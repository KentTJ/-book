# 进程与子进程

参考： [C++ 多进程，父进程监控子进程 - 代码先锋网 (codeleading.com)](https://codeleading.com/article/60953963187/)          https://codeleading.com/article/60953963187/

```java
 #include <unistd.h>
 #include <sys/types.h>
 #include <stdlib.h>
 #include <signal.h>
 #include <stdio.h>
 #include<sys/wait.h>
 

 //子进程个数
 #define SUB_PRO_COUNT 10

 //处理子进程的退出信号
 void sub_quit_signal_handle(int sig);

 //父进程的事件循环
 void ParentCycle();

 //子进程的事件循环
 void ChildCycle();

 int main(void)
 {
     pid_t  pid;
     int i;

     //创建SUB_PRO_COUNT个子进程
     for(i=0; i<SUB_PRO_COUNT; i++)
     {
         pid = fork();
         printf("cg, this process id: %d, i: %d, fork, pid: %d\\n", getpid(), i, pid);
         if( 0 == pid || -1 == pid )
             break;
     }

     //创建子进程失败
     if( -1 == pid )
     {
         printf("No. %d: fork error\\n", i);
     }
     //子进程的事件循环
     else if( 0 == pid )
     {
         printf("cg, this process id: %d, ChildCycle, pid: %d\\n", getpid(), pid);
         ChildCycle();
     }
     //父进程的事件循环
     else
     {
         printf("cg, this process id: %d, ParentCycle, pid: %d\\n", getpid(), pid);
         ParentCycle();
     }

     return 0;
 }

 void sub_quit_signal_handle(int sig)
 {
     printf("sub_quit_signal_handle, this process: %d\\n", getpid());
     int status;
     //获取退出的那个子进程的状态
     int quit_pid = wait(&status);
     printf("sub process %d quit, exit status %d\\n", quit_pid, status);

     //新创建一个子进程
     //pid_t pid = fork();
     //if( 0 == pid )
       //   ChildCycle();
 }

 void ParentCycle()
 {
     printf("Parent process1 %d\\n", getpid());
     signal(SIGCHLD, sub_quit_signal_handle);    // todo:
     printf("Parent process2 %d\\n", getpid());
     while(1){
         printf("Parent process3 %d\\n", getpid());
         pause();
     };
 }

 void ChildCycle()
 {
     printf("create sub process id: %d, parent id: %d\\n", getpid(), getppid());
     while(1){
         pause();
     };
 }
 
```

-----------------> 一行关键代码：

```java
 signal(SIGCHLD, sub_quit_signal_handle);  // 父进程，收到child的信号  ------>【1】  为啥这行不会阻塞？
```

~~次要：调用处理，获取具体信息~~

```java
 //获取退出的那个子进程的状态
 int quit_pid = wait(&status);
 printf("sub process %d quit, exit status %d\\n", quit_pid, status);
```

TODO: 【1】为什么没有阻塞？后面SIGCHLD却可以唤醒 主进程！！！！！

[【信号】SIGCHLD信号-CSDN博客](https://blog.csdn.net/isunbin/article/details/84032708?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&utm_relevant_index=2)            https://blog.csdn.net/isunbin/article/details/84032708?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2~default~BlogCommendFromBaidu~Rate-1-84032708-blog-127649401.235^v38^pc_relevant_sort_base1&utm_relevant_index=2





