{"./":{"url":"./","title":"Introduction","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction ls -la console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/":{"url":"coding/","title":"Coding","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/":{"url":"coding/Andriod/","title":"Andriod","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/AMS_.html":{"url":"coding/Andriod/AMS_.html","title":"AMS","keywords":"","body":"1. 目录2. 超级0层图: AMS-APP-WMS2.1. 桥梁 合理性证明2.1.1. AMS与APP2.1.2. WMS与APP2.2. 基于架构的结论：3. 基于0层架构图4. AMS启动流程5. AMS 启动APP startActivity6. AMS模块做了哪些事情7. AMS类做了哪些事情 ---从属性角度7.1. 相关重要类7.1.1. ProcessRecord 数据结构7.1.2. ProcessRecord容器7.1.3. 内部四大组件记录表的容器8. AMS如何管理进程的 TODO9. Activity 四种启动模式10. Task概念 ，即TaskRecord10.1. 1层结构10.2. Task前后台概念:10.3. 不同场景，任务栈的变化10.3.1. 总之：10.3.2. APP1 的Activity1 启动 APP2 的Activity210.3.3. launcher（APP1）启动 APP2 的Activity211. Activity的七大生命周期11.1. 一个Activity的生命周期11.1.1. 相邻状态之间的区别11.1.2. 场景：11.2. 两个的组合11.2.1. 场景（基于模型给出解释）11.2.2. 其他一些疑问11.3. 代码（与模型的对比）12. Activity的启动模式13. TODO:13.1. appToken14. 参考：15. AMS相关的面试题目：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 超级0层图: AMS-APP-WMS 桥梁 合理性证明 AMS与APP WMS与APP 基于架构的结论： 基于0层架构图 AMS启动流程 AMS 启动APP startActivity AMS模块做了哪些事情 AMS类做了哪些事情 ---从属性角度 相关重要类 ProcessRecord 数据结构 ProcessRecord容器 内部四大组件记录表的容器 AMS如何管理进程的 TODO Activity 四种启动模式 Task概念 ，即TaskRecord 1层结构 Task前后台概念: 不同场景，任务栈的变化 总之： APP1 的Activity1 启动 APP2 的Activity2 launcher（APP1）启动 APP2 的Activity2 Activity的七大生命周期 一个Activity的生命周期 相邻状态之间的区别 场景： 锁屏 两个的组合 场景（基于模型给出解释） 前进：同进程 ActivityA 调用 ActivityB 后退：同进程 back键 ，ActivityB返回ActivityA 两个进程：ActivityA （比如launcher）调用 ActivityB 点击Home键 旋转屏幕 弹窗 其他一些疑问 代码（与模型的对比） Activity的启动模式 TODO: appToken 参考： AMS相关的面试题目： 1. 目录 [TOC] 2. 超级0层图: AMS-APP-WMS https://ericchows.github.io/Android-Window-Mechanism/ 2.1. 桥梁 合理性证明 2.1.1. AMS与APP 其中桥梁： IWindowManager和IAcitivityManger 是一个自然的桥梁，客户端对wms和AMS的引用~~ ----》系统服务 开机初始化 注册的缘故 2.1.2. WMS与APP APP-> WMS两个桥梁： 【1】IWindowManager，进程级：System private interface to the window manager. 进程级的。窗口级不从这里过 【2】IWindowSession，进程级，但被参数限制了成了窗口级：System private per-application interface to the window manager. 证明： mWindowSession = WindowManagerGlobal.getWindowSession(); //cg: Single Instance in procsse 是单例，进程级 int addToDisplay(IWindow window,........) // IWindow解决了 mWindowSession 是一对多问题 void remove(IWindow window); WMS->APP 桥梁： 【3】IWindow 是窗口级 1、为什么要有两个APP-> AMS？ 一个级别，做一个级别的事情 2、为什么IWindowSession不能弄成像IWindow 真正是窗口级的？ 一个IWindowSession对应一个线程，多个就会有很多线程了 -----》 浪费资源 TODO: 从设计角度： 一个低级别的类（资源）一般来说会有多份，如果这个类是一个比较消耗资源的（内存、线程资源）。 设计思路：变成一个单例，以参数区分不同低级别 3、自然：【1】搭建【2】，【2】搭建【3】 TODO: mWindowSession所有方法的第一个参数，是IWindow 。 这样就？？？？？ 桥梁Iwindow1: 桥梁Iwindow2: 桥梁-----------------Iwindow2-----------> windowManagerIml----> WMS 有两条路： 1、路1：转到ViewRootIml ，走 IWindowSession 2、路2：直接走Iwindow 2.2. 基于架构的结论： 1、从系统角度来看，是看不到view的---------view体系只是window的一部分，是window的显示 TODO: 通过生活化模型，记忆流程性 图（动图）。。。。。那么如何记忆类图（静图）呢？ 3. 基于0层架构图 所处的位置：SystemServer进程，AMS运行在一个Binder线程里 ----》 TODO: 这个Binder线程什么时候创建的？ Binder线程池？ 疑问：如果每个服务有一个Binder线程，那么线程肯定不够，90个服务 TODO: 个人理解：应该是 Binder线程池，谁要用谁用 // system_server的所有线程： \u001buThreads: 122 total, 0 running, 122 sleeping, 0 stopped, 0 zombie Mem: 3.6G total, 3.0G used, 672M free, 25M buffers Swap: 512M total, 0 used, 512M free, 1.4G cached 400%cpu 11%user 0%nice 37%sys 351%idle 0%iow 0%irq 0%sirq 0%host \u001b[7m TID USER PR NI VIRT RES SHR S[%CPU] %MEM TIME+ THREAD \u001b[0m 1441 system RT -8 7.5G 258M 186M S 2.8 6.8 0:02.35 SensorService 6791 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.15 Binder:1270_11 6103 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.15 Binder:1270_10 3865 system 20 0 7.5G 258M 186M S 0.0 6.8 1:11.68 Binder:1270_F 3716 system 20 0 7.5G 258M 186M S 0.0 6.8 0:03.74 Binder:1270_E 3519 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 AsyncQueryWorke 3149 system 20 0 7.5G 258M 186M S 0.0 6.8 1:35.48 Binder:1270_D 3127 system 16 -4 7.5G 258M 186M S 0.0 6.8 0:00.09 RenderThread 2641 system 30 10 7.5G 258M 186M S 0.0 6.8 0:00.24 backup-0 2636 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.31 Binder:1270_C 2635 system 20 0 7.5G 258M 186M S 0.0 6.8 0:18.02 Binder:1270_B 2606 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 pool-2-thread-1 2600 system 30 10 7.5G 258M 186M S 0.0 6.8 0:00.02 LazyTaskWriterT 2213 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 AdbDebuggingMan 2015 system 18 -2 7.5G 258M 186M S 0.0 6.8 0:00.00 queued-work-loo 1926 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 HwBinder:1270_5 1923 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 ConnectionSvrFo 1922 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 CallAudioModeSt 1920 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.00 uteStateMachine 1914 system 20 0 7.5G 258M 186M S 0.0 6.8 0:00.21 HwBinder:1270_4 AMS: 组件管理(虽然叫AMS) : Activity service provider broadcast android10增加了 : ATMS(ActivityTaskManagerService)，目的AMS管理太多了，把Activity 的管理抽出来给ATMS~。自然 ActvityManagerServcie的重要功能: start() 函数知道: 1)启动 CPU 监控线程; 2) 注册电池状态和权限管理服务 startObservingNativeCrashes（） 函数知道： 监听所有的crash事件 setSystemProcess()函数知道： 添加各种管理app状态信息的服务还有进程等等信息 SystemServiceManager忽略掉，只是SystemServer startService功能的抽取，自然 4. AMS启动流程 都是在SystemServer中，通过SytemServiceManager启动的 -----》 见系统启动流程 5. AMS 启动APP startActivity 见应用启动流程 6. AMS模块做了哪些事情 基于 超级0层图: AMS-APP-WMS 1、IActivityManager接口： 引用 AMS的Binder 具体做了：比如： attachApplication //塞App的binder给AMS startActivity // 启动一个Actvity finishActivity startService // stopService\\ bindService 2、socket 7. AMS类做了哪些事情 ---从属性角度 TODO: 从属性总结，可以得到精华 参考：《AMS预习资料.pdf》 ----> 非常好的资料 TODO: 如何认识一个模块？-----角度： 1、从哪里来： 2、是什么？ 3、模块内核心类 4、重要的纵向流程 7.1. 相关重要类 7.1.1. ProcessRecord 数据结构 一句话功能： 主要是在 AMS侧记录 进程相关信息 ，自然，很直白，ProcessRecord 站在AMS角度来看，Record Process 的目的，就是管理APP ，自然 ProcessRecord （AMS） = APP进程 绑定关系：AMS: 一个进程列表ProcessList（系统级）: 多个 ProcessRecord（应用级）: 一个applicationThread（AMS侧）------最初由APP侧流转到AMS侧 // ProcessList.java /** * List of running applications, sorted by recent usage. * The first entry in the list is the least recently used. */ final ArrayList mLruProcesses = new ArrayList(); // List of running, 自然，不得不这样 /** * The currently running isolated processes. */ final SparseArray mIsolatedProcesses = new SparseArray<>(); // TODO: isolated processes是啥？？？ /** * Processes that are being forcibly torn down. */ final ArrayList mRemovedProcesses = new ArrayList(); // -----> 结论：ProcessRecord，从数据结构角度：是多个ArrayList。 具体记录的信息有： 第一类数据：描述身份的数据 1.ApplicationInfo info：AndroidManifest.xml中定义的Application信息 2.boolean isolated：是不是isolated进程 3.int uid：进程uid 4.int userId：这个是android做的多用户系统id，就像windows可以登录很多用户一样，android 也希望可以实现类似的多用户 5.String processName：进程名字，默认情况下是包名 6.UidRecord uidRecord：记录已经使用的uid 7.IApplicationThread thread：这个很重要，它是ApplicationThread的客户端，AMS就是通过这 个对象给apk进程发送异步消息的（管理四大组件的消息），所以只有这个对象不为空的情况下， 才代表apk进程可是使用了 8.int pid：进程的pid 9.String procStatFile：proc目录下每一个进程都有一个以pid命名的目录文件，这个目录下记载着 进程的详细信息，这个目录及目录下的文件是内核创建的， proc是内核文件系统，proc就是 process的缩写，涉及的目的就是导出进程内核信息 10.int[] gids：gid组 11.CompatibilityInfo compat : 兼容性信息 12.String requiredAbi : abi信息 13.String instructionSet : 指令集信息 第二类数据：描述进程中组件的数据 第三类数据：描述进程状态的数据 第四类数据：和pss相关的数据 第五类数据：和时间相关的数据 第六类数据：crash和anr相关的数据 第八类数据：电源信息和调试信息 .............见： AMS 预习资料.pdf 7.1.2. ProcessRecord容器 永久性容器 临时性容器 一个特别的容器 7.1.3. 内部四大组件记录表的容器 8. AMS如何管理进程的 TODO 图： AMS管理和启动Application流程.pdf 参考文章：https://mp.weixin.qq.com/s/H8RPu77Y7IDRxEcVYJGPfg 9. Activity 四种启动模式 说明： 1、自下而上越来越严格 2、栈顶复用模式singleTop：即该Activity处于任务栈栈顶，即下图： 3、singleInstance单实例：所有栈只有一个实例 ----> 自然，次再使用的时候，直接使用这个栈。比如打电话应用就是一个singleStance模式启动的activity 各种模式的应用场景： 具体 TODO 10. Task概念 ，即TaskRecord 参考： https://blog.csdn.net/Smile_729day/article/details/122241576 https://blog.csdn.net/Jason_Lee155/article/details/116571487 ActivityRecord、TaskRecord、ActivityStack相互关系以及Activity启动模式 https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 图： Activity代码属于Application，但是Task属于Android操作系统，跨越了不同的process Task概念: 从用户角度来看，Task 应该就是跳跳跳 (任务级,可能多个APP进程) ~~正式表述：用户在执行某项工作时与之互动的一系列 Activity 的集合~~ 从用户角度来看， 即是一个Task对应一个TaskRecord ----> 所以，程序员应该从TaskRecord角度理解各种 场景 查看task的命令： adb shell dumpsys activity activities adb shell dumpsys activity activities | sed -En -e '/Stack #/p' -e '/Running activities/,/Run #0/p' dump出的一个stack进行分析: Display #0 (activities from top to bottom): // Display #0 代表第一个屏幕。安卓可能存在多个屏幕，投屏 Stack #4: type=standard mode=fullscreen //Stack信息 isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #51 //Task信息 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} userId=0 effectiveUid=u0a128 mCallingUid=u0a28 mUserSetupComplete=true mCallingPackage=com.cyanogenmod.trebuchet affinity=android.tplink.sjj.teststack intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=android.tplink.sjj.teststack/.MainActivity} //启动信息，包括启动源和被启动app的MainActivity realActivity=android.tplink.sjj.teststack/.MainActivity autoRemoveRecents=false isPersistable=true numFullscreen=2 activityType=1 rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE **Activities=[ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51}, ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51}]** //当前栈中Activity记录 askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} stackId=4 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mSupportsPictureInPicture=false isResizeable=true lastActiveTime=256734507 (inactive for 30s) * Hist #1: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} //栈中Activity调用历史（最近的） packageName=android.tplink.sjj.teststack processName=android.tplink.sjj.teststack launchedFromUid=10128 launchedFromPackage=android.tplink.sjj.teststack userId=0 app=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} Intent { flg=0x10000000 cmp=android.tplink.sjj.teststack/.FirstActivity } frontOfTask=false task=TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} taskAffinity=android.tplink.sjj.teststack realActivity=android.tplink.sjj.teststack/.FirstActivity baseDir=/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/base.apk dataDir=/data/user/0/android.tplink.sjj.teststack splitDir=[/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/split_lib_dependencies_apk.apk, ......................................... fullscreen=true noDisplay=false immersive=false launchMode=2 frozenBeforeDestroy=false forceNewConfig=false mActivityType=standard waitingVisible=false nowVisible=true lastVisibleTime=-33s65ms resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false * Hist #0: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} //同上，这是在上个历史之前的 packageName=android.tplink.sjj.teststack processName=android.tplink.sjj.teststack launchedFromUid=10028 launchedFromPackage=com.cyanogenmod.trebuchet userId=0 app=ProcessRecord{ebe742c 31812:android.tplink.sjj.teststack/u0a128} Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=android.tplink.sjj.teststack/.MainActivity bnds=[24,204][192,398] } frontOfTask=true task=TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} taskAffinity=android.tplink.sjj.teststack realActivity=android.tplink.sjj.teststack/.MainActivity baseDir=/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/base.apk dataDir=/data/user/0/android.tplink.sjj.teststack splitDir=[/data/app/android.tplink.sjj.teststack-Cu_ETALVG7u-Plh9vUC5Ug==/split_lib_dependencies_apk.apk, fullscreen=true noDisplay=false immersive=false launchMode=0 frozenBeforeDestroy=false forceNewConfig=false mActivityType=standard waitingVisible=false nowVisible=false lastVisibleTime=-36s658ms resizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mLastReportedMultiWindowMode=false mLastReportedPictureInPictureMode=false ....................................... Running activities (most recent first): //最近该任务栈中活动了的Activity，按最近时间排列 TaskRecord{e0bdfdf #51 A=android.tplink.sjj.teststack U=0 StackId=4 sz=2} Run #1: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} Run #0: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} mResumedActivity: ActivityRecord{898d92a u0 android.tplink.sjj.teststack/.FirstActivity t51} //当前页面Activity mLastPausedActivity: ActivityRecord{4542de6 u0 android.tplink.sjj.teststack/.MainActivity t51} //最后一个退出前台的Activity .......................... task启动方式: launcher(第三方应用跳转不会)、通知 task恢复的方式: Recents与back button 10.1. 1层结构 参见：https://blog.csdn.net/Jason_Lee155/article/details/116571487 好文 通常情况下： 一个APP----》最多一个ActivityStack（可能其他APP启动的，则没有自己的ActivityStack）--------对应一个 TaskRecord（例外：存在多个） 一个 ActivityStack 对应多个 TaskRecord的情况： 见： https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 10.2. Task前后台概念: 如果这时候用户按下Home键,则这个Task 会从前台切换到后台 ---》即1层结构中 HomeStack与FocusedStack交 换? 10.3. 不同场景，任务栈的变化 10.3.1. 总之： 1、Launcher与普通的startActivity差异在于: 是否会创建任务栈? -------》 只有这样才自然, 想表达的点: 任务是从laucher点击开 始的 跳跳跳 TODO: 如何证明？ 2、结论：（1）不论是否同进程，**同一个任务栈**变化基本上都是： （3）注意back时，栈顶的 activty会destroyed 3、生命周期： 1、Task新建: launcher启动 launcher启动 打开另外一个新的应用, 默认情况下,这个新的应用期望加入到 Task name为自己包名的Task 中, （自然） 如果该Task 不存在,则创建一个新的Task,并且该Task 的默认 name 和该应用的包名相同, --》 自然，推论 如果期望的 Task 存在,则直接复用原有的 Task, 如果该 Task 处于后台, 则需要把整个Task 转移到前台 --》 自然，推论 2、 Task的切换 ： 即 3、 Activity的切换 ： Activity向前跳转： 在当前 Activity 启动另一个Activity时, 新的Activity 将被推送到 TaskRecord 顶部并获得焦点（TODO: 焦点具体什么概念呢）。上一个 Activity 仍保留在堆栈中, 但会停止（TODO: pause还是stop？）。当 Activity 停止时, 系统会保留其界面的当前状态。自然 当用户按 Back： 当前 Activity 会从 TaskRecord 顶部退出(该 Activity 销毁 destroyed，自然)， 上一个Activity 会恢复(界面会恢复到上一个状态)。TaskRecord 中的 Activity 永远不会重新排列, 只会被送入和退出(自然,这是栈结构,只能如此), 4、销毁 移除 TaskRecord 中的所有Activity后,该 Task 将不复存在。自然 10.3.2. APP1 的Activity1 启动 APP2 的Activity2 结论： 任务栈还是APP1的，自然 证明： Display #0 (activities from top to bottom): Stack #16: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #25 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{d75f457 #25 A=com.example.myhandlerdemo U=0 StackId=16 sz=2} // 第一个应用的 任务栈TaskRecord userId=0 effectiveUid=u0a128 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 affinity=com.example.myhandlerdemo intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.example.myhandlerdemo/.MainActivity} mActivityComponent=com.example.myhandlerdemo/.MainActivity autoRemoveRecents=false isPersistable=true numFullscreen=2 activityType=1 rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{5105c0f u0 com.example.myhandlerdemo/.MainActivity t25}, ActivityRecord{b2a437e u0 com.example.sourceCode/.MainActivity t25}] Running activities (most recent first): TaskRecord{d75f457 #25 A=com.example.myhandlerdemo U=0 StackId=16 sz=2} // 第一个应用的 任务栈TaskRecord Run #1: ActivityRecord{b2a437e u0 com.example.sourceCode/.MainActivity t25} // 第二个应用的 处于栈顶 Run #0: ActivityRecord{5105c0f u0 com.example.myhandlerdemo/.MainActivity t25} 10.3.3. launcher（APP1）启动 APP2 的Activity2 则会启动 新的任务栈。自然，launcher是任务栈的起点 从任务栈角度来看：基于1层结构图 新增了一个任务栈，即 ActivityStackSupervisor中的 mFocusedStack 11. Activity的七大生命周期 11.1. 一个Activity的生命周期 实际上，永远不存在一个孤立的activty的 化简： 杀掉进程场景，见下 onPause 阶段返回，极端场景 -----》因为onPause 下台，是个暂时态，很短时间 可见，只考虑一个activity，其状态是很简单的：就两条路 按组记忆： 图：从4个视角理解安卓activity的启动模式pptx 11.1.1. 相邻状态之间的区别 1.onCreate和onStart之间有什么区别？ （1）可见与不可见的区别。前者不可见，后者可见。 自然，可见性 （2）执行次数的区别， 自然。onCreate方法只在Activity创建时执行一次，而onStart方法在Activity的切换以及按Home键返回桌面再切回应用的过程中被多次调用。因此Bundle数据的恢复在onStart中进行比onCreate中执行更合适。（3）onCreate能做的事onStart其实都能做，但是onstart能做的事onCreate却未必适合做。如前文所说的，setContentView和资源初始化在两者都能做，然而想动画的初始化在onStart中做比较好。 2.onStart方法和onResume方法有什么区别？ （1）是否在前台。onStart方法中Activity可见但不在前台，不可交互，而在onResume中在前台 （2）职责不同，onStart方法中主要还是进行初始化工作，而onResume方法，根据官方的建议，可以做开启动画和独占设备的操作。 3.onPause方法和onStop方法有什么区别？ （1）是否可见。onPause时Activity可见，onStop时Activity不可见，但Activity对象还在内存中。 （2）在系统内存不足的时候可能不会执行onStop方法，因此程序状态的保存、独占设备和动画的关闭、以及一些数据的保存最好在onPause中进行，但要注意不能太耗时 ---》 自然，瞬态 4.onStop方法和onDestroy方法有什么区别？ onStop阶段Activity还没有被销毁，对象还在内存中，此时可以通过切换Activity再次回到该Activity，而onDestroy阶段Acivity被销毁 11.1.2. 场景： 锁屏 从onPause---------> onStop 11.2. 两个的组合 Todo：场景有哪些 1、组合对一个的影响 2、组合对两个的影响 生活类比： 舞台演员演出模型： onCreate 舞台后刚招来一个人，作为演员 onStart 开始化妆，但是还没有到前台 onResume 这个人到前台表演 运行runing onPause 导演说要换人，演员退到后台 onstop 不演了，卸妆 onDestroy 杀人，撵人滚蛋（Activity即将被销毁） onRestart 很自然，让stop重新回到start：即卸完妆又化妆 规则一： 所有演员下到后台，有一个stack。因为结束后，要按照上场相反顺序，重新亮相 ----> 模拟back键 导演： 所有Activity生命周期 幕后的操作者Ams： --->生命周期的方法都由其触发调用（通过Binder） Activity的状态在AMS侧是ActivitySatck维护的 -----》同步到 APP，即生命周期函数 由模型，一些不得不的东西： 1、onCreate 招人 与 onDestroy 撵人滚蛋 是一组 创建过程，比如整个view树，绑定 ---》自然 2、onStart 开始化妆 与 onStop 卸妆 ，是一组 这两组标志着是否 TODO: 已经渲染好了？？？，只是没有到前台 3、onResume 到前台 与 onPause 到后台，是一组 这两组标志着是否到前台 ---》自然 这两组是一个暂时态，一般时间很短 ---》自然 11.2.1. 场景（基于模型给出解释） 前进：同进程 ActivityA 调用 ActivityB 基于模型，自然·： A先下台onPause（A后面的事情先不管） B招进来onCreate，化妆 onStart，到舞台表演onResume A 卸妆onStop A下台之后，为啥不安排A 卸妆onStop呢？ 这是自然的，因为是串行，优先让B 上台表演（观众是上帝），最后执行A的 卸妆 注：如果ActivityB之前已经启动(已经在栈里了)： ActivityB走onRestart，其他不变 ---》自然 后退：同进程 back键 ，ActivityB返回ActivityA 基于模型，自然·： B下台 （B后面的事情先不管） A 重新化妆onRestart，化妆 onStart , 上台onResume B 实际上没有用了，走完最后生命周期：卸妆onStop，走人onDestroy 后退比前进多了一个onDestroy，原因在于： 因为栈的原因， 后退的时候，当前页面没有用了，销毁掉 前进的时候，当前页面要保存在栈里 两个进程：ActivityA （比如launcher）调用 ActivityB 由APP启动流程知道： ActivityA 先onPause，之后ActivityB走...... ----->结论： 与同进程的生命周期一样 注：如果ActivityB之前已经启动(已经在栈里了)： ActivityB走onRestart，其他不变 ---》结论： 与同进程的生命周期一样 点击Home键 退出舞台，演员卸妆 即 Activity将会处于不可见的状态，当前Activity会执行生命周期onStop 旋转屏幕 参考： https://www.jianshu.com/p/eff8496dbf0e 旋转屏幕 ，即 一个演员先下台，走人后，明天再上台 onPause() -> onStop() -> onDestroy() onCreate() -> onStart() -> onResume() ------》结论： 自然，相当于先关闭再重启 弹窗 弹出 Dialog 对生命周期有什么影响 1、我们知道，生命周期回调都是 AMS 通过 Binder 通知应用进程调用的；而弹出 Dialog、Toast、PopupWindow 本质上都直接是通过 WindowManager.addView() 显示的（没有经过 AMS），所以不会对生命周期有任何影响。 如果是启动一个 Theme 为 Dialog 的 Activity , 则生命周期为： A.onPause -> B.onCrete -> B.onStart -> B.onResume 注意这边没有前一个 Activity 不会回调 onStop，因为只有在 Activity 切到后台不可见才会回调 onStop；而弹出 Dialog 主题的 Activity 时前一个页面还是可见的，只是失去了焦点而已所以仅有 onPause 回调。 11.2.2. 其他一些疑问 https://zhuanlan.zhihu.com/p/190151810 给 onPause 一个精准的描述的话，应该是 非前台，不可交互，但不一定不可见 。 ---》 符合模型 11.3. 代码（与模型的对比） 12. Activity的启动模式 四种启动模式： 13. TODO: 13.1. appToken what，作用： token--------本质：activity包名？ 作用： TODO: 表征哪个activity：在APP、AMS、WMS 三个线程中，表征当前的window是哪个activity的？ when，生于： 参考： https://www.bilibili.com/video/BV1pb4y1B7TW/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 14. 参考： https://www.jianshu.com/p/eb2ff0bc64a0 AMS重要的数据结构解析（三）：ActivityStack 15. AMS相关的面试题目： 请描述 Android 中的 Activity 生命周期。 见上 解释一下 Android 中的任务（Task）和返回栈（Back Stack） 请描述如何使用 Android AMS 启动新活动。 请描述 Android AMS 如何管理应用程序的内存。 解释一下 Android AMS 如何处理多窗口（Multi-Window）支持。 请详细说明 Android AMS 的工作原理。 解释一下 Android AMS 如何创建新活动实例。 请描述 Android AMS 如何管理活动的状态。 请描述如何使用 Android AMS 关闭不再使用的活动。 解释一下 Android AMS 如何处理应用程序间的消息传递。 请描述如何在 Android 中使用 AMS 管理多个进程。 请说明 Android AMS 如何处理应用程序的安装和卸载。 请描述如何使用 Android AMS 管理应用程序的权限。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/AndriodIPC.html":{"url":"coding/Andriod/AndriodIPC.html","title":"Andriod IPC","keywords":"","body":"1. 目录2. 序列化2.1. 序列化的本质是啥？2.2. 安卓序列化源码分析2.2.1. 0层2.2.2. J_parcel的获取与recycle()2.2.3. //3构造的过程是怎样的？2.2.4. parcel与Ibinder的关系？？？3. 进程设计的意义/初衷3.1. 进程天然内存隔离，系统为什么采用多进程呢？3.2. APP的多进程3.3. 总结 涉及到IPC的场景4. 进程间通信（IPC）---Binder4.1. 前戏4.1.1. Linux IPC通信方式的种类：4.1.2. Parcel + Parcelable4.2. 0层流程-----一次Binder通信4.3. 0层结构-----Binder架构（存在三个ipc）4.4. 功能实现之管理结构(后面拆除掉)4.4.1. 管理模型，类似于其他C/S架构4.5. 功能实现之核心结构4.6. Binder的创建4.6.1. Binder是什么4.6.2. Binder驱动的创建时机4.6.3. Binder的注册时机4.7. AIDL4.8. 分析一次Binder调用(核心)4.8.1. client--->BinderProxy--->binder驱动4.8.2. binder驱动--->BinderProxy--->server4.9. binderService流程4.10. Binder的 同步调用 / 异步调用4.10.1. 异步4.11. 优缺点：4.12. 实现机制4.13. 参考：4.14. 其他细节4.14.1. binder安全机制4.14.2. 一些函数4.15. 参考4.16. 面试题5. 线程间通信-----Handler5.1. 前言---从应用角度5.1.1. 使用目的：5.1.2. 其他 线程通信的方式5.1.3. Handler场景例子详解5.1.4. 使用逻辑：5.2. 0层模型----锚点5.3. 1层架构图：5.4. 串线之驴子：Looper.loop()--基于0层模型图5.5. 不得不之 Looper线程唤醒（核心）5.6. 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）：5.6.1. 问题：何时切的主线程呢？？？5.6.2. for 确定一直在循环嘛6. 1 、线程如何block？？？？6.1.1. 次要补充： msg获取6.1.2. 次要补充： 新消息入队规则：6.2. 机制 --> 如何完成线程切换的：6.3. 补充1：准备消息循环looper6.4. 从架构师 角度看Handler6.5. 关于 MessageQueue6.6. Handler容易导致的内存泄漏6.7. ThreadLocal机制6.7.1. 相关问题6.8. 消息屏障6.8.1. 从设计角度，看 消息屏障6.9. 使用注意事项6.10. 疑问6.10.1. 子线程发一个消息6.11. 相关面试题6.11.1. 一个线程可以有几个Looper？可以有几个Handler？6.11.2. 线程安全问题：6.11.3. 多对一、多对多6.11.4. 取消息函数next（）为啥也加锁了？6.11.5. Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？6.11.6. Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？6.11.7. Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done6.11.8. Handler 消息阻塞 为什么不会导致应用卡死？6.11.9. handler实现延时任务 VS Timer延时任务(计时器)6.11.10. 总结6.12. TODO: epoll与select区别6.13. 安卓系统根本动力7. 线程、进程（抛开安卓、抛开语言）7.1. 线程同步/异步（功能）7.1.1. 与 互斥的区别：7.1.2. 支撑 线程同步 功能的结构7.1.3. 线程同步与线程通信的关系7.2. 线程互斥/非互斥（功能）7.2.1. 支撑线程互斥功能的结构7.3. 线程通信(功能)7.3.1. 支撑线程通信功能的结构8. TODO: 上面Handler和Binder分析方式完全不一样9. 格式9.1. 使用逻辑：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 序列化 序列化的本质是啥？ 安卓序列化源码分析 0层 J_parcel的获取与recycle() //3构造的过程是怎样的？ parcel与Ibinder的关系？？？ 进程设计的意义/初衷 进程天然内存隔离，系统为什么采用多进程呢？ APP的多进程 总结 涉及到IPC的场景 进程间通信（IPC）---Binder 前戏 Linux IPC通信方式的种类： 内存共享 管道 消息队列 socket 信号量 为啥安卓要重新做一个Binder呢（对比）？ Parcel + Parcelable 0层流程-----一次Binder通信 0层结构-----Binder架构（存在三个ipc） 功能实现之管理结构(后面拆除掉) 管理模型，类似于其他C/S架构 功能实现之核心结构 Binder的创建 Binder是什么 Binder驱动的创建时机 Binder的注册时机 AIDL 分析一次Binder调用(核心) client--->BinderProxy--->binder驱动 binder驱动--->BinderProxy--->server binderService流程 Binder的 同步调用 / 异步调用 异步 例子： 优缺点： 实现机制 参考： 其他细节 binder安全机制 一些函数 参考 面试题 线程间通信-----Handler 前言---从应用角度 使用目的： 其他 线程通信的方式 Handler场景例子详解 使用逻辑： 0层模型----锚点 1层架构图： 串线之驴子：Looper.loop()--基于0层模型图 不得不之 Looper线程唤醒（核心） 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）： 问题：何时切的主线程呢？？？ for 确定一直在循环嘛 1 、线程如何block？？？？ 次要补充： msg获取 次要补充： 新消息入队规则： 机制 --> 如何完成线程切换的： 补充1：准备消息循环looper 从架构师 角度看Handler 关于 MessageQueue Handler容易导致的内存泄漏 ThreadLocal机制 相关问题 消息屏障 从设计角度，看 消息屏障 使用注意事项 疑问 子线程发一个消息 相关面试题 一个线程可以有几个Looper？可以有几个Handler？ 线程安全问题： 多对一、多对多 取消息函数next（）为啥也加锁了？ Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？ Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？ Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done Handler 消息阻塞 为什么不会导致应用卡死？ handler实现延时任务 VS Timer延时任务(计时器) 总结 TODO: epoll与select区别 安卓系统根本动力 线程、进程（抛开安卓、抛开语言） 线程同步/异步（功能） 与 互斥的区别： 支撑 线程同步 功能的结构 关于锁的深入 线程同步与线程通信的关系 线程互斥/非互斥（功能） 支撑线程互斥功能的结构 线程通信(功能) 支撑线程通信功能的结构 TODO: 上面Handler和Binder分析方式完全不一样 格式 使用逻辑： 1. 目录 [TOC] 2. 序列化 2.1. 序列化的本质是啥？ Java序列化的本质是将Java对象保存为二进制字节码。-----> 进而可以传输 + 存储 传输有哪些，传输为什么要序列化？ 传输：网络传输、进程间通信IPC 为什么？----> 本质在于：同一进程间，对象的传递 传地址内存。。。同一进程有统一的内存 不同进程间，内存是独立的 存储为什么序列化？？（-----> 电脑上存储都是二进制的） 一座大厦好比一个对象，你要把这座大厦搬到另外一个地方去，你想直接挪肯定不行吧？(一般来说，只有传值，没有传对象)但我可以搬砖头吧，一个一个搬，然后搬到目的地重新组合成一个大厦，而序列化就起到了将大厦分成砖头的作用. TODO：最底层逻辑，如何做到的呢？？？ TODO：为什么会很高效？？？没有序列化结构，只是序列化数据 补充:HW笔记 序列化结果: 字节序列 2.2. 安卓序列化源码分析 --->Parcel序列化 2.2.1. 0层 https://blog.csdn.net/tkwxty/article/details/107916160 内核 Todo：内核调用怎么理解？？？--->系统调用 用户空间与内核空间怎么理解？？？ 2.2.2. J_parcel的获取与recycle() //parcel.java private static final Parcel[] sOwnedPool = new Parcel[POOL_SIZE];//1 6个对象的对象池 public static Parcel obtain() { final Parcel[] pool = sOwnedPool; synchronized (pool) { Parcel p; for (int i=0; i但是有其他引用 if (DEBUG_RECYCLE) { p.mStack = new RuntimeException(); } p.mReadWriteHelper = ReadWriteHelper.DEFAULT;//todo:作用？？？ return p; } } } return new Parcel(0);//3 新建，没加入对象池里面！ } //1 用了对象池：1、由于parcel对象创建+释放的非常频繁---->消耗资源 2、不是轻量级对象 // 3 自然的，没加入代表在使用---->recycle时，有可能加入对象池（前提：有空位）,见#3_1 public final void recycle() { if (DEBUG_RECYCLE) mStack = null; freeBuffer(); final Parcel[] pool; if (mOwnsNativeParcelObject) { pool = sOwnedPool; } else { mNativePtr = 0; pool = sHolderPool; } synchronized (pool) { for (int i=0; i 2.2.3. //3构造的过程是怎样的？ //Parcel.java private Parcel(long nativePtr) { if (DEBUG_RECYCLE) { mStack = new RuntimeException(); } init(nativePtr); } 2.2.4. parcel与Ibinder的关系？？？ 3. 进程设计的意义/初衷 我们谈到IPC，那么其实就有疑问了，不要有那么多进程不就行了？不就不存在进程隔离了吗？ 3.1. 进程天然内存隔离，系统为什么采用多进程呢？ ----安全(隔离)/稳定/内存分配 3.2. APP的多进程 一个APP为啥要做成 多进程？见下图： 主要（也是开发技巧）： 1、突破522M内存限制（虚拟机给一个java进程的） 2、稳定：将 需要稳定的重要代码与不稳定的分离开，不至于一起crash ​ 比如 微信的消息 接受功能。不能因为微信界面进程crash，而收不到消息！！！！！！，不然信息丢掉了 举例子： QQ等应用就是多线程 3.3. 总结 涉及到IPC的场景 APP进程间、APP进程与FrameWork的系统进程、FrameWork的系统进程与native（部分是jni） native 与 kernel进程之间（TODO: 跨了进程？） 4. 进程间通信（IPC）---Binder 4.1. 前戏 因为要谈论andriod的Binder，不得不： 2、为啥不用linux本身的，为啥andriod自己要开发一套Binder机制？（即优缺点） 1、-----> 自然，先要列举一下Linux本身的IPC通信方式 4.1.1. Linux IPC通信方式的种类： 1、2、3、4、5、6 注意：c嵌入式开发，经常使用信号量 如何遍历记忆？: 内存共享 生活化模型，合租房子： 我家的客厅就是你家的客厅。。。注意：内存共享，没有使用内核空间 共享内存的缺点： 我家的客厅就是你家的客厅，那还有安全可言嘛 ----> 官方：没有同步控制：1、访问出现紊乱 2、信息安全没有保障 注：由图知道，进程地址空间，全部地址----------》 只是映射到 物理内存 ​ 所以，从本质物理上看，共享内存，就是共享的物理内存（地址空间相同） 管道 生活化模型，管道走线： 一边人塞进去，另一边人拉出来 管道，利用文件作为中间介质（利用了内核空间） TODO, 注意：管道的方向是一定的？单向的 缺点： 1、两次复制 A ---》 管道 ----》 B （模型: 一推一拉） 2、管道会阻塞（管道有多大） 消息队列 消息队列（存在于内核中）-------》 也是利用内核空间内存 消息的发送方和接受方，要约定好消息体的类型（和大小） 生活化模型，快递模型： 快递公司， 内核中的消息队列：负责接收、存储、发送快递包裹（消息）。 快递包裹，消息：有一个唯一的标识号（消息类型），发件人（发送方）将包裹交给快递员（消息队列），然后快递员将包裹存储到快递公司的仓库（消息队列缓冲区）中。 自然： 收件人（接收方）需要从快递公司的仓库中取出包裹，只能取走属于自己的包裹： 根据唯一标识取（实际上就是发取双方的协议） 如果没有属于自己的包裹，收件人需要等待，直到快递员把包裹送到仓库中。 socket 这个图和 管道 很相似 -------》 感觉没啥区别？ 与管道区别: 方向性不同：Socket通信是双向的，而管道通信是单向的。 应用范围不同：Socket通信可以在不同的机器之间（网络）进行通信，而管道通信只能在同一个机器上的进程之间进行通信。 传输方式不同：Socket通信是面向连接的，而管道通信是面向数据流的。 缺点： 两次copy 信号量 为啥安卓要重新做一个Binder呢（对比）？ 进程通信对比 2、或者说， 共享内存和 Socket的一个 中间态：取Socket的copy + 共享内存的内存映射 补充： 后面几种（除了共享内存），都有一个特点： 必须通过内核空间 4.1.2. Parcel + Parcelable 模型：图 TODO 目的在于： 拆解成基本类型，通过内核（IoCtrl） 本质：Parcel + Parcelable 。与类没有任何关系， 已经拆解成基本类型了 ​ 可以打包的数据，自然：Parcelable(Intent、Bundle) + 基础数据类型 + list + map + Binder（TODO: 如何做的？？？） 推论：Parcel作用就是拆解 类----> 基本数据类型序列 应用场景：跨进程传输，打包解包必须（必须int传输） 4.2. 0层流程-----一次Binder通信 IPC.eddx 分层设计思想：类比于 五层TPC/IP协议体系，见 http://gityuan.com/2016/09/04/binder-start-service/ 好处： 从功能实现角度看，层与层具有独立性, 例如应用层可以使用传输层提供的功能而无需知晓其实现原理; 设计灵活, 层与层之间都定义好接口, 即便层内方法发生变化,只有接口不变, 对这个系统便毫无影响; 结构的解耦合, 让每一层可以用更适合的技术方案, 更合适的语言; 从维护角度看，方便维护, 可分层调试和定位问题; 4.3. 0层结构-----Binder架构（存在三个ipc） 参考： https://www.cnblogs.com/yocapl/p/12422617.html 逻辑化简： 1、上图中步骤1、2、3是虚线的，并不是直接调用。系统调用Binder驱动完成的 2、上图存在三个进程：client进程、server进程、Service Manager进程 ---> 任意两个之间的交互都是通过Binder？ 3、从应用角度：应用层只需要实现client 和 server； 4、对于应用层来说，看到的 就是 client调用 server 5、背后的架构：C/S架构 6、从实现机制上看，有点儿类似linux共享内存 7、从数据拷贝次数来看，Binder只需要进行一次内存拷贝，而管道、消息队列、Socket都需要两次。共享内存不需要拷贝，Binder的性能仅次于共享内存。---> 为什么不用共享内存？共享内存需要处理并发同 基于0层的生活化模型： 床柜挪房间模型： 两个房间：两个进程。进程内存隔离 两个房间之间有个客厅： 内核，通往客厅的门只能通过小的基本类型数据 拆床说明书（即组装床说明书）Parcelable、同样拆柜子说明书：Bed implements Parcelable --------> 这个其实不是AIDL。不得不：两边有一模一样的 拆哪个东西的约定：AIDL协议--------> 即int code表征执行哪个方法。。。不得不：两边有一模一样的AIDL 目标：床柜挪房间 ---------- 》 不得不： 1、这边房间需要拆床 ，拆完的 基本部件才能通过门，到另一个房间 2、到另一个房间后，怎么知道这次拆的是床的 ------》AIDL协议 4.4. 功能实现之管理结构(后面拆除掉) 0层结构图中的： 一般C/S架构必然有 管理者，server用来注册；client端用来查询 所以，ServiceManager 一句话本质： 维护了 binder名-------Binder列表： 比如 “Activity” ----- AMS的Binder AMS的Binder 何时注册到 ServiceManager呢？见《系统启动流程》中的publishBinderService流程 Q： ServiceManager本身底层也是 Binder, 他怎注册呢？ A: 自然，必然是固定的，不注册。 ServiceManager对应的handle为0，取到对应binder TODO: 如果是APP开发者自己定义的Service，binderService时，走的是AMS，没有注册到ServiceManager嘛？ 注意：后面看流程，先把管理serviceManager给去除了 4.4.1. 管理模型，类似于其他C/S架构 再比如：DNS 服务器，也是维护了 域名----IP的列表 4.5. 功能实现之核心结构 Binder的物理本质 : 一个词总结： 共享内存 一句话总结： Binder 是在 共享内存的基础上， 以性能（增加copy）为代价，换取了 安全性 注意：1、上图是在 共享内存 图的基础演化而来。差别在于： ​ （1）内存映射 的双方不同： 共享内存是两个APP进程 ；Binder是 内核进程 与 server端 ​ （2）mmap()功能的物理实现 即 图中1和2 数据流： client 发送数据 ----> kernel ( kernel 内核空间地址，映射到了物理内存，则server能感受到) 从数据的流转来看（数据结构的变化）, Binder的本质： 经过内核，不得不： 1、传输的数据，不得不拆解成int、string等基本类型（TODO: 经过内核时，是不是更基本？） -----> 所以，parcel拆解，是不得不的 2、AIDL协议也是不得不的，AIDL要做两件事情：（1）保证 触发与接收函数一致，通过code（2）保证拆合，原则一致，有同一套说明书 （Parcelable保证的！！！！！不是AIDL） AIDL从模型的角度的本质：即上面保证（协议） 官方描述： mmap() 是操作系统中一种内存映射的方法。 内存映射就是将用户空间的一块内存区域映射到内核空间。映射关系建立后，用户对这块内存区域的修改可以直接反应到内核空间；反之内核空间对这段区域的修改也能直接反应到用户空间。 基于上图，一句话： 整个Binder机制，唯一核心的就是映射1（ kernel内存地址 和 物理内存 的映射）创建 -------> 在server端 ， Binder的创建流程中，见下 4.6. Binder的创建 目标：整个Binder机制唯一核心------- 映射的创建 4.6.1. Binder是什么 不同角度： 机制: Binder是一种进程间通信机制; ----> 这个角度来看： Binder 是 安卓的 神经系统 从功能看：Binder就是一种服务（虽然可能不是service，比如主线程的Binder）。所以，天生的，Service，底层必然是Binder 应用层: Binder是一个能发起通信Java类; ---> 对外的接口 Framework/Native: Binder Client、 Server、 Service Manager和Binder驱动程序, 形成一套C/S的通 信架构 驱动: Binder是一个虚拟物理设备驱动; ----> 真正实现功能的地方 物理角度：Binder的本质 见上 --------> 记忆锚点： 应用层来看、Framework/Native、驱动、物理角度 4.6.2. Binder驱动的创建时机 进程创建的时候，一般就创建了。比如： 问题1：为啥要在APP创建时，要第一时间初始化Binder驱动呢？ A: 因为创建APP进程之后，会将自己的Binder给到AMS来管理（后续，AMS让APP创建Activity） -----> 见APP启动流程 ​ 自然，在这之前，要创建Binder 问题2：zygote进程有自己的 binder嘛？ video7 A：没有。 linux角度：因为主要功能是生孩子（fork）。linux不允许fork的有多线程，会产生死锁 ----> 规则 代码角度：TODO 4.6.3. Binder的注册时机 （1）0号引用 ServiceManager 的Binder不需要注册 （2）对于一个普通的APP定义的service，何时注册到 ServiceManager 的？ 4.7. AIDL aidl 目的： 就是 对外接口 Proxy和stub，自动生成。不用APP开发者自己写 为啥不能纳入framework呢？没办法，因为AIDL里面的具体接口函数，不清楚 所以，AIDL是封装 ​ AIDL也是没能纳入framework层的妥协，利用编译抽取公共功能--------》 TODO: 背后的背后： 收集这个技巧！！ 核心的核心就是 Ibinder如何传递的 注意： 两个 APP源代码，必须有相同的 .aidl文件 文件 推论：虽然Server端有Proxy，但是没有用到 TODO: AIDL编译也可以生成native的proxy和stub？？？？？？ 从APP开发者来看： AIDL是接口 -----> 自然，server和client都要（复制一份一模一样的 或者 编译共用一个） AIDL的本质，一句话： ​ 1、从代码角度：对proxy和stub进行封装 ------> 通过编译.aidl文件，自动生成 proxy 和 stub文件 ​ 2、从模型角度： 见上 4.8. 分析一次Binder调用(核心) 前提条件： 默认 client 已经持有 server端的 binder了（物理上持有的是啥？）通过 manger 4.8.1. client--->BinderProxy--->binder驱动 即0层架构图的 以 APP 获取AMS服务为例子，即ServiceManager.getService方法 ： 前提，已经持有ServiceManager对应的Binder了 角色： client ---- APP BinderProxy ---- ServiceManagerProxy jni BpBinder Binder驱动 ------- 即 ServiceManager对应的0号 Binder 4.8.2. binder驱动--->BinderProxy--->server 以ServiceManager.addService为例子： 4.9. binderService流程 注：如上所说，Binder本质就是体现一个服务 (但不一定都是Service) 原图： 化简： 1、2、5、6删除。Client 通过 AMS 、Server也通过AMS，自然 ，先必须找ServiceManager 触发点： MainActivity.bindService(intent, mServiceConnection, Context.BIND_AUTO_CREATE); // 唯一核心代码 唯一一行核心代码： AMS把 Service的Binder给到 Client端： onServiceConnected() 之前流程。调用栈： 也是上图的一句话总结 总结： 上图总共 8次跨进程 通信！！！！ 繁琐的展开流程如下： 1）Activity作为Client发起bindService，最终会调度到AMS 去执行bindService。在这个过程中，Client要去调用 AMS的代码，所以此时就会涉及到跨进程调度，基于第三章的Binder通信模型我们不难知道，Client会先和 ServiceManager通信，从ServiceManager中拿到AMS的IBinder。 2）Activity拿到AMS的IBinder后，跨进程执行AMS的BindService函数； 3）由于AMS管理所有的应用进程，因此AMS中持有了应用进程的Binder，所以此时AMS可以发起第4步也就是跨进 程调度scheduleBindService(); 4)Server端会在收到AMS的bindService的请求后，会将自己的IBinder发送给client，但是Server必须通过AMS才能 将Binder对象传过去，所以此时需要跨进程从ServiceManager中去拿到AMS的binder； 5）Server端通过AMS的binder直接调用AMS的代码publishService(),将service的Binder发送给AMS； 6）经过层层调用，最终AMS讲Server端的binder通过回调connect函数传递给了Client端的Activity； 以上就是bindService的全流程，这个流程主要的目的是将Server端的Binder对象发送给Client端。从此以后，Client 端就可以通过Server端的binder与Server端像调用自己的代码一样完成跨进程通信了 4.10. Binder的 同步调用 / 异步调用 结论：默认都是同步调用 ​ 即 A 应用调 B应用，等待B应用的返回结果 同步调用，图： 关注点：（1）client 休眠（ 在等待结果时）； （2）Server端 是在binder线程上 （非主线程） 为什么默认都是同步？同步为何是自然的？ 1、同步是自然的 2、很多情况，Client调Server是需要 获取结果（reply）的： 比如BOOK中例子，获取Server端的getBookList() ​ 从模型角度： 要等待结果，必须休眠 ​ 从代码角度： // Client 端 public java.util.List getBookList() { android.os.Parcel _data = android.os.Parcel.obtain(); android.os.Parcel _reply = android.os.Parcel.obtain(); java.util.List _result; try { _data.writeInterfaceToken(DESCRIPTOR); boolean _status = mRemote.transact(Stub.TRANSACTION_getBookList, _data, _reply, 0); //【1】 ............ _result = _reply.createTypedArrayList(com.example.aidl.Book.CREATOR); //【2】 } ............ return _result; } 必须等【1】执行完，_reply才有数据，【2】才能用_reply 4.10.1. 异步 异步调用，图： 对比同步，异步注意点： client不会休眠（自然也不会等待结果） 代码层面的区分点： //Proxy中： mRemoteBinder.transact(REQUEST_CODE, _data, _reply, 0);// flag = 0 // flag = 0 表示同步调用（默认），1 表示表示异步调用（自然， 异步调用_reply必须为null） 补充：1即 IBinder.FLAG_ONEWAY 从aidl的接口定义角度： 自然，oneway的aidl的接口定义是不能有返回值的 （返回值都是由_reply承载的） ​ 比如： oneway interface IApplicationThread{..........} 使用方法： oneway关键字，决定了 代码中 flag = 1 IPCThreadState角度： TODO: https://www.jianshu.com/p/db2df0a4e037 线程角度： TODO 对于ONEWAY接口，所有调用在server端都被串行化(尽管不同应用发起请求是并行的) 例子： onesay主要用于系统服务向应用端发起binder调用： scheduleLaunchingActivity: 系统服务向应用端发起oneway binder调用，让应用端启动acitvitiy IWindow：WMS向应用端发起oneway binder调用 IServiceConnection: 应用端bindService完成时，AMS向应用端发起的oneway binder调用 IIntentReceiver：AMS发起oneway binder调用 分发广播 具体例子： // IApplicationThread.aidl oneway interface IApplicationThread{ void scheduleTransaction(........); // 同步生命周期的。即启动应用侧 acitvitiy // 所有方法，不能有返回值 } 结论： 系统侧----> APP侧，必须是 oneway 的aidl ​ TODO: APP侧绝不能阻塞系统侧 APP侧 ----> 系统侧，一般可以是 同步aidl： 自然，APP里AIDL一般不加oneway 4.11. 优缺点： oneway binder 优点： 1，异步：应用端处理这些oneway binder调用，如果很耗时，也不会阻塞系统服务 2，串行化，系统会逐个分发binder 调用 4.12. 实现机制 TODO: 4.13. 参考： https://www.jianshu.com/p/db2df0a4e037 Android Framework学习之Binder的oneway机制 https://blog.csdn.net/yu8fei/article/details/109389362?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109389362-blog-123662130.235%5Ev32%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-109389362-blog-123662130.235%5Ev32%5Epc_relevant_default_base3&utm_relevant_index=2 Binder的同步与异步 4.14. 其他细节 4.14.1. binder安全机制 上面说binder比其他IPC机制更加安全，体现在内核 对 UID/PID进行有效性检测。 TODO: 具体如何校验的？ 4.14.2. 一些函数 Binder.getCallingPid(); //获取 调用binder的进程pid（自然是在 在服务端 ） 4.15. 参考 http://gityuan.com/2016/09/04/binder-start-service/ http://gityuan.com/2015/10/31/binder-prepare/ https://blog.csdn.net/carson_ho/article/details/73560642 https://developpaper.com/principle-and-use-of-android-binder/ https://blog.csdn.net/carson_ho/article/details/73560642 -->Binder优质文章 一些结论： 一个Binder就是一个线程。比如： AMS实现了Ibinder接口，是一个Binder, 所以也是一个binder线程 Binder机制：https://blog.csdn.net/carson_ho/article/details/73560642 这3大过程每一次都是一个完整的BinderIPC过程 http://gityuan.com/2016/09/04/binder-start-service/ 《Binder预习资料.pdf》 4.16. 面试题 https://blog.csdn.net/xuyin1204/article/details/118546330?ops_request_misc=%257B%2522request%255Fid%2522%253A%2522162599351116780274143599%2522%252C%2522scm%2522%253A%252220140713.130102334.pc%255Fblog.%2522%257D&request_id=162599351116780274143599&biz_id=0&utm_medium=distribute.pc_search_result.none-task-blog-2~blog~first_rank_v2~rank_v29-2-118546330.pc_v2_rank_blog_default&utm_term=binder&spm=1018.2226.3001.4450 Binder相关面试题目 5. 线程间通信-----Handler 5.1. 前言---从应用角度 5.1.1. 使用目的： Handler的存在就是为了解决在子线程中无法访问UI的问题（自然，进程间不可以），多用于切换主线程 从线程模型的角度（抛开安卓、UI）来看，Handler本质就是线程 所以，Handler本质与主线程 没关系、与UI没关系 常见的使用场景： 非子线程想要界面操作，比如： 网络交互后切换到主线程进行UI更新 Binder通信后，Binder线程切换到主线程进行UI更新 由此引发的问题： 1、如何使用？ 2、如何完成切换线程的呢？机制 3、 5.1.2. 其他 线程通信的方式 5.1.3. Handler场景例子详解 EX 1: 比如： Toast服务给Toast回调，为什么要用message？为什么不直接回调呢？ Binder线程，切换到main线程去真正show《------因为界面变化必须在主线程 EX 2： TODO: 输入法的六个桥梁之间，有哪些是用了Handler 转Binder线程 为主线程的？why？ EX 3： 在子线程里发送： 主线程里接收： 如果要msg携带多个参数呢？ 一些细节： Message msg = Message.obtain(); 与 new Message() 5.1.4. 使用逻辑： 一句话描述：子线程用了主线程的Handler发消息（补充，含有looper的线程都可以） 例子： public class MainActivity extends AppCompatActivity { TextView mTxtShowTest; Button mBtn1, mBtn2, mBtn3; //2、在主线程里new Handler.------->为什么这样??? private MyHandler myHandler = new MyHandler(); @Override protected void onCreate(Bundle savedInstanceState) { super.onCreate(savedInstanceState); setContentView(R.layout.activity_main); mTxtShowTest = (TextView) findViewById(R.id.mTxtShowTest); mBtn1 = (Button) findViewById(R.id.mBtn1); mBtn1.setOnClickListener(new View.OnClickListener() { @Override public void onClick(View v) { new Thread(new Runnable() { //3、在子线程里发消息 @Override public void run() { Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); } }).start(); } }); } class MyHandler extends Handler {//1、通过继承拿到Message（含数据） @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: mTxtShowTest.setText(\"新建Handler子类方法\"); default: //nothing } } } } 5.2. 0层模型----锚点 切换线程，不得不的模型： 注意忽略掉类名，与代码无关 见 handler.eddx 生活化的模型： 磨玉米模型 人物： 人（调用线程）：人，可以有多个人 ----》 一般来说是 非主线程 驴（Looper线程）：干活线程(有些活，必须这个线程干，就像磨一般都是驴来拉) 旋转杆：Looper，负责旋转整个线程 ----> Looper的旋转，才导致玉米msg不断被取出next()，是永恒的动力 绑绳： ThreadLocal---------绑绳，是线程相关量，让Looper与对应线程绑定 装玉米的磨：msgQueue(自然,一个线程一个) 磨洞：取玉米，一个一个取的 一个个排队的玉米： msg，注意：玉米之间是线性的，一个一个网磨的洞里漏 ​ 玉米的排队顺序：是人指定的， 按照玉米的 着急程度排序 （质量高的 玉米， 人给 赋了值when，安排靠前 加工） Handler：是添加玉米/取玉米的瓢(添加msg的工具/处理msg的工具), 有多个, 绑在磨上(自然,1、一个线程可以多个2、自然,在Looper 线程里生成,与Looper绑定3、自然各个调用线程都能用) 自然的结论： 1、 一个线程可以有多个Handler(瓢),只有一个Looper(驴子),只有一个MessageQueue(磨) 2、Handler(瓢)的生成，必须在Looper线程下--------驴子的瓢，给人用 3、所有的一切都是主线程的（Looper线程），是一个输入系统。调用线程没有任何东西。 纵向流程： 1、正常情况下，驴子看自己的磨里（Looper线程的queue）没有玉米（msg），不需要磨，驴子就睡地上了（Looper线程阻塞，挂起？） ​ 人也在干自己的事情（调用线程做自己的事情） 2、人通知驴去干活，两件事情： （1）人用瓢 往磨里 填加 玉米： 调用线程 通过Handler 往 Looper线程的queue里加 msg ----> 这一步是简单的，因为人和驴的磨之间，没有墙（共进程），可以直接加（共内存） （2） 人把驴弄醒wake 由此可见，最核心的是（2），如何弄醒驴子 xaingxue的模型： 5.3. 1层架构图： 见 handler.eddx 对外接口： 最终都归结为：Handler. enqueueMessage Queue. enqueueMessage 即消息入队列 5.4. 串线之驴子：Looper.loop()--基于0层模型图 基于0层模型图中，最核心的就是 死循环 // Looper.java public static void loop() { final Looper me = myLooper(); final MessageQueue queue = me.mQueue; for (;;) { // 死循环：for内部没有return或break ........... Message msg = queue.next(); // might block 【1】获取下一个msg block线程的地方，见下 try { msg.target.dispatchMessage(msg); // 【2】分发msg 给target处理，见下 } ........... msg.recycleUnchecked(); // 用完的msg回收消息池 TODO } } 时机：由 0层模型图，自然：Looper.loop() 自然是被 Looper线程调起来的----> 对于主线程，是ActivityTread的main里Looper.loop() 作用：做了两件事情，同 0层模型图一致： 【1】获取下一个msg ( block线程的地方，见下) 【2】分发msg 给target处理 自然 补充【1】 queue.next()获取下一个msg block线程的地方 链接: 基于0层模型图，为什么一定要有 Looper线程的block? A: 不得不： 1、如果没有block，那么主线程一直在Loop里循环跑，根本不会有其他代码会被执行。驴子在空跑 2、主线程还需要处理其他很多事情，比如Input、view等等 ------> 似乎不是理由？ // MessageQueue.java Message next() { for (;;) { // 遍历queue，获取下一个msg，不是死循环 //【1】阻塞操作，当等待nextPollTimeoutMillis时长，或者消息队列被唤醒，都会返回。见下 nativePollOnce(ptr, nextPollTimeoutMillis); synchronized (this) { // Try to retrieve the next message. Return if found. Message prevMsg = null; Message msg = mMessages; if (msg != null && msg.target == null) { //cg: 【消息屏障】 syncBarrier // Stalled by a barrier. Find the next asynchronous message in the queue. do { prevMsg = msg; msg = msg.next; } while (msg != null && !msg.isAsynchronous()); //cg: get asynchronous msg，找到异步消息 } ........... // Got a message. mBlocked = false; if (prevMsg != null) { prevMsg.next = msg.next; } else { mMessages = msg.next; } msg.next = null; msg.markInUse(); return msg; // 【2】获取头节点 } 【1】阻塞block操作 nativePollOnce()： 其中参数 nextPollTimeoutMillis 代表下一个消息到来前，还需要等待的时长（-1一直等） （1）作用 nativePollOnce()阻塞Looper线程。 自然：只有当nativePollOnce()返回后，next()从mMessages中提取一个消息 （2）具体做了啥？ 见 技术点pollOnce与wake （3）何时nativePollOnce()会有返回？ 5.5. 不得不之 Looper线程唤醒（核心） pollOnce与wake~----最核心代码，线程间通信 这里就是Android系统的Handler消息机制的消息循环的核心实现，使用了Linux的epoll事件处理机制。当消息队列为空时，常规的循环实现是调用sleep/usleep释放cpu，当时间到了之后，会获得CPU资源进行一次消息检查；Handler的消息循环采用Linux kernel的epoll机制，当消息队列为空时，会挂起释放CPU资源，只有当消息队列有新消息到来时，才会重新获得CPU资源，进行消息处理。 相比常规实现，Android系统的Handler消息机制更加节省系统资源(CPU资源)。 相比常规实现，Android系统的Handler消息机制的生产者，把消息放入消息队列的同时，可以通知(唤醒)消息处理者。 链接：https://juejin.cn/post/6856366890936827911 最核心：epoll机制：epoll导致睡眠 ​ 往文件里写字符，唤醒epoll流程继续注意 wake() 绝对不够本质！！！！！！ 5.6. 串线之人：Handler.sendMessage流程---为死循环提供玉米（数据）+唤醒（驴子）： 链接：基于0层模型图，存在的理由（不得不）： 1、死循环需要被提供数据 2、死循环需要被唤醒 //发消息在子线程 sendMessage:611, Handler (android.os)// 对外API sendMessageDelayed:673, Handler (android.os) sendMessageAtTime:703, Handler (android.os) enqueueMessage:754, Handler (android.os) enqueueMessage:556, MessageQueue (android.os)// 队列 ------------------native--------------------- NativeMessageQueue::wake() Looper::wake() // 【1】最终真正唤醒的地方 流程，子线程中： Handler.sendMessage(msg) (msg通过obtain获得，见补充msg) 最终是调了链表MessageQueue.enqueueMessage方法(自然，不得不)，将msg加入链表 （新消息入队规则：见次要补充1：新消息入队规则） 一句话总结：发送消息，实际上就是消息入队（链表） 5.6.1. 问题：何时切的主线程呢？？？ 答：looper.loop()在主线程一直循环（for循环）, 感受到了链表里有新的msg 0层图 结构：looper也持有MessageQueue // Looper.java public static void loop() { //#4 loop()是在主线程main方法里被调起来的！！！！！！ final Looper me = myLooper(); final MessageQueue queue = me.mQueue; boolean slowDeliveryDetected = false; for (;;) { //这里就是一直说的looper循环！！！！！ Message msg = queue.next(); // might block //#3 if (msg null) { // No message indicates that the message queue is quitting. return; } 问题：关于for循环： (1) for 循环确定一直在循环嘛，即使queue没有东西？？？ 跳转A （3）对于#4，如果for是一直循环，那么 main函数之后的流程理应走不到！！！！！！----》确实是，Looper.loop()是最后一行代码 （4）App如何退出呢？ 5.6.2. for 确定一直在循环嘛 ----》即使queue没有东西？？？ A: 总结： list为空，是block状态------》#1、线程如何block？？？？ list不为0 ，被唤醒，读取-------》#2、如何被第二个线程唤醒？？？？ TODO： Looper的wake机制升级 https://cloud.tencent.com/developer/article/1639805 6. 1 、线程如何block？？？？ epoll 6.1.1. 次要补充： msg获取 obtainMessage 6.1.2. 次要补充： 新消息入队规则： https://blog.csdn.net/u013008419/article/details/80001310 注意：与普通链表不同，不是添加在最后 ，而是 按照玉米的 着急程度排序 （质量高的 玉米， 人给 赋了值when，安排靠前 加工） 自然：原始的消息队列顺序是按照消息执行时间when排序的。新msg也是按照when大小插入：when小，插前面 6.2. 机制 --> 如何完成线程切换的： https://blog.csdn.net/wsq_tomato/article/details/80301851 6.3. 补充1：准备消息循环looper 因为handler里有Looper 问题： 1、循环Looper是啥？ 2、Looper的主线程无限循环，为什么没有造成ANR呢？ 循环Looper是啥？： 1、消息处理机制中，消息都是存放在一个消息队列中去，而应用程序的主线程就是围绕这个消息队列进入一个无限循环的，直到应用程序退出。 2、如果队列中有消息，应用程序的主线程就会把它取出来，并分发给相应的Handler进行处理；如果队列中没有消息，应用程序的主线程就会进入空闲等待状态，等待下一个消息的到来。 Looper初始化流程： //ActivityThread.java public static void main(String[] args) { ........ Looper.prepareMainLooper(); //#1 ........ ActivityThread thread = new ActivityThread();// (1) thread.attach(false, startSeq); if (sMainThreadHandler null) { sMainThreadHandler = thread.getHandler(); } ........ Looper.loop();// (2) throw new RuntimeException(\"Main thread loop unexpectedly exited\"); } 这个函数做了两件事情， (1)一是在主线程中创建了一个ActivityThread实例， (2)二是通过Looper类使=主线程进入消息循环中，这里我们只关注后者。 什么叫使主线程进入消息循环里？ ----> Looper.prepareMainLooper(); //#1流程 静态函数 TODO： ThreadLocal，表示这是一个线程局部变量------》如何做到的???? 注意：变量、类是没有线程概念的！！！！----》本质是内存，内存是进程级的！！！！ 6.4. 从架构师 角度看Handler 从设计模式角度： 属于生产者、消费者模式。见: 《设计模式》 从系统角度看：有进无出。1、所有的一切都是主线程的。 2、调用线程，只是用Handler做了调用，即输入 从功能角度： 发号命令的人（之后不用管事了），与干活的驴。 从本质角度：内存共享原理 ----> 共享的是哪一块内存？ msgQueue（人可以往这里添加玉米，驴子可以从这里拿玉米） ThreadLocal原理 6.5. 关于 MessageQueue 持有mMessages, mMessages 有 next属性指向下一个msg -----》 msg本身就是链表了 所以, MessageQueue只是对链表的封装, 提供一个管理功能 add, remove操作 6.6. Handler容易导致的内存泄漏 参考： https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650238704&idx=1&sn=ad334840afdc2d9bdb8215e9f942e54e&chksm=88639f9fbf1416898edfc3615a7ea25f6798e3bb6f3089ca720e18b92ce67328c623561cf35e&scene=27 好文 内存泄漏全解析 郭霖;) 2017-02-28 08:00 视频： 19. Handler内存泄漏的GCRoot到底是谁-fS.vep 例子1： // MainActivity.java Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); class MyHandler extends Handler { @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: //mTxtShowTest.setText(\"新建Handler子类方法\");// 【表达1】 MainActivity.this.mTxtShowTest.setText(\"新建Handler子类方法\"); // 【表达2】MainActivity.this 代表外部类的实例 break; default: //nothing break; } } } // 持有关系 static sThreadLocal -> Looper-> MessageQueue -> Message -> handler -> MainActivity.this外部类的当前实例 因为sThreadLocal是静态的，与APP同生命周期。所以是GcRoot (1) 这里 handler -> Main2Activity.this 原因：内部类（非静态）持有外部类引用 , 见【表达2】 -----》 自然的，如果没有外部，怎么找到内部类？ TODO: 根本原因，要到JVM里找 (2) Message -> handler: 每个Message 有处理对象 handler (2~) 记忆：持有链： 瓢handler 《----玉米Message 《----磨MessageQueue 《-----旋转杆Looper 《 ------绑绳： ThreadLocal -------------》 最终结果，造成 MainActivity.this 与APP同周期？错误！！！！ A: 玉米Message 《----磨MessageQueue 这一环链接时间最短，决定了 内存泄漏时间。 例子1是造成的内存泄漏时间可能很短。 所以，需要一个前提： Message 尚未被处理，长时间在MessageQueue ，比如，延迟5分钟 执行的消息 Message 即：例子2： myHandler.postDelayed(new Runnable() { // 延迟执行 @Override public void run() { Message msg = Message.obtain(); msg.what = 1;//要传递的数据 myHandler.sendMessage(msg); } }, 50000); // 设定指定的时间time,此处为20000毫秒 解决办法： Handler 声明为静态内部类 -----》 自然，static的 与外部类没有关系了，不会再持有外部类。同时，【表达2】MainActivity.this 编译也报错，引不到外部类了 改动导致的不得不：静态内部类要使用 外部类，只能 弱引用了。。。其实自然的，因为此时内部类是静态的，外部类不一定实例化了，所以编译上一定过不去 即修改为： private static class MyHandler extends Handler { private WeakReference mReference; public MyHandler(MainActivity mainActivity) { this.mReference = new WeakReference<>(mainActivity); //【表达3】只能通过弱引用，来引用外部类，肯定无法直接 } @Override public void handleMessage(Message msg) { int what = msg.what; switch (what) { case 1: // mTxtShowTest.setText(\"新建Handler子类方法\"); // MainActivity.this.mTxtShowTest.setText(\"新建Handler子类方法\"); this.mReference.get().mTxtShowTest.setText(\"新建Handler子类方法\"); break; default: //nothing break; } } } 工具： Android内存泄漏的检测工具——LeakCanary。 TODO: 原理： https://blog.csdn.net/a820703048/article/details/112849983 应用举例：https://blog.csdn.net/weixin_35924765/article/details/117505874 实操： TODO 一句话总结： 普通内部类 + 延迟 执行的消息 Message，容易造成内存泄漏 6.7. ThreadLocal机制 要是我来设计，我肯定这样设计：一个进程级别Map，以ThreadId为key -----》问题在哪里呢？ 1、进程级别Map 做不到 只对一个线程开放，对其他线程封闭 2、用是可以用的------> 多线程同时操作 Map, 存在并发问题，需要枷锁 官方设计： 本质：1、 map线程级， 2、Map本身是Thread的私有属性 3、key是 ThreadLocal, value是存储值 从物理内存角度来看：map对象肯定是在堆里（进程都可以访问），但是因为是线程 私有 属性 ----》 达到对其他线程的封闭 ​ 即一句话：物理上，可以访问，但是没有索引 化简： 从本质上，可以看出，只需要Thread的Map就行了，真正干活的。那为啥还要Treadlocal呢？ 见下： 从功能角度： 1、存储（ 线程级） 是在线程里Thread ，真正干活的 自然，区分线程也是这里区分的 2、Treadlocal存在的必要性： ​ （1）不得不1：封装map，对外提供功能。因为map是私有的，不能直接对外 ----> 工具类的作用 ​ 推论：自然，是静态的，进程级别 static final ThreadLocal sThreadLocal = new ThreadLocal(); ​ （2）不得不2：~map里面存了很多数据，如何快速找到，需要一个key来标志数据类型，自然 ----> key的标志作用，指定要存啥类型 ​ （3）优秀的点： 封装了Map，自然不用传参key。----> 从而，安全性，其他线程不能访问 使用： 1、存放Looper，使用new ThreadLocal() ​ 存放Intent，使用 new ThreadLocal() 使用场景： 并发问题中， 同时使用的共享资源，可以被拆解成一个个独立的 线程级变量 补充： 任何用 ThreadLocal保存的变量，都是线程单例。比如 可以说 Looper 是线程单例 ----》 自然的，新的说法而已 6.7.1. 相关问题 弱引用？ 6.8. 消息屏障 生活化模型，基于封路模型： 马路上一个个 汽车（msg ），一个个排队 走。这个时候，xin 的车(异步msg ) 要来了， 屏障msg是 警察。警察插入队伍中某个位置（when），封住后面所有的车 。 基于封路模型：一些自然的不得不： 1、警察是不动的（屏障msg是不被执行的，因为处理的Target = null） 2、警察封住后面所有的车，对前面的车不封。即：前面的msg可以正常运行 3、之前 人将玉米加入 磨里，会唤醒驴子（子线程发送msg，唤醒主线程）。。。。。但是 屏障消息不会 唤醒主线程，因为本身就不需要执行 ，自然 ​ 代码证明：没有nativeWake() 本质：屏障消息就是为了确保异步消息的优先级，即：设置了屏障后，只能处理其后的异步消息，同步消息会被挡住 三种消息： 同步消息 异步消息 屏障消息 机制要解决的业务问题（背景）： 为 xin的车（VSync消息？？？）开路： VSync 16ms一次，如果用户同步消息（多个，很可能）没有执行完成，无法执行VSync消息，无法画用户界面。在用户角度，出现了掉帧或卡顿的情况。 同步屏障（自然和异步消息一起） 使用场景，很少： ViewRootImpl接收屏幕垂直同步信息事件用于驱动UI测绘 ActivityThread接收AMS的事件驱动生命周期 InputMethodManager分发软键盘输入事件 PhoneWindowManager分发电话页面各种事件 基于模型，代码： class MessageQueue{ public int postSycnBarrier() { return postSyncBarrier(SystemClock.uptimeMillis()); //currentTimeMills()系统当前时间，即日期时间，可以被系统设置修改,时间值会发生跳变 //uptimeMills() 自开机后，经过的时间，不包括深度休眠的时间 //sendMessageDelay，postDelay也都使用了这个时间戳 //意思是指，发送了这条消息，在这期间如果设备进入休眠状态(如息屏后长时间不操作手机)那么消息是不会被执行的， //设备唤醒后到了时间才会执行 } private int postSyncBarrier(long when) { synchronized (this) { final int token = mNextBarrierToken++; //屏障消息和普通消息的区别是屏障消息没有tartget //也就不会被分发处理(执行) //可以理解为是一个标志位flag final Message msg = Message.obtain(); msg.markInUse(); msg.when = when; msg.arg1 = token; Message prev = null; Message p = mMessages; //【】根据时间顺序将屏障插入到消息链表中适当的位置 if (when != 0) { while (p != null && p.when 异步消息：msg.setAsynchronous(true); 即 FLAG_ASYNCHRONOUS标致 屏障如何工作的？见 取函数next() 中 【消息屏障】 6.8.1. 从设计角度，看 消息屏障 因为msg是个队列，所以，设计者想要 调节一下 msg执行顺序 小调节：when 大调节：消息屏障 6.9. 使用注意事项 1、Handler使用前，一定要在looper线程先执行 Looper.prepare() //----> 为线程创建Looper Looper.loop() // 磨转起来 为啥主线程不要？ A：要的。主线程，在main流程中，系统侧已经做了 6.10. 疑问 6.10.1. 子线程发一个消息 （1）何时主线程处理？？？----》按道理在主线程的messgeQueue排队 （2）如果主线程在执行其他流程呢 ---》按道理要等着现在流程走完（即：一个msg引发的操作执行完） （3）一直走不完呢？ -----》在。。。。。会引发ANR？？？（TODO） （4）ANR的机制是啥？ 6.11. 相关面试题 6.11.1. 一个线程可以有几个Looper？可以有几个Handler？ 从模型角度： Looper.looper() 是驱动整个线程运行的 拉磨驴----> 自然，只有一个 ​ Handler是对外接口，send.msg和处理msg，自然，可以有多个 从代码角度：Looper.prepare()创建Looper之前，会判断当前线程的Looper是不是存在，存在会抛异常 --------> 所以：问题的深层次答案，只能从模型中得出（代码只能给出浅显的答案） 6.11.2. 线程安全问题： 6.11.3. 多对一、多对多 case1：多个子线程 使用 同一个Handler case2：多个子线程使用 多个Handler 如何保证多线程安全？ --------> case1不需要枷锁， 因为 函数栈sendMsg（包括局部变量） 是线程级别的，两个线程，有两套 -----> 一句话：函数栈的封闭性 堆（对象）是进程级别的，所有线程共用一个对不对？ 结论： （1）case1， 两个线程可以更改 Handler对象， 但是更改不了 sendMessage(msg) 里的msg -----> 虽然对象在堆里，但是引用是局部变量，另一个线程拿不到 （2）case1， 从 Handler角度来看，两个线程可以同时使用一个对象而不加锁。前提，自然：不改变他 总结，从代码的角度看： 一个线程能不能改变一个 对象，主要看 整个线程 有没有拿到这个对象的引用 ------》自然，推论：1、两个线程都持有Handler 引用，站在handler角度看，两个线程若改变handler，会有冲突 -----》 好在sendmsg没有修改handler ​ 2、整个过程两个msg是被各自 线程引用的，所以不会有线程间冲突 -----》 如果msg 被保存成 Handler 的属性，就会有冲突 结论： 多线程问题，该在代码何处枷锁呢？ --------》规定原则：1、 从代码内存改动的角度，临界区最小化原则，比如修改了mMessages TODO: 为啥mQuitting也要 锁进去？？？ 从代码 依赖角度， 最好不能依赖 属性，因为属性不可靠！！！（可能被其他线程所更改） 2、从模型角度，大致判断： 多个人同时用 一个瓢（极其副本），没有事情（只要不改造）。但是到磨时，就改了磨了，磨被改动了 -------》 技巧：死定着改动发生点！！！ 6.11.4. 取消息函数next（）为啥也加锁了？ 按道理， 存是多个线程并发，而取只是在主线程，只有一个线程，为啥还要加锁？ 因为其他线程的存 要与 主线程的取互斥。。。取只有主线程，不会自己和自己互斥 6.11.5. Todo 以什么样的模型 来思考并发编程呢？何处该加锁呢？ 1、什么样的模型 2、类要不要再复制一份 3、注意力放哪里？ base 于一个类， 索引 可能改变的属性。 想象不同线程 穿过？ 4、结论： 需要 索引的量 ：静态变量、类的属性 5、图中的属性，其实也代表一个函数（因为一定在函数内被改变） 5、this 锁、与 object锁、静态锁， 可以用一个模型来思考嘛？ 从数学上，证明，一个函数要不要加锁，以及枷锁的位置： 1、如果调用栈上游枷锁了，自然不用 2、找出多个函数（不同线程），或者一个函数（不同线程）， 找出所有 涉及修改属性 以及 依赖的属性（可变的） 按道理，这些都应该加锁 6.11.6. Handler 内存泄漏原因是什么？为什么其他的内部类没有说过有这个问题？ 3、为何主线程可以new Handler？如果想要在子线程中new Handler要做哪些准备？ 4、子线程中维护的Looper，消息队列无消息的时候的处理方案是什么?有什么用？ 5、既然可以存在多个Handler往MessageQueue中添加数据(发消息时各个Handler可能处于不同线程)，那它内部是如何确保线程安全的？ 6、我们使用Message时应该如何创建它？ 6.11.7. Looper死循环为什么不会导致应用卡死？会消耗大量资源嘛？-----Done 当然不会，反而是Looper驱动（looper用消息驱动的） 6.11.8. Handler 消息阻塞 为什么不会导致应用卡死？ 先技术语言翻译： 阻塞指的是 取一个消息，next() 函数中 sleep了-----》线程阻塞 卡死： ANR (todo： 一定是嘛) 一句话： ANR是因为处理input消息处理超时了(其中之一)。 而 线程阻塞，正是由于queue里没有消息过来，说明没有Input，自然不会ANR了 TODO做笔记： ANR 产生的四个原因 以及 主要原理 ANR实际例子： 8、Binder有什么优势？（字节跳动） 9、Binder是如何做到一次拷贝的？（腾讯） service manager进程与Binder的关系 10、MMAP的原理讲解；（腾讯） 11、为什么Intent不能传递大数据？（阿里）限制多少? Binder驱动在哪限制? 12、描述AIDL生成的Java类细节；（字节跳动） 13、四大组件底层的通信机制；（字节跳动） 为啥不用 wait/notify ？ 6.11.9. handler实现延时任务 VS Timer延时任务(计时器) 参考： https://blog.csdn.net/fenjiehuang/article/details/65937794 Timer实现： 延迟与循环 【1】 Timer myTimer = new Timer(); myTimer.schedule(new TimerTask() { // 【】schedule方法！ @Override public void run() { ........... } }, 3000, 4000); // 延时3000毫秒开始计时，每隔4000毫秒计时一次 ---》可循环 // }, 3000); // 延时3000毫秒开始 ---》不可循环 handler实现：【2】 本质：for 循环方法 //定义msg.what常量 private static final int TIMER_TASK = 101; //使用handler发送延时消息：【】sendMessageDelayed方法！ mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMER_TASK), 3000); //在handler的处理方法中处理消息任务 public boolean handleMessage(Message msg) { switch (msg.what) { case TIMER_TASK: //do something you want //mHandler.sendMessageDelayed(mHandler.obtainMessage(TIMER_TASK), 3000); 【】核心：加上是循环，不加是定时任务 break; default: break; } return true; } 1、从原理上看：schedule与sendMessageDelayed方法，计时器基准时间不一样~ 【3】和【4】 public void schedule(TimerTask task, long delay, long period) { ......... sched(task, System.currentTimeMillis()+delay, -period); //【3】基于系统时间 System.currentTimeMillis } public final boolean sendMessageDelayed(Message msg, long delayMillis) { if (delayMillis 结论：自然，当系统时间改变，肯定会影响Timer的任务的执行。而handler不受影响 2、Handler的任务周期可调整（优点） 原因：Handler使用即for循环，每次改变delay值即可 一句话总结： 计时器不同：系统时间 和 时钟时间的区别 补充: 发送消息屏障，也是用的 SystemClock 6.11.10. 总结 推荐使用handler使用定时任务 6.12. TODO: epoll与select区别 6.13. 安卓系统根本动力 安卓系统根本动力-----事件（事件驱动） 事件是玉米（是驴要干的事情），没有事件，拉磨驴looper不会去干活。整个系统是事件驱动的 7. 线程、进程（抛开安卓、抛开语言） 基于线程模型， 线程之间关系： 同步、通信、 一个线程状态： 休眠..... 7.1. 线程同步/异步（功能） 线程同步sync------协同两个线程，即sync：通过同步建立起执行顺序的关系。 比如 你先说完，我再说。。。。。。。常见场景： A线程等待B线程执行结果 线程异步-------没有等待，同时执行。就是正常情况。两个线程各自运行各自的 ---------> 区别的标准：同一时间（不是时刻），两个线程有没有做到并发 本质区别： 有没有等待结果 7.1.1. 与 互斥的区别： 同步与互斥 的 生活化模型理解 ： 临界资源：盘子 女儿等吃爸爸放置的苹果。一起完成一件事情------> 同步 妈妈和爸爸之间，竞争关系 ------> 互斥 安卓中的例子： TODO 补充： 同步调用/异步调用是调用关系上的概念。 7.1.2. 支撑 线程同步 功能的结构 1、信号量 2、锁 例子1： 对于java，用synchronized 关键字（是自动锁） synchronized 方法和 synchronized 块 public synchronized void synMethod(){ //方法体 } public Object synMethod(Object a1){ synchronized(a1){ //一次只能有一个线程进入，将其他线程锁在外面 } } 注意：不用纠结是同步锁 还是 互斥锁，认为是同一个东西。比如，java的synchronized就是 同步锁，也是互斥锁 例子2： 在C++ 11里面，通过std::mutex的加锁和解锁来保证 同步 （ 参考 https://baike.baidu.com/item/%E7%BA%BF%E7%A8%8B%E5%90%8C%E6%AD%A5/4855164） #include #include usingnamespace std; mutexm; void threadFunc(int i) { m.lock(); //在这里写上你需要的代码 m.unlock(); } int main() { threadt1(threadFunc,1); threadt2(threadFunc,2); t1.join(); t2.join(); return0; } 例子3： c语言中， 关于锁的深入 参考：https://blog.csdn.net/liuwg1226/article/details/119900991 从第一性原理理解锁： 锁的实现要处理的大概就只有以下4类问题： “谁拿到了锁“，这个信息存哪里（可以是当前 class，当前 instance 的 markword，也可以是某个具体的 Lock 的实例） 谁能抢到锁的规则（只能一个人抢到 - Mutex；能抢有限多个数量 - Semaphore；自己可以反复抢 - 重入锁；读可以反复抢到但是写独占 - 读写锁……） 抢不到时怎么办（抢不到玩命抢；抢不到暂时睡着，等一段时间再试/等通知再试；或者二者的结合，先玩命抢几次，还没抢到就睡着） 如果锁被释放了还有其他等待锁的怎么办（不管，让等的线程通过超时机制自己抢；按照一定规则通知某一个等待的线程；通知所有线程唤醒他们，让他们一起抢……） 有了这些选择，你就可以按照业务需求组装出你需要锁 (可见，作者是从第一性原理来理解锁的) 7.1.3. 线程同步与线程通信的关系 线程同步 体现了 ？ 线程通信 体现了 多个线程的 合作性（类似于 A线程调用B线程，去完成一件事情），比如Handler机制 7.2. 线程互斥/非互斥（功能） 互斥，是指对于共享的进程系统资源，在各单个线程访问时的排它性 非互斥---------没对共享的做保护 7.2.1. 支撑线程互斥功能的结构 信号量、锁........见上 7.3. 线程通信(功能) 参考：https://blog.csdn.net/qq_45453784/article/details/124157666 what： 多个线程间的一种协作机制： 比如Handler机制 7.3.1. 支撑线程通信功能的结构 信号量、锁........见上 8. TODO: 上面Handler和Binder分析方式完全不一样 Binder： FMSR 分析方法。基于功能解释 ----> 注意力在功能上 ​ 优点：有章法。知道为啥这样做 Handler: 基于生活化模型，解释 -----> 注意力生活化模型上 ​ 优点：如果模型非常能反映 代码，那么更容易记忆与理解 ​ 缺点：Handler 行文之间，明显缺乏链接 9. 格式 9.1. 使用逻辑： 跳转使用逻辑 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/AndriodSystem.html":{"url":"coding/Andriod/AndriodSystem.html","title":"Andriod System","keywords":"","body":"1. 目录2. 官方文档3. 对系统的理解与疑问4. 0层4.1. 静态0层4.2. 动态0层 ---> 以进程的视角4.3. 知识点0层5. 源码地图：即分层，细化5.1. framework基础框架，0层5.2. 其中，WMS 1层6. 系统启动流程（纵向主线）7. APP启动流程（纵向主线）8. window8.1. 0层8.2. setAttributes流程：8.3. vSync - surface -window-view 0层：8.4. 参考的博客资料：9. View/ViewGroup9.1. 功能点0层9.2. UI刷新 -invalidate9.2.1. 流程图：9.2.2. 调用栈角度：9.2.3. 关于首帧9.3. 性能方面的优化：9.4. 面试题：9.4.1. 多次invalidate 会刷新几次？9.4.2. Activity, Window,View三者的联系和区别?9.4.3. 关于首帧问题9.4.4. 我们调用invalidate()之后会马上进行屏幕刷新吗?9.4.5. 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧?9.4.6. 都有消息屏障，为什么还会掉帧呢？10. Grapics10.1. 0层框架-----系统数据流向：10.2. 硬件框架10.3. 0层框架10.4. 0层纵向10.5. 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计10.5.1. 背景：10.5.2. 问题1：帧缓冲区同时读写，会造成画面的撕裂10.5.3. 基于双缓冲机制，问题2：10.5.4. 基于双缓冲机制+Vsync机制，问题3：10.6. SurfaceFlinger 图形合成者10.6.1. 功能（what）10.7. 解决屏幕撕裂、卡顿、掉帧问题10.8. 关于掉帧的实操10.9. 申请surface的流程(APP向surfaceFlinger)10.9.1. Q&A：10.10. 关于draw：10.11. 面试问题：10.12. Grapics-----Flutter10.12.1. Flutter渲染pipeline10.12.2. Flutter数据模型---四棵树0层10.13. 几个概念：10.13.1. 硬件加速（GPU） 与 软件加速(CPU)10.13.2. 硬件合成(HWC) 与 软件合成10.14. 参考文章：11. view-Graphic 纵向0层12. SurfaceFlinger13. 无障碍14. 应用程序消息处理机制分析15. 稳定性专题15.1. ANR16. 内存泄漏专题17. 内存抖动专题18. 安卓资源：18.1. 见config需求分析18.2. 资源目录结构18.2.1. symbols.xml 系统私有资源18.2.2. public.xml公共资源18.2.3. attrs.xml18.2.4. 以attr为例子：18.2.5. style19. ViewOverlay20. 安卓面试题目20.1. Activity生命周期？20.2. Activity的启动过程20.3. Broadcast注册方式与区别20.3.1. HttpClient、HttpUrlConnection20.3.2. java虚拟机和Dalvik虚拟机的区别20.3.3. 进程保活（不死进程）20.3.4. 讲解一下Context20.3.5. 理解Activity,View,Window三者关系20.3.6. 四种LaunchMode及其使用场景21. 安卓基础知识21.1. aidl21.1.1. aidl的理解21.1.2. Android中Parcelable接口：21.1.3. 状态保存分析，待合并21.1.4. 关于Binder21.2. 关于线程的理解：21.2.1. 什么是线程？21.2.2. 什么是主线程？21.2.3. 安卓主线程是一个死循环22. 输入法23. 安卓逆向24. 计算机基础24.1. 操作系统之进程管理25. 性能专题25.1. 其他26. 面试26.1. 项目相关问题：26.1.1. 开发26.1.2. 软件经理26.2. 面试技术问题26.2.1. 帧数据的流转26.2.2. 需要补充的知识点：26.3. 一些好的点26.4. 问面试官的问题26.5. 谈薪资27. 参考文章28. Android开发常用网站28.1. Android 相关29. 格式29.1. 使用逻辑：29.2. 标记29.3. 隐藏TreeviewCopyright © aleen42 all right reserved, powered by aleen42 官方文档 对系统的理解与疑问 0层 静态0层 动态0层 ---> 以进程的视角 知识点0层 源码地图：即分层，细化 framework基础框架，0层 其中，WMS 1层 系统启动流程（纵向主线） APP启动流程（纵向主线） window 0层 setAttributes流程： vSync - surface -window-view 0层： 参考的博客资料： View/ViewGroup 功能点0层 UI刷新 -invalidate 流程图： 调用栈角度： 关于首帧 首次 View 的绘制流程是在什么时候触发的?----> 即首帧的触发 onResume函数中度量的高有效? 性能方面的优化： 面试题： 多次invalidate 会刷新几次？ Activity, Window,View三者的联系和区别? 关于首帧问题 我们调用invalidate()之后会马上进行屏幕刷新吗? 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 都有消息屏障，为什么还会掉帧呢？ Grapics 0层框架-----系统数据流向： 硬件框架 0层框架 0层纵向 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计 背景： 问题1：帧缓冲区同时读写，会造成画面的撕裂 基于双缓冲机制，问题2： 基于双缓冲机制+Vsync机制，问题3： Q&A环节： 补充： 三缓冲，可以关闭 SurfaceFlinger 图形合成者 功能（what） 解决屏幕撕裂、卡顿、掉帧问题 关于掉帧的实操 申请surface的流程(APP向surfaceFlinger) Q&A： 关于draw： 面试问题： Grapics-----Flutter Flutter渲染pipeline Flutter数据模型---四棵树0层 layout过程： 几个概念： 硬件加速（GPU） 与 软件加速(CPU) 面试题：既然硬件加速很好，为啥还要有软件加速？ 硬件合成(HWC) 与 软件合成 参考文章： view-Graphic 纵向0层 SurfaceFlinger 无障碍 应用程序消息处理机制分析 稳定性专题 ANR 内存泄漏专题 内存抖动专题 安卓资源： 见config需求分析 资源目录结构 symbols.xml 系统私有资源 public.xml公共资源 attrs.xml 以attr为例子： style ViewOverlay 安卓面试题目 Activity生命周期？ Activity的启动过程 Broadcast注册方式与区别 HttpClient、HttpUrlConnection java虚拟机和Dalvik虚拟机的区别 进程保活（不死进程） 讲解一下Context 理解Activity,View,Window三者关系 四种LaunchMode及其使用场景 View的绘制流程 View，ViewGroup事件分发 保存Activity状态 Android中的几种动画 Android中跨进程通讯的几种方式 AIDL理解 Handler的原理 Binder机制原理 热修复的原理 Android内存泄露及管理 Fragment、Activity通信的方式 Android UI适配 app优化 图片优化 HybridApp WebView和JS交互 JAVA GC原理 27、ANR 安卓基础知识 aidl aidl的理解 Android中Parcelable接口： 何时使用？使用例子 parcel #1 parcel.writeString 如何转的？？？ 复杂化：Book类里面有其它对象 Parcelable与Intent或者Bundle 与Serializable对比，优劣势？ 状态保存分析，待合并 关于Binder 关于线程的理解： 什么是线程？ 什么是主线程？ 安卓主线程是一个死循环 输入法 安卓逆向 计算机基础 操作系统之进程管理 性能专题 其他 面试 项目相关问题： 开发 软件经理 所做的事情 遇到需求交不了，你是怎么解决的： 遇到很多领域都没完成的 对某一个项目中遇到的问题，举一反三 面试技术问题 帧数据的流转 需要补充的知识点： 一些好的点 问面试官的问题 谈薪资 参考文章 Android开发常用网站 Android 相关 格式 使用逻辑： 标记 隐藏 1. 目录 [TOC] 2. 官方文档 1、 https://source.android.google.cn/docs/core/display/multi_display/displays?authuser=0&hl=zh-cn#focus 官方文档是最快搭建知识框架的方式！！！ 重要的事只有一件，同样重要的文档只有一个-------官方文档 从哪些角度理解安卓？以上 2、Android 开发者 https://developer.android.com/guide?hl=zh-cn 3、Google git 查找提交记录 https://android.googlesource.com/platform/frameworks 3. 对系统的理解与疑问 系统是status在时间上的流淌，即status(t)-----> 以帧来理解系统 那么多status，抓主status（次要status为主要服务） 如何理解dump？即一帧status 规定： 1、每一个status都要只要adb 设置的的方法，和get的方法 ，比如 perDisplayFocusEnabled设置是xml，获取是 WindowManagerService#mPerDisplayFocusEnabled debug可以看 2、永远不相信任何一个set（只有经历get之后，才能确定） 疑问： 那么多进程与线程，如何做到协调？ -------》 一定是有大的结构协调（小协调依附于大协调） ​ 抛开代码不谈，事物的本质？ 如何协调硬件资源？ 4. 0层 https://mp.weixin.qq.com/s/saps9pV-HEAon4majH1-aQ 注：所有的知识，必须脱离纸面、脱离文字！！！！！！！！ 4.1. 静态0层 Android底层内核空间以Linux Kernel作为基石，上层用户空间由Native系统库、虚拟机运行环境、框架层组成，通过系统调用(Syscall)连通系统的内核空间与用户空间。对于用户空间主要采用C++和Java代码编写，通过JNI技术打通用户空间的Java层和Native层(C++/C)，从而连通整个系统。 4.2. 动态0层 ---> 以进程的视角 系统启动架构图： 见 《系统启动流程》 4.3. 知识点0层 注意点： RunTime 和 异常原理 5. 源码地图：即分层，细化 5.1. framework基础框架，0层 见 AndriodSystem_Others 5.2. 其中，WMS 1层 见 AndriodSystem_Others 6. 系统启动流程（纵向主线） 见《InitSystem.md》 7. APP启动流程（纵向主线） 见《startAPP.md》 8. window 8.1. 0层 注意：这里并没有statusBar的window （G:\\working_pan\\doc_my\\Draw\\Activity_window_dialog.eddx） 1、每个window结构都如此，dialog亦如此 2、activity的本质是 context 3、dialog本质是 window。。。new的时候需要传入context，即activity，必须依赖activity 1、Z的dialog包了A的window ，A的window里又塞了A的surfaceview（Z画图的地方） ------》2、给window里再塞一块view，置于surfaceview之上。Z dialog有两块surface了 -------》todo： 第二块surface和canvas啥关系？ 如果说为啥surface换了，canvas没换？地址 todo：status bar 属于哪个widow，哪个进程 SurfaceView有自己的窗口 。所以，如果一个Activity有一个SurfaceView，它将有多个窗口。 关于dialog： TODO： dialog里面的window也是phoneWindow ！！！！自己new出来的 final Window w = new PhoneWindow(mContext); PhoneWindow持有WindowManagerImpl（即是WindowManager） 8.2. setAttributes流程： dialog -》被塞到了Window(PhoneWindow)里，mWindowAttributes记录，-》PhoneWindow.dispatchWindowAttributesChanged() 注意：linearLayout，没有包statusBar ----> (1) linearLayout包含的是statusBar和navigationBar的背景, 因为 statusBar本身透明，需要下一层的window显示颜色？？？（TODO: 为什么要这样设计？？） （2）statusBar和navigationBar在另一个window上（TODO: 一个还是两个？？？） ----》对于dialog类型的呢？？？ Dialog： （https://ericchows.github.io/Android-Window-Mechanism/） 带你彻底理解 Window 和 WindowManager Surface是一个对象，用于保存与屏幕合成的像素。 每个窗口（对话框，全屏活动，状态栏）都有自己的绘图表面surface。（todo：如果没有view，surface还能显示嘛？Z dialog证明不能？） Window Manager creates a Surface for each window and gives it to the application for drawing. Todo：验证。 应用指的具体是啥，哪个类 wm哪个进程？ Surface Flinger会以正确的Z顺序将这些窗口渲染到最终显示 关于view： 1、A View is an interactive UI element inside of a window. 交互用的 2、A window has a single view hierarchy attached to it, which provides all of the behavior of the window. 独一的view体系 下面有四个window，对应四个surface ----》有几个canvas？？？？ TODO: surface、canvas 画图往这个上画————》最终怎么呈现的？ 谁创建的surface？（window粒度的）最终用作什么了？ 8.3. vSync - surface -window-view 0层： 见 AndriodSystem_Others 8.4. 参考的博客资料： https://ericchows.github.io/Android-Window-Mechanism/ --->优 9. View/ViewGroup view （G:\\working_pan\\doc_my\\Draw\\view_viewGroup.eddx） 其中，Graphic与Input是核心 , 与用户交互的两个功能点：看和触摸 9.1. 功能点0层 见li 11 9.2. UI刷新 -invalidate 9.2.1. 流程图： 关键函数：vsync信号 1、必然有请求： invalidate -----> scheduleTraversal： 请求vsync、设置同步屏障。 2、必然有执行: perform................ 绘制、 取消同步屏障？ 新增枝叶： 1、为了给 vsync信号 带来的 vsync msg 让道， 请求vsnc的同时（自然），插入同步屏障： --------》见handler 同步屏障 必然： 1、所有 控件的 invalidate操作，最终都 转接到 ViewRootImpl的invalidate (设计模式上，单一职责) 9.2.2. 调用栈角度： 1、请求： 2、vsync信号来后，执行： 等到VSYNC到来后， 会移除同步栅栏 ----- 》 TODO: 具体哪里？ todo：很奇怪，这里为啥涉及到两次 消息？ 9.2.3. 关于首帧 首次 View 的绘制流程是在什么时候触发的?----> 即首帧的触发 Activity Resume时-> WindowManagerImpl.addView -> WindowManagerGlobal.addView-> ViewRootimpl.setView -> ViewRootimpl.requestLayout ->ViewRootImpl.scheduleTraversals onResume函数中度量的高有效? Activity第一次调用onResume的时候是无效的 Activity第二次之后调用onResume是有效 因为首次request vysn是在addwindow过程中（viewrootimpl的setview） 下一帧，才真正绘制（包括测量、layout、draw） 9.3. 性能方面的优化： 房间中椅子坏了，不会换整个房子 局部刷新：dirty脏区 9.4. 面试题： 9.4.1. 多次invalidate 会刷新几次？ 代码上： 有标致 设计上：是不得不的。 因为vsync信号，从上到下隔离 1.onResume函数中度量的高有效? 2.Activity, Window,View三者的联系和区别? 3. 首次 View 的绘制流程是在什么时候触发的? 4.我们调用invalidate()之后会马上进行屏幕刷新吗? 5.我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 问题1和问题3和问题4，是一个东西 因为首次request vysn是在addwindow过程中（viewrootimpl的setview） 下一帧，才真正绘制（包括测量、layout、draw） 9.4.2. Activity, Window,View三者的联系和区别? 9.4.3. 关于首帧问题 见《关于首帧》 9.4.4. 我们调用invalidate()之后会马上进行屏幕刷新吗? 9.4.5. 我们说丢帧是因为主线程做了耗时操作,为什么主线程做了耗时操作就会引起丢帧? 9.4.6. 都有消息屏障，为什么还会掉帧呢？ 因为消息屏障之前的消息（具体指哪些？），还会执行的 主线程加的消息屏障 10. Grapics 10.1. 0层框架-----系统数据流向： 参考: https://blog.csdn.net/qq_45254908/article/details/125449470 0层框架中的角色： 1、image stream produceers 图像流生产者（见图） ， 即生成BufferData的： OpenGL ES、NDK(即Skia)、Canvas 2D 、 mediaserver等。 例： draw方法把 绘制指令 通过canvas传递给framework层的RenderThread线程，在buffer上绘制 两种生产方式： （1） NDK（Skia），OpenGL ES是通过自身的绘制能力生产的图像数据 （2） MediaPlayer和Camera Preview是通过直接读取图像源来生成图像数据 2、 image stream consumers 图像流消费者，消费 BufferData的： SurfaceFlinger： 消耗当前可见的Surface（对应的buffer数据）+ 不同buffer数据 合成到屏幕 （自然，是根据图中 WMS 提供的window信息） OpenGL ES 应用也可以消费：例如相机应用会消耗相机预览图像流 ------> TODO: 证明 并没有经过 SurfaceFlinger 显示子系统的硬件抽象实现，在HAL中： 负责协助消费者把图形数据展示到设备屏幕。 图形内存分配器 (Gralloc) ： 分配图像生产方请求的内存 缓冲区 Buffer Queue： TODO: 这个到底是啥？ 下面图到底是个啥？ 可以大概看到BufferQueue的工作过程： TODO BufferQueue 类是 Android 中所有图形处理操作的核心。它的作用很简单：将生成图形数据缓冲区的一方（生产方）连接到接受数据以进行显示或进一步处理的一方（消耗方）。 即：Android中的图像生产者OpenGL，Skia，Vulkan将绘制的数据存放在图像缓冲区中，Android中的图像消费SurfaceFlinger从图像缓冲区将数据取出，进行加工及合成 https://www.androidperformance.com/2020/02/14/Android-Systrace-SurfaceFlinger/#/BufferQueue-%E9%83%A8%E5%88%86 注意： 1、 一个可见APP对应一个BufferQueue（有backBuffer和frontBuffer） 2、frontButter是要 经过 SurfaceFlinger合成 TODO: 证明 10.2. 硬件框架 出自：《1-111显示系统框架_framebuffer原理及改进.wmv》 TODO: DisplayControl的作用？ 操纵LCD去读取FrameBuffer？ 屏幕：内存的关系： 屏幕上一个像素16位 ，即 2字节 ----> 内存Buffer： 800*600* 2字节 10.3. 0层框架 1、贯穿0层框架的主线buffer： buffer的获取，填充完的buffer流转过程 2、基于0层框架，自然： （1）数量关系： 1个 window ： 1个surface：一个bufferQueue（三个buffer）：一个bufferQueueLayer 注意：给到surface的 是一个buffer 即surface是对buffer的封装 ，一个surface内部具有多个buffer TODO: 上述的buffer与frameBuffer什么关系？frameBuffer应该是一个屏幕大小 frameBuffer有几个？ 三缓冲，处于0层框架什么位置？ BufferQueue中: SurfaceFling 消费 FrontBuffer，GPU 使用一个 BackBuffer，CPU使用一个 BackBuffer -----> TODO: GPU在软件上是怎么调用的？CPU 怎么调用的？ 硬件图： 出自： https://androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#/Android-%E7%89%88%E6%9C%AC-lt-Android-P TODO: 0层架构图 与 硬件图中 CPU和GPU 什么关系？ 如何整合到一起表达？？？？？？？？？？】 10.4. 0层纵向 自然： 1、Render线程--> SurfaceFlinge进程： 跨了进程 所以，不得不：BufferQueue中的 backBuffer 通过Binder的形式提供给了APP的Render线程 （TODO，核心:Binder 如何流转给APP的？！！！！） 2、App 是生产者，负责填充显示缓冲区（Buffer）；SurfaceFlinger 是消费者，将各个进程的显示缓冲区做合成操作。 3、触发点：vsync信号过来，view.onDraw 10.5. 三缓冲+vsync：从显示屏显示讲起，为什么要这么设计 10.5.1. 背景： 屏幕刷新率（即屏幕读取速率）： 1、固定是16.67ms （永恒不变的） 2、其 物理本质就是 逐行扫描 的时间：显示器并不是一次性将显存里的数据显示到屏幕上，而是从左到右边，从上到下逐行扫描，顺序显示整屏的一个个像素点（硬件 晶体管），不过这一过程快到人眼无法察觉到变化。 沿着帧缓冲区 逐行扫描： 注意，这里的内存实际上是显存（GPU的） vsync信号 ： 1、硬件天然存在的（在硬件侧可能不叫vsync），与是否发给软件无关。注意区别 vsync信号 与vsync机制 2、标致着屏幕开始扫描 系统帧速率FPS（即CPU+GPU 合成数据速率）： 代表了系统在一秒内合成的帧数, 该值的大小由系统算法和硬件决定 (没有vsync时，其实不是固定的) 两者的关系造成的问题（没有vsync和双缓冲机制的话），胖子吃面包模型： ①屏幕刷新速率比系统帧速率快 胖子吃的很快，面包不够 ------> 「造成一帧显示多次,也就是卡顿。」 ②系统帧速率比屏幕刷新率快 胖子吃的慢，面包很多就吃了一半 ------> 「造成屏幕上显示多帧,也就是屏幕撕裂。」 ③系统帧速率 快很多 胖子很多面包没吃就跳过了 ------> 跳帧 ------------------》 一句话总结vsync： 卡顿、撕裂、跳帧 就是Vsync设计的初衷 为啥绘制阶段，也用到了GPU? Todo 10.5.2. 问题1：帧缓冲区同时读写，会造成画面的撕裂 问题1：并发问题（存在临界资源 竞争问题） 解决问题1，不得不： 双缓冲机制： fontBuffer、backBuffer -------》 并发，性能高：可以一个写一个读，之后，两个交换指针 加锁： 太耗费性能，而且 不能同时 读和 写 ----》 不是并发 引入双缓冲机制： 双缓冲的位置（线程）： fontBuffer、backBuffer 在bufferQueue里面嘛？ 与 屏幕进行交互的，我理解只有一个buffer(所有APP的) 所以，上面图有没有问题？？？？？？？？？？？？？？是不是少了合成这一步？？？ 基于双缓冲区，不得不的结论，铁律： 即使没有vsync机制，交换指针的时机，就是 vsync时机（因为这个时候，前刚被用完，后填充完）：这个因为此时刚好扫描完，硬件决定的 （注：1、图中vsync只是固有的硬件信号，还没有vsync机制 ​ 2、图中蓝、绿都是指backBuffer，时间先后 ​ 3、后的1 在下个扫描时，交换给了Display ​ 4、这里Display即屏幕，即屏幕刷新速率 ， 自然 ​ 5、图中GPU+CPU 即 系统帧速率 ​ 6、注意：图中的 0和1理解为 内容数据 ，而不是内存，下同 内存是框起来的部分，两个 ​ 7、不得不，CPU+GPU准备好数据为一帧数据，显示display 必然在下一帧显示 这个数据） 10.5.3. 基于双缓冲机制，问题2： 存在的问题2： 卡顿：因为vsync机制，CPU+GPU 绘制数据不是vsync触发，而是APP自己触发的，很可能backBuffer没准备好（即上面 屏幕刷新率快 问题） -----> 导致，Display用的上一帧数据, 屏幕平白无故地多显示了一次第1帧。 TODO: 这不是丢帧呀？？？？ https://blog.csdn.net/qq_45254908/article/details/125449470 假设图中是双缓冲的（1234明显不是） 解决问题2的方法，引入vsync机制： 把硬件信号，给到软件，触发 软件绘制backBuffer(即CPU+GPU 填充backBuffer) -----》 结果：自然，如果性能ok，后必然在 16.67ms内准备ok。不存在问题 一些不得不： 1、vsync信号是CPU执行的起点，即view.draw ---------> 软件设计保证的 2、vsync信号 是 指针交换时刻 ---------> 硬件决定的，此时刚好 扫描完，必须交换 10.5.4. 基于双缓冲机制+Vsync机制，问题3： 双缓冲机制+Vsync机制 其实已经非常好了，解决大部分情况。 问题3： 双缓冲机制+Vsync机制 好的前提是 ，CPU + GPU 在16ms内完成了工作 极端情况下，CPU + GPU 没能及时完成工作，导致下一帧显示数据没准备好： 解决办法，让CPU多多跑起来（三缓冲）： 红框处 GPU 占据着 BackBuffer，CPU没有填充的内存，所以单独给其一个BackBuffer -----》 注意：三缓冲本质： 让CPU多多跑起来，所以只是一个优化，不是一个大的机制变动 最左边，三块内存; A B C是 内容 Q&A环节： 1、三缓冲 + Vsync机制： CPU开始用 新的C内存，生成C数据（注意：C数据两帧之后才显示），那么 ​ 补充： 三缓冲，可以关闭 所以，不是必须的 https://blog.csdn.net/wjky2014/article/details/117962861 10.6. SurfaceFlinger 图形合成者 10.6.1. 功能（what） 从进程角度：SF是整个Android系统渲染的核心进程 -----> TODO: 什么是渲染？渲染到底做了啥？I 从功能角度：将所有Surface到Framebuffer -----> todo： Surface的buffer与 Framebuffer 数据转换上什么关系？ 个数上是什么比例？ 从信息流角度：信息的传递： 1、以Surface为图元数据 2、SurfaceFlinger： 所有 图层(Surface数据 )合成。 3、最终交给CPU和GPU 绘制-----> 绘制是什么概念？跟view的draw是什么区别？ 绘制的结果又是啥？ 设计模式：生产者-消费者 Queue：BufferQueue 这里表达不清 TODO: surface对应buffer去画，跨进程到 surfaceflinger？ 图元数据到底是进程级别？还是 surface？ 区别很大 surface属于应用进程，那么在 surfaceflinger端是什么数据结构？ 硬件合成与软件合成，理解TODO： 软件合成：软件将多个surface合成一个屏幕图像，给到屏幕 硬件合成： 实操： adb shell dump System surfaceFlinger 10.7. 解决屏幕撕裂、卡顿、掉帧问题 三缓冲机制 + vsync 10.8. 关于掉帧的实操 10.9. 申请surface的流程(APP向surfaceFlinger) 目的： 解决在哪里绘制问题？ 图出自： https://www.jianshu.com/p/7a18666a43ce Android画面显示流程分析(4) 主要：WMS去申请的 触发时机： viewRootImpl.performTraversals时 ----> relayoutWindow TODO 三个进程，APP，system_server, surfaceflinger 10.9.1. Q&A： Q：为什么要经过wms? APP直接 向 surfaceflinger 申请呢？ --------->A： 不行，wms要管理surface TODO: 具体如何管理的？ Q: app侧的java surface就是一个空壳子 ​ WMS surfaceControl 是surface的包装类，无法直接控制surface 10.10. 关于draw： 主线程与render线程之间数据同步：绘图指令集 （主产生，render利用canvas去 执行 指令集，结果：buffer上） 见 《0层纵向》 TODO: 卡顿、掉帧 -----》 这些概念对应的 物理解释！！！ 10.11. 面试问题： 问题 丢帧(掉帧) ，是说 这一帧延迟显示 还是丢弃不再显示 ？ 答：延迟显示，因为缓存交换的时机只能等下一个VSync了。 布局层级较多/主线程耗时 是如何造成 丢帧的呢？ 答：布局层级较多/主线程耗时 会影响CPU/GPU的执行时间，大于16.6ms时只能等下一个VSync了。 16.6ms刷新一次 是啥意思？是每16.6ms都走一次 measure/layout/draw ？ 答：屏幕的固定刷新频率是60Hz，即16.6ms。不是每16.6ms都走一次 measure/layout/draw，而是有绘制任务才会走，并且绘制时间间隔是取决于布局复杂度及主线程耗时。 measure/layout/draw 走完，界面就立刻刷新了吗? 答：不是。measure/layout/draw 走完后 会在VSync到来时进行缓存交换和刷新。 如果界面没动静止了，还会刷新吗？ 答：屏幕会固定每16.6ms刷新，但CPU/GPU没有绘制任务时就不走绘制流程。 VSYNC具体指啥？在屏幕刷新中如何工作的？ 答：当扫描完一个屏幕后，设备需要重新回到第一行以进入下一次的循环，此时会发出一个vertical sync pulse（垂直同步脉冲）来保证双缓冲在最佳时间点才进行交换。并且Android4.1后 CPU/GPU的绘制是在VSYNC到来时开始。 屏幕刷新使用 双缓存、三缓存，这又是啥意思呢？ 答：双缓存是Back buffer、Frame buffer，用于解决画面撕裂。三缓存增加一个Back buffer，用于减少Jank。 ———————————————— 版权声明：本文为CSDN博主「贺兰猪」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/u013773608/article/details/125142405 什么是surfaceView'？TODO 10.12. Grapics-----Flutter 10.12.1. Flutter渲染pipeline Flutter的渲染管道分为以下七个步骤： 用户输入（User Input）： 响应用户通过鼠标、键盘、触摸屏等设备产生的手势行为。 动画（Animation）： 基于定时器（Timer）更新当前帧的数据。 构建（Build）： 三棵树的创建，更新和销毁阶段，StatelessWidget和State的build方法将在改阶段执行。 布局（Layout）： Render Tree将在该阶段完成各个节点的大小和位置计算。 绘制（Paint）： Render Tree遍历每个节点，生成Layer Tree、RenderObject的paint方法在该阶段执行，生成一系列绘制指令。 合成（Composition）： 处理Layer Tree，生成一个Scene对象，作为栅格化的输入。-->TODO: 这个地方与英文图有差异, 一个是 栅格化（Rasterize）：将绘制指令处理成可供GPU上屏的原始数据（合成的视图数据其实还是一份矢量描述数据，光栅化帮助把这份数据真正地生成一个一个的像素填充数据，即 矢量描述---> 像素填充） 10.12.2. Flutter数据模型---四棵树0层 https://docs.flutter.dev/resources/architectural-overview TODO: 1、flutter一个widgets会对应非常多的element嘛？（Y是这样）上图没有体现出来 2、flutter的layerTree到底是啥？ layout过程： 布局约束 https://www.cnblogs.com/qianxiaox/p/14120511.html 盒子协议： 10.13. 几个概念： Paint画笔：颜色、画笔宽度、 canvas: 画家画圆、画三角形 bitmap: 位图－－> 存储像素的，初始的时候，是空的 surface (有多于一个的缓冲区（通常是两个）来做双缓冲渲染）：屏幕缓存/墙(比bitMap大很多）一》真正的画布 --------------------> 上述几个概念是类。存在于Skia 图像渲染库中 SurfaceFlinger: 按照它们的Z轴顺序将各个surface渲染出来 view: 是—个舞台，让其他演员演绎的舞台 https://www.cnblogs.com/CreateLight/archive/2012/07/04/2575401.html 好代码设计原则：－－－－＞举例子，所有代码的设计原则，给出总结 1、模块分层合理，类职责清晰，代码可读性强，注释规范 2、模块具有过载流控能力，支持非法输入校验和外部输入防御性拷贝，可靠性强；-----＞状态保存机制，在AZ转换地方，做了大小校验 3、所有参数采用动态配置项，可扩展性强； 4、消息处理过程中，减少不必要的内存复制与对象实例化操作，支持系统高并发； 10.13.1. 硬件加速（GPU） 与 软件加速(CPU) 1、本身没有软件加速这一概念。 2、硬件加速是基于软件加速做的优化（区分点）：Buffer数据谁来绘制 ​ 代码中的分歧点： //ViewRootImpl.java performTraversals relayoutWindow performMeasure performLayout performDraw 面试题：既然硬件加速很好，为啥还要有软件加速？ https://baijiahao.baidu.com/s?id=1709178794607037191&wfr=spider&for=pc 深度好文：理解Android硬件加速原理 10.13.2. 硬件合成(HWC) 与 软件合成 10.14. 参考文章： https://www.androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer Android Systrace 基础知识 - Triple Buffer 解读 https://blog.csdn.net/qq_45254908/article/details/125449470 https://blog.csdn.net/wjky2014/article/details/117962861 Systrace 之 三级缓存 Triple Buffer Android画面显示流程分析(1)~(5) https://www.jianshu.com/p/df46e4b39428 https://androidperformance.com/2019/12/15/Android-Systrace-Triple-Buffer/#/Android-%E7%89%88%E6%9C%AC-gt-Android-P 好文 https://community.nxp.com/t5/i-MX-Processors-Knowledge-Base/Android-Graphic-UI-with-GPU-Hardware-Acceleration/ta-p/1102023Android Graphic UI with GPU Hardware Acceleration https://baijiahao.baidu.com/s?id=1709178794607037191&wfr=spider&for=pc 深度好文：理解Android硬件加速原理 https://www.jianshu.com/p/6474297924b6 Android 图形系统（Graphics） 11. view-Graphic 纵向0层 即一帧的整体流程： 纵轴为时间 出自： https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/#/%E4%BB%8E%E6%89%A7%E8%A1%8C%E9%A1%BA%E5%BA%8F%E7%9A%84%E8%A7%92%E5%BA%A6%E6%9D%A5%E7%9C%8B 为什么选取一帧呢？ 一帧即是 for循环中一个 TODO: 上图是一个好的纵向0层图，借鉴其画法： 1、纵轴是时间、横轴为 空间（进程、线程、类） -------> 跟时序图很像 2、只列 最核心函数/功能 + 没有调用栈font> -------> 跟时序图差异 证据+细节： 12. SurfaceFlinger 13. 无障碍 见 《无障碍.md》 14. 应用程序消息处理机制分析 ---》（Looper、Handler）分析 总结：Android应用程序是通过消息来驱动的 系统为每一个应用程序维护一个消息队列，应用程序的主线程不断地从这个消息队例中获取消息（Looper），然后对这些消息进行处理（Handler），这样就实现了通过消息来驱动应用程序的执行--------》总结：消息驱动程序！！！！ 当ActivityManagerService需要与应用程序进行交互时，如加载Activity和Service、处理广播等，会通过Binder进程间通信机制来知（TODO:）会应用程序，应用程序接收到这个请求时，它不是马上就处理这个请求，而是将这个请求封装成一个消息，然后把这个消息放在应用程序的消息队列中去，然后再通过消息循环来处理这个消息。 ------->总结：1、AMS通过Binder请求应用程序 2、应用程序（TODO:具体哪个）自己发消息，然后自己处理 为什么要有这样的机制？？？好处: 消息的发送方只要把消息发送到应用程序的消息队列中去就行了，它可以马上返回去处理别的事情，而不需要等待消息的接收方去处理完这个消息才返回，这样就可以提高系统的并发性。实质上，这就是一种异步处理机制。（TODO:一个线程还是两个？要是一个，怎么异步的） 例子： 程序启动过程中（（TODO:）），要启动的应用程序称为Activity，它的默认Activity是MainActivity: Launcher来负责启动的，而Launcher又是通过ActivityManagerService来启动的，当ActivityManagerService为这个即将要启的应用程序准备好新的进程后，便通过一个Binder进程间通信过程来通知这个新的进程来加载MainActivity，如下图所示： 15. 稳定性专题 15.1. ANR 《什么是ANR_如何避免ANR.md》 《ANR问题的产生机制.pdf》 16. 内存泄漏专题 参考： https://mp.weixin.qq.com/s?__biz=MzA5MzI3NjE2MA==&mid=2650238704&idx=1&sn=ad334840afdc2d9bdb8215e9f942e54e&chksm=88639f9fbf1416898edfc3615a7ea25f6798e3bb6f3089ca720e18b92ce67328c623561cf35e&scene=27 好文 内存泄漏全解析 郭霖;) 2017-02-28 08:00 原因： 1、对于cpp：内存泄漏就是new出来的对象没有 delete -------》 例子：阎王 让你出生，忘记 让你死了 2、对于 java ：就是 new 出来的 Object 放在 Heap 上无法被GC回收 无法GC的原因：长生命周期的对象持有短生命周期对象的引用，尽管短生命周期的对象不再使用 ----》 例子：父子之间 同生共死 ，明显不合理 补充：目前java 常见GC，是可达性分析（还有计数引用） ​ 注意： 对于java，一般关心比较消耗内存的类，比如Activity; 不占内存的类，发生泄漏，其实没太大关系 疑问： cpp会产生类似于java那种嘛？A：不会，cpp对象的销毁由程序员自己去delete。 如果存在 父子之间 同生共死，那么就是 程序员自己delete 时机出了问题。 例子：见Handler导致的内存泄漏 规定： 在 Android 开发中，为了防止内存溢出，在处理一些占用内存大并且生命周期较长的对象的时候，可以尽量地使用 软引用 和 弱引用 技术。 17. 内存抖动专题 见设计模式---复用原则 18. 安卓资源： 18.1. 见config需求分析 18.2. 资源目录结构 18.2.1. symbols.xml 系统私有资源 （不对app公开) 18.2.2. public.xml公共资源 （可以在app中访问） 注意：公共资源在xml里给定了id值。但。。没有 public.xml的作用：1、显示对外了 2、给配了唯一的id ---》TODO:public为什么要配固定ID？？？ https://blog.csdn.net/joby1981/article/details/16809869 AOSP添加资源的方法： 如果要添加的资源是私有的，则加上 （不需要id），如果是公共的则先找到最后一个type为 drawable 的 public 项，4.2.2系统中最后一项为，然后添加一句 ，即id为最后一个的id+1（为了避免 id 冲突） 原文链接：https://blog.csdn.net/ganzhijie/article/details/38489957 18.2.3. attrs.xml -->基于类， 定义了其属性 1、定义了类的有哪些xml配置属性：--->导致IDE编辑时xml联想 比如：view类，有属性id、padding.......... Theme类 再比如：include类以及ViewGroup类： 2、TODO：attrs.xml 与public.xml什么关系？？？ 18.2.4. 以attr为例子： java中引用：android.R.attr.absListViewStyle 结论：attrs.xml ： ​ （2） 注意：format即类型，比如reference、boolean、dimension、integer、color。。。。。。。 format=\"reference\"是指这个类型是引用类型：引用某一资源id！！！ 1. //reference：参考另一资源ID。 （1）属性定义： （2）属性使用： //这里引用资源Id!!!!!! 3. boolean：布尔值。 （1）属性定义： （2）属性使用： ​ （2） 《-------到底对应什么资源？？？ todo: 18.2.5. style -style是可以继承的，并且子类可以修改父类的属性值 4行是继承 12行是修改 ----》这一点非常好：结论：资源本身对开发者也是public的！！！！ -----》所以，我理解，开发者是能够改变系统默认获焦效果（灰色）的！！！！！！！！！！ 自定义主题： G:\\working_pan\\Demo\\BarrierFree_demo\\app\\src\\main\\res\\values\\styles.xml // 这里自定义 @color/colorPrimary @color/colorPrimaryDark @color/colorAccent // 注意:这里必须用android: 才能覆盖--->跳转的地方不一样 @drawable/my_item_background false true 19. ViewOverlay ViewOverlay中的view或者drawable不会响应任何触摸事件 ----》本质：ViewOverlay是另一个抽象层（只显示，不响应） ---》用途：动画 20. 安卓面试题目 20.1. Activity生命周期？ onCreate() -> onStart() -> onResume() -> onPause() -> onStop() -> onDetroy() 20.2. Activity的启动过程 注意：（不要回答生命周期） app启动的过程有两种情况，第一种是从桌面launcher上点击相应的应用图标，第二种是在activity中通过调用startActivity来启动一个新的activity。 我们创建一个新的项目，默认的根activity都是MainActivity，而所有的activity都是保存在堆栈中的，我们启动一个新的activity就会放在上一个activity上面，而我们从桌面点击应用图标的时候，由于launcher本身也是一个应用，当我们点击图标的时候，系统就会调用startActivitySately(),一般情况下，我们所启动的activity的相关信息都会保存在intent中，比如action，category等等。我们在安装这个应用的时候，系统也会启动一个PackaManagerService的管理服务，这个管理服务会对AndroidManifest.xml文件进行解析，从而得到应用程序中的相关信息，比如service，activity，Broadcast等等，然后获得相关组件的信息。当我们点击应用图标的时候，就会调用startActivitySately()方法，而这个方法内部则是调用startActivty(),而startActivity()方法最终还是会调用startActivityForResult()这个方法。而在startActivityForResult()这个方法。因为startActivityForResult()方法是有返回结果的，所以系统就直接给一个-1，就表示不需要结果返回了。而startActivityForResult()这个方法实际是通过Instrumentation类中的execStartActivity()方法来启动activity，Instrumentation这个类主要作用就是监控程序和系统之间的交互。而在这个execStartActivity()方法中会获取ActivityManagerService的代理对象，通过这个代理对象进行启动activity。启动会就会调用一个checkStartActivityResult()方法，如果说没有在配置清单中配置有这个组件，就会在这个方法中抛出异常了。当然最后是调用的是Application.scheduleLaunchActivity()进行启动activity，而这个方法中通过获取得到一个ActivityClientRecord对象，而这个ActivityClientRecord通过handler来进行消息的发送，系统内部会将每一个activity组件使用ActivityClientRecord对象来进行描述，而ActivityClientRecord对象中保存有一个LoaderApk对象，通过这个对象调用handleLaunchActivity来启动activity组件，而页面的生命周期方法也就是在这个方法中进行调用。 20.3. Broadcast注册方式与区别 此处延伸：什么情况下用动态注册 Broadcast广播，注册方式主要有两种. 第一种是静态注册，也可成为常驻型广播，这种广播需要在Androidmanifest.xml中进行注册，这中方式注册的广播，不受页面生命周期的影响，即使退出了页面，也可以收到广播这种广播一般用于想开机自启动啊等等，由于这种注册的方式的广播是常驻型广播，所以会占用CPU的资源。 第二种是动态注册，而动态注册的话，是在代码中注册的，这种注册方式也叫非常驻型广播，收到生命周期的影响，退出页面后，就不会收到广播，我们通常运用在更新UI方面。这种注册方式优先级较高。最后需要解绑，否会会内存泄露 广播是分为有序广播和无序广播。 20.3.1. HttpClient、HttpUrlConnection 两者区别： 此处延伸：Volley里用的哪种请求方式（2.3前HttpClient，2.3后HttpUrlConnection） 首先HttpClient和HttpUrlConnection 这两种方式都支持Https协议，都是以流的形式进行上传或者下载数据，也可以说是以流的形式进行数据的传输，还有ipv6,以及连接池等功能。HttpClient这个拥有非常多的API，所以如果想要进行扩展的话，并且不破坏它的兼容性的话，很难进行扩展，也就是这个原因，Google在Android6.0的时候，直接就弃用了这个HttpClient. 而HttpUrlConnection相对来说就是比较轻量级了，API比较少，容易扩展，并且能够满足Android大部分的数据传输。比较经典的一个框架volley，在2.3版本以前都是使用HttpClient,在2.3以后就使用了HttpUrlConnection。 20.3.2. java虚拟机和Dalvik虚拟机的区别 Java虚拟机： 1、java虚拟机基于栈。 基于栈的机器必须使用指令来载入和操作栈上数据，所需指令更多更多。 2、java虚拟机运行的是java字节码。（java类会被编译成一个或多个字节码.class文件） Dalvik虚拟机： 1、dalvik虚拟机是基于寄存器的 2、Dalvik运行的是自定义的.dex字节码格式。（java类被编译成.class文件后，会通过一个dx工具将所有的.class文件转换成一个.dex文件，然后dalvik虚拟机会从其中读取指令和数据 3、常量池已被修改为只使用32位的索引，以 简化解释器。 4、一个应用，一个虚拟机实例，一个进程（所有android应用的线程都是对应一个linux线程，都运行在自己的沙盒中，不同的应用在不同的进程中运行。每个android dalvik应用程序都被赋予了一个独立的linux PID(app_*)） 20.3.3. 进程保活（不死进程） 此处延伸：进程的优先级是什么 当前业界的Android进程保活手段主要分为 黑、白、灰 三种，其大致的实现思路如下： 黑色保活：不同的app进程，用广播相互唤醒（包括利用系统提供的广播进行唤醒） 白色保活：启动前台Service 灰色保活：利用系统的漏洞启动前台Service 黑色保活 所谓黑色保活，就是利用不同的app进程使用广播来进行相互唤醒。举个3个比较常见的场景： 场景1：开机，网络切换、拍照、拍视频时候，利用系统产生的广播唤醒app 场景2：接入第三方SDK也会唤醒相应的app进程，如微信sdk会唤醒微信，支付宝sdk会唤醒支付宝。由此发散开去，就会直接触发了下面的 场景3 场景3：假如你手机里装了支付宝、淘宝、天猫、UC等阿里系的app，那么你打开任意一个阿里系的app后，有可能就顺便把其他阿里系的app给唤醒了。（只是拿阿里打个比方，其实BAT系都差不多） 白色保活 白色保活手段非常简单，就是调用系统api启动一个前台的Service进程，这样会在系统的通知栏生成一个Notification，用来让用户知道有这样一个app在运行着，哪怕当前的app退到了后台。如下方的LBE和QQ音乐这样： 灰色保活 灰色保活，这种保活手段是应用范围最广泛。它是利用系统的漏洞来启动一个前台的Service进程，与普通的启动方式区别在于，它不会在系统通知栏处出现一个Notification，看起来就如同运行着一个后台Service进程一样。这样做带来的好处就是，用户无法察觉到你运行着一个前台进程（因为看不到Notification）,但你的进程优先级又是高于普通后台进程的。那么如何利用系统的漏洞呢，大致的实现思路和代码如下： 思路一：API 思路二：API >= 18，同时启动两个id相同的前台Service，然后再将后启动的Service做stop处理 熟悉Android系统的童鞋都知道，系统出于体验和性能上的考虑，app在退到后台时系统并不会真正的kill掉这个进程，而是将其缓存起来。打开的应用越多，后台缓存的进程也越多。在系统内存不足的情况下，系统开始依据自身的一套进程回收机制来判断要kill掉哪些进程，以腾出内存来供给需要的app。这套杀进程回收内存的机制就叫 Low Memory Killer ，它是基于Linux内核的 OOM Killer（Out-Of-Memory killer）机制诞生。 进程的重要性，划分5级： 前台进程 (Foreground process) 可见进程 (Visible process) 服务进程 (Service process) 后台进程 (Background process) 空进程 (Empty process) 了解完 Low Memory Killer，再科普一下oom_adj。什么是oom_adj？它是linux内核分配给每个系统进程的一个值，代表进程的优先级，进程回收机制就是根据这个优先级来决定是否进行回收。对于oom_adj的作用，你只需要记住以下几点即可： 进程的oom_adj越大，表示此进程优先级越低，越容易被杀回收；越小，表示进程优先级越高，越不容易被杀回收 普通app进程的oom_adj>=0,系统进程的oom_adj才可能 有些手机厂商把这些知名的app放入了自己的白名单中，保证了进程不死来提高用户体验（如微信、QQ、陌陌都在小米的白名单中）。如果从白名单中移除，他们终究还是和普通app一样躲避不了被杀的命运，为了尽量避免被杀，还是老老实实去做好优化工作吧。 所以，进程保活的根本方案终究还是回到了性能优化上，进程永生不死终究是个彻头彻尾的伪命题！ 20.3.4. 讲解一下Context Context是一个抽象基类。在翻译为上下文，也可以理解为环境，是提供一些程序的运行环境基础信息。Context下有两个子类，ContextWrapper是上下文功能的封装类，而ContextImpl则是上下文功能的实现类。而ContextWrapper又有三个直接的子类， ContextThemeWrapper、Service和Application。其中，ContextThemeWrapper是一个带主题的封装类，而它有一个直接子类就是Activity，所以Activity和Service以及Application的Context是不一样的，只有Activity需要主题，Service不需要主题。Context一共有三种类型，分别是Application、Activity和Service。这三个类虽然分别各种承担着不同的作用，但它们都属于Context的一种，而它们具体Context的功能则是由ContextImpl类去实现的，因此在绝大多数场景下，Activity、Service和Application这三种类型的Context都是可以通用的。不过有几种场景比较特殊，比如启动Activity，还有弹出Dialog。出于安全原因的考虑，Android是不允许Activity或Dialog凭空出现的，一个Activity的启动必须要建立在另一个Activity的基础之上，也就是以此形成的返回栈。而Dialog则必须在一个Activity上面弹出（除非是System Alert类型的Dialog），因此在这种场景下，我们只能使用Activity类型的Context，否则将会出错。 getApplicationContext()和getApplication()方法得到的对象都是同一个application对象，只是对象的类型不一样。 Context数量 = Activity数量 + Service数量 + 1 （1为Application） 20.3.5. 理解Activity,View,Window三者关系 这个问题真的很不好回答。所以这里先来个算是比较恰当的比喻来形容下它们的关系吧。Activity像一个工匠（控制单元），Window像窗户（承载模型），View像窗花（显示视图）LayoutInflater像剪刀，Xml配置像窗花图纸。 1：Activity构造的时候会初始化一个Window，准确的说是PhoneWindow。 2：这个PhoneWindow有一个“ViewRoot”，这个“ViewRoot”是一个View或者说ViewGroup，是最初始的根视图。 3：“ViewRoot”通过addView方法来一个个的添加View。比如TextView，Button等 4：这些View的事件监听，是由WindowManagerService来接受消息，并且回调Activity函数。比如onClickListener，onKeyDown等。 20.3.6. 四种LaunchMode及其使用场景 此处延伸：栈(First In Last Out)与队列(First In First Out)的区别 栈与队列的区别： 队列先进先出，栈先进后出 \\2. 对插入和删除操作的\"限定\"。 栈是限定只能在表的一端进行插入和删除操作的线性表。 队列是限定只能在表的一端进行插入和在另一端进行删除操作的线性表。 \\3. 遍历数据速度不同 standard 模式 这是默认模式，每次激活Activity时都会创建Activity实例，并放入任务栈中。使用场景：大多数Activity。 singleTop 模式 如果在任务的栈顶正好存在该Activity的实例，就重用该实例( 会调用实例的 onNewIntent() )，否则就会创建新的实例并放入栈顶，即使栈中已经存在该Activity的实例，只要不在栈顶，都会创建新的实例。使用场景如新闻类或者阅读类App的内容页面。 singleTask 模式 如果在栈中已经有该Activity的实例，就重用该实例(会调用实例的 onNewIntent() )。重用时，会让该实例回到栈顶，因此在它上面的实例将会被移出栈。如果栈中不存在该实例，将会创建新的实例放入栈中。使用场景如浏览器的主界面。不管从多少个应用启动浏览器，只会启动主界面一次，其余情况都会走onNewIntent，并且会清空主界面上面的其他页面。 singleInstance 模式 在一个新栈中创建该Activity的实例，并让多个应用共享该栈中的该Activity实例。一旦该模式的Activity实例已经存在于某个栈中，任何应用再激活该Activity时都会重用该栈中的实例( 会调用实例的 onNewIntent() )。其效果相当于多个应用共享一个应用，不管谁激活该 Activity 都会进入同一个应用中。使用场景如闹铃提醒，将闹铃提醒与闹铃设置分离。singleInstance不要用于中间页面，如果用于中间页面，跳转会有问题，比如：A -> B (singleInstance) -> C，完全退出后，在此启动，首先打开的是B。 View的绘制流程 自定义控件： 1、组合控件。这种自定义控件不需要我们自己绘制，而是使用原生控件组合成的新控件。如标题栏。 2、继承原有的控件。这种自定义控件在原生控件提供的方法外，可以自己添加一些方法。如制作圆角，圆形图片。 3、完全自定义控件：这个View上所展现的内容全部都是我们自己绘制出来的。比如说制作水波纹进度条。 View的绘制流程：OnMeasure()——>OnLayout()——>OnDraw() 第一步：OnMeasure()：测量视图大小。从顶层父View到子View递归调用measure方法，measure方法又回调OnMeasure。 第二步：OnLayout()：确定View位置，进行页面布局。从顶层父View向子View的递归调用view.layout方法的过程，即父View根据上一步measure子View所得到的布局大小和布局参数，将子View放在合适的位置上。 第三步：OnDraw()：绘制视图。ViewRoot创建一个Canvas对象，然后调用OnDraw()。六个步骤：①、绘制视图的背景；②、保存画布的图层（Layer）；③、绘制View的内容；④、绘制View子视图，如果没有就不用； ⑤、还原图层（Layer）；⑥、绘制滚动条。 View，ViewGroup事件分发 \\1. Touch事件分发中只有两个主角:ViewGroup和View。ViewGroup包含onInterceptTouchEvent、dispatchTouchEvent、onTouchEvent三个相关事件。View包含dispatchTouchEvent、onTouchEvent两个相关事件。其中ViewGroup又继承于View。 2.ViewGroup和View组成了一个树状结构，根节点为Activity内部包含的一个ViwGroup。 3.触摸事件由Action_Down、Action_Move、Aciton_UP组成，其中一次完整的触摸事件中，Down和Up都只有一个，Move有若干个，可以为0个。 4.当Acitivty接收到Touch事件时，将遍历子View进行Down事件的分发。ViewGroup的遍历可以看成是递归的。分发的目的是为了找到真正要处理本次完整触摸事件的View，这个View会在onTouchuEvent结果返回true。 5.当某个子View返回true时，会中止Down事件的分发，同时在ViewGroup中记录该子View。接下去的Move和Up事件将由该子View直接进行处理。由于子View是保存在ViewGroup中的，多层ViewGroup的节点结构时，上级ViewGroup保存的会是真实处理事件的View所在的ViewGroup对象:如ViewGroup0-ViewGroup1-TextView的结构中，TextView返回了true，它将被保存在ViewGroup1中，而ViewGroup1也会返回true，被保存在ViewGroup0中。当Move和UP事件来时，会先从ViewGroup0传递至ViewGroup1，再由ViewGroup1传递至TextView。 6.当ViewGroup中所有子View都不捕获Down事件时，将触发ViewGroup自身的onTouch事件。触发的方式是调用super.dispatchTouchEvent函数，即父类View的dispatchTouchEvent方法。在所有子View都不处理的情况下，触发Acitivity的onTouchEvent方法。 7.onInterceptTouchEvent有两个作用：1.拦截Down事件的分发。2.中止Up和Move事件向目标View传递，使得目标View所在的ViewGroup捕获Up和Move事件。 保存Activity状态 onSaveInstanceState(Bundle)会在activity转入后台状态之前被调用，也就是onStop()方法之前，onPause方法之后被调用； Android中的几种动画 帧动画：指通过指定每一帧的图片和播放时间，有序的进行播放而形成动画效果，比如想听的律动条。 补间动画：指通过指定View的初始状态、变化时间、方式，通过一系列的算法去进行图形变换，从而形成动画效果，主要有Alpha、Scale、Translate、Rotate四种效果。注意：只是在视图层实现了动画效果，并没有真正改变View的属性，比如滑动列表，改变标题栏的透明度。 属性动画：在Android3.0的时候才支持，通过不断的改变View的属性，不断的重绘而形成动画效果。相比于视图动画，View的属性是真正改变了。比如view的旋转，放大，缩小。 Android中跨进程通讯的几种方式 Android 跨进程通信，像intent，contentProvider,广播，service都可以跨进程通信。 intent：这种跨进程方式并不是访问内存的形式，它需要传递一个uri,比如说打电话。 contentProvider：这种形式，是使用数据共享的形式进行数据共享。 service：远程服务，aidl 广播 AIDL理解 此处延伸：简述Binder AIDL: 每一个进程都有自己的Dalvik VM实例，都有自己的一块独立的内存，都在自己的内存上存储自己的数据，执行着自己的操作，都在自己的那片狭小的空间里过完自己的一生。而aidl就类似与两个进程之间的桥梁，使得两个进程之间可以进行数据的传输，跨进程通信有多种选择，比如 BroadcastReceiver , Messenger 等，但是 BroadcastReceiver 占用的系统资源比较多，如果是频繁的跨进程通信的话显然是不可取的；Messenger 进行跨进程通信时请求队列是同步进行的，无法并发执行。 Binde机制简单理解: 在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互， Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。 Handler的原理 Android中主线程是不能进行耗时操作的，子线程是不能进行更新UI的。所以就有了handler，它的作用就是实现线程之间的通信。 handler整个流程中，主要有四个对象，handler，Message,MessageQueue,Looper。当应用创建的时候，就会在主线程中创建handler对象， 我们通过要传送的消息保存到Message中，handler通过调用sendMessage方法将Message发送到MessageQueue中，Looper对象就会不断的调用loop()方法 不断的从MessageQueue中取出Message交给handler进行处理。从而实现线程之间的通信。 Binder机制原理 在Android系统的Binder机制中，是有Client,Service,ServiceManager,Binder驱动程序组成的，其中Client，service，Service Manager运行在用户空间，Binder驱动程序是运行在内核空间的。而Binder就是把这4种组件粘合在一块的粘合剂，其中核心的组件就是Binder驱动程序，Service Manager提供辅助管理的功能，而Client和Service正是在Binder驱动程序和Service Manager提供的基础设施上实现C/S 之间的通信。其中Binder驱动程序提供设备文件/dev/binder与用户控件进行交互，Client、Service，Service Manager通过open和ioctl文件操作相应的方法与Binder驱动程序进行通信。而Client和Service之间的进程间通信是通过Binder驱动程序间接实现的。而Binder Manager是一个守护进程，用来管理Service，并向Client提供查询Service接口的能力。 热修复的原理 我们知道Java虚拟机 —— JVM 是加载类的class文件的，而Android虚拟机——Dalvik/ART VM 是加载类的dex文件， 而他们加载类的时候都需要ClassLoader,ClassLoader有一个子类BaseDexClassLoader，而BaseDexClassLoader下有一个 数组——DexPathList，是用来存放dex文件，当BaseDexClassLoader通过调用findClass方法时，实际上就是遍历数组， 找到相应的dex文件，找到，则直接将它return。而热修复的解决方法就是将新的dex添加到该集合中，并且是在旧的dex的前面， 所以就会优先被取出来并且return返回。 Android内存泄露及管理 （1）内存溢出（OOM）和内存泄露（对象无法被回收）的区别。 （2）引起内存泄露的原因 (3) 内存泄露检测工具 ------>LeakCanary 内存溢出 out of memory：是指程序在申请内存时，没有足够的内存空间供其使用，出现out of memory；比如申请了一个integer,但给它存了long才能存下的数，那就是内存溢出。内存溢出通俗的讲就是内存不够用。 内存泄露 memory leak：是指程序在申请内存后，无法释放已申请的内存空间，一次内存泄露危害可以忽略，但内存泄露堆积后果很严重，无论多少内存,迟早会被占光 内存泄露原因： 一、Handler 引起的内存泄漏。 解决：将Handler声明为静态内部类，就不会持有外部类SecondActivity的引用，其生命周期就和外部类无关， 如果Handler里面需要context的话，可以通过弱引用方式引用外部类 二、单例模式引起的内存泄漏。 解决：Context是ApplicationContext，由于ApplicationContext的生命周期是和app一致的，不会导致内存泄漏 三、非静态内部类创建静态实例引起的内存泄漏。 解决：把内部类修改为静态的就可以避免内存泄漏了 四、非静态匿名内部类引起的内存泄漏。 解决：将匿名内部类设置为静态的。 五、注册/反注册未成对使用引起的内存泄漏。 注册广播接受器、EventBus等，记得解绑。 六、资源对象没有关闭引起的内存泄漏。 在这些资源不使用的时候，记得调用相应的类似close（）、destroy（）、recycler（）、release（）等方法释放。 七、集合对象没有及时清理引起的内存泄漏。 通常会把一些对象装入到集合中，当不使用的时候一定要记得及时清理集合，让相关对象不再被引用。 Fragment、Activity通信的方式 1.直接在一个Fragment中调用另外一个Fragment中的方法 2.使用接口回调 3.使用广播 4.Fragment直接调用Activity中的public方法 Android UI适配 字体使用sp,使用dp，多使用match_parent，wrap_content，weight 图片资源，不同图片的的分辨率，放在相应的文件夹下可使用百分比代替。 app优化 app优化:(工具：Hierarchy Viewer 分析布局 工具：TraceView 测试分析耗时的) App启动优化 布局优化 响应优化 内存优化 电池使用优化 网络优化 App启动优化(针对冷启动) App启动的方式有三种： 冷启动：App没有启动过或App进程被killed, 系统中不存在该App进程, 此时启动App即为冷启动。 热启动：热启动意味着你的App进程只是处于后台, 系统只是将其从后台带到前台, 展示给用户。 介于冷启动和热启动之间, 一般来说在以下两种情况下发生: (1)用户back退出了App, 然后又启动. App进程可能还在运行, 但是activity需要重建。 (2)用户退出App后, 系统可能由于内存原因将App杀死, 进程和activity都需要重启, 但是可以在onCreate中将被动杀死锁保存的状态(saved instance state)恢复。 优化： Application的onCreate（特别是第三方SDK初始化），首屏Activity的渲染都不要进行耗时操作，如果有，就可以放到子线程或者IntentService中 布局优化 尽量不要过于复杂的嵌套。可以使用，， 响应优化 Android系统每隔16ms会发出VSYNC信号重绘我们的界面(Activity)。 页面卡顿的原因： (1)过于复杂的布局. (2)UI线程的复杂运算 (3)频繁的GC,导致频繁GC有两个原因:1、内存抖动, 即大量的对象被创建又在短时间内马上被释放.2、瞬间产生大量的对象会严重占用内存区域。 内存优化：参考内存泄露和内存溢出部分 电池使用优化(使用工具：Batterystats & bugreport) (1)优化网络请求 (2)定位中使用GPS, 请记得及时关闭 网络优化(网络连接对用户的影响:流量,电量,用户等待)可在Android studio下方logcat旁边那个工具Network Monitor检测 API设计：App与Server之间的API设计要考虑网络请求的频次, 资源的状态等. 以便App可以以较少的请求来完成业务需求和界面的展示. Gzip压缩：使用Gzip来压缩request和response, 减少传输数据量, 从而减少流量消耗. 图片的Size：可以在获取图片时告知服务器需要的图片的宽高, 以便服务器给出合适的图片, 避免浪费. 网络缓存：适当的缓存, 既可以让我们的应用看起来更快, 也能避免一些不必要的流量消耗. 图片优化 (1)对图片本身进行操作。尽量不要使用setImageBitmap、setImageResource、BitmapFactory.decodeResource来设置一张大图，因为这些方法在完成decode后， 最终都是通过java层的createBitmap来完成的，需要消耗更多内存. (2)图片进行缩放的比例，SDK中建议其值是2的指数值,值越大会导致图片不清晰。 (3)不用的图片记得调用图片的recycle()方法 HybridApp WebView和JS交互 Android与JS通过WebView互相调用方法，实际上是： Android去调用JS的代码 通过WebView的loadUrl(),使用该方法比较简洁，方便。但是效率比较低，获取返回值比较困难。 通过WebView的evaluateJavascript(),该方法效率高，但是4.4以上的版本才支持，4.4以下版本不支持。所以建议两者混合使用。 JS去调用Android的代码 通过WebView的addJavascriptInterface（）进行对象映射 ，该方法使用简单，仅将Android对象和JS对象映射即可，但是存在比较大的漏洞。 漏洞产生原因是：当JS拿到Android这个对象后，就可以调用这个Android对象中所有的方法，包括系统类（java.lang.Runtime 类），从而进行任意代码执行。 解决方式： (1)Google 在Android 4.2 版本中规定对被调用的函数以 @JavascriptInterface进行注解从而避免漏洞攻击。 (2)在Android 4.2版本之前采用拦截prompt（）进行漏洞修复。 通过 WebViewClient 的shouldOverrideUrlLoading ()方法回调拦截 url 。这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。(ios主要用的是这个方式) (1)Android通过 WebViewClient 的回调方法shouldOverrideUrlLoading ()拦截 url (2)解析该 url 的协议 (3)如果检测到是预先约定好的协议，就调用相应方法 通过 WebChromeClient 的onJsAlert()、onJsConfirm()、onJsPrompt（）方法回调拦截JS对话框alert()、confirm()、prompt（） 消息 这种方式的优点：不存在方式1的漏洞；缺点：JS获取Android方法的返回值复杂。 JAVA GC原理 垃圾收集算法的核心思想是：对虚拟机可用内存空间，即堆空间中的对象进行识别，如果对象正在被引用，那么称其为存活对象 ，反之，如果对象不再被引用，则为垃圾对象，可以回收其占据的空间，用于再分配。垃圾收集算法的选择和垃圾收集系统参数的合理调节直接影响着系统性能。 27、ANR ANR全名Application Not Responding, 也就是\"应用无响应\". 当操作在一段时间内系统无法处理时, 系统层面会弹出上图那样的ANR对话框. 产生原因： (1)5s内无法响应用户输入事件(例如键盘输入, 触摸屏幕等). (2)BroadcastReceiver在10s内无法结束 (3)Service 20s内无法结束（低概率） 解决方式： (1)不要在主线程中做耗时的操作，而应放在子线程中来实现。如onCreate()和onResume()里尽可能少的去做创建操作。 (2)应用程序应该避免在BroadcastReceiver里做耗时的操作或计算。 (3)避免在Intent Receiver里启动一个Activity，因为它会创建一个新的画面，并从当前用户正在运行的程序上抢夺焦点。 (4)service是运行在主线程的，所以在service中做耗时操作，必须要放在子线程中。 21. 安卓基础知识 21.1. aidl 21.1.1. aidl的理解 见AndriodSystem_Others 21.1.2. Android中Parcelable接口： 记忆，实现了某个接口，即拥有某种能力！！！！！！----》实现了Parcelable接口，就有了打包的能力 何时使用？使用例子 是一种序列化（反）手段：其本质：将对象转换为二进制流 -----》为什么要转？： 为了传输，网络传输或者保存到本地 》TODO：不转不能完成这些？？？？怎么证明？？？ 应用场景：进程间通信IPC、网络传输、保存到本地、Activity之间？？。。。。。。TODO：补充并验证 //Book类的序列化 public class Book implements Parcelable { private String name; private int id; private String classify; protected Book(Parcel in) { name = in.readString(); classify = in.readString(); id = in.readInt(); } public Book(String classify, String name, int id) { this.name = name; this.id = id; this.classify = classify; } /** * （2）CREATOR负责反序列化过程：从Parcel中新建对象 */ public static final Creator CREATOR = new Creator() { @Override public Book createFromParcel(Parcel in) { return new Book(in); } @Override public Book[] newArray(int size) { return new Book[size]; } }; @Override public int describeContents() { return 0; } /** * （1）序列化过程 * * @param dest * @param flags */ @Override public void writeToParcel(Parcel dest, int flags) { dest.writeString(name); dest.writeString(classify); dest.writeInt(id); } @Override public String toString() { return \"name : \" + name + \"\\\"\" + \"id : \" + id + \"\\\"\" + \"classify\" + classify; } } ---》那么拥有序列化能力的book如何使用？？？？ parcel https://www.cnblogs.com/ldq2016/p/8469334.html （1）parcel读写能力： Parcel parcel= Parcel.obtain(); //写入，即是write parcel.writeString(\"111111\"); //#1 parcel.marshall(); //#2 (1)序列化过程--》没有这一步，后面read为null (2)这一步返回byte parcel.setDataPosition(0); // #3 在将数据写入之后，需要将指针手动指向到最初的位置 //#4 read String s = parcel.readString(); 为什么没有#2 #3, 步骤#4 read出来的是null？？？？？？ 《-------必须回答#123做了啥，4又具体做了啥？？ #1 parcel.writeString (2)parcel的复制 如何转的？？？ 具体的序列化原理：Parcelable的序列化需要借助Parcel 最后对Parcelable的序列化做一个总结： Parcelable的序列化需要借助Parcel。 Parcel通过JNI把序列化数据写入到进程的共享内存中，或从进程共享内存中读数据。 Parcel推荐使用Parcel.obtain()方法获取可用实例。 与Serializable相比，Parcelable避免了大量反射操作，在效率上有很大提升。 Parcelable仅仅是IPC的高效实现方案，其他场景慎用。 复杂化：Book类里面有其它对象 Parcelable与Intent或者Bundle 与Serializable对比，优劣势？ Parcelable属于安卓，Serializable是java的 Parcelable比Serializable快十倍--------》证明？？？？？ 本质原因在于：Serializable保存了整个类------》消耗极大 Parcelable只是保存了数据结构的值， 没有保存数据结构，而数据结构仍然在开发者手中（恢复时用！！！） Serializable具有可继承性，Parcelable虽然也具有，但是仍然需要完善实现，因为CREATOR是静态的。 21.1.3. 状态保存分析，待合并 序列化： (1)ActivityThread 去做的 (2)场景：activityStopped时机 （3）序列化最终去向：内存(证据：parcel底层是内存操作函数)，native侧的二进制。。。并非文件？（文件场景：开机重启后仍然能够恢复） java序列化是外部存储器，效率低（证据：？？？？） （4）序列化的场景比状态保存的场景少！！！！！！！！（activity切换时，前activity保存） （5）反序列化场景比序列化场景还要少？？？？ writeToParcel:13053, TextView$SavedState (android.widget) writeParcelable:1801, Parcel (android.os) writeValue:1707, Parcel (android.os) writeSparseArray:1085, Parcel (android.os) writeValue:1732, Parcel (android.os) writeArrayMapInternal:928, Parcel (android.os) writeToParcelInner:1584, BaseBundle (android.os) writeToParcel:1253, Bundle (android.os) writeBundle:997, Parcel (android.os) writeValue:1698, Parcel (android.os) writeArrayMapInternal:928, Parcel (android.os) writeToParcelInner:1584, BaseBundle (android.os) writeToParcel:1253, Bundle (android.os) activityStopped:4505, IActivityTaskManager$Stub$Proxy (android.app) run:145, PendingTransactionActions$StopInfo (android.app.servertransaction) handleCallback:883, Handler (android.os) dispatchMessage:100, Handler (android.os) loop:214, Looper (android.os) main:7356, ActivityThread (android.app) invoke:-1, Method (java.lang.reflect) run:492, RuntimeInit$MethodAndArgsCaller (com.android.internal.os) main:930, ZygoteInit (com.android.internal.os) trace是万能的，但是弊端：必须建立在场景你能复现！！！！！（所有动态调试的弊端）。比如状态保存好复现，但是反序列化很难复现！！！！ nameili思路： 1、网页提示 已知存在native和java -----》找流程: 1、先save流程，下发空Bundle 66，填充 ----->注意：这个接口也开给开发者了！！！！！！ Activity.onSaveInstanceState(@NonNull Bundle outState) 2、旋转之后，onCreate----->注意：这个接口开给开发者了！！！！！！(但用处是啥) Activity.onCreate(Bundle savedInstanceState) Bundle 66 ------》怎么协调这个与Ability的关系呢？ 3、Activity.onRestoreInstanceState(@NonNull Bundle savedInstanceState) ----->注意：这个接口开给开发者了！！！！！！ ----》这个Bundle 66 ------>上述问题，可以把转换代码挪到元解决（目前问题，转换问题） 目前上述所有问题，都是Activity去对接的，责任主体是元？？？？ ------->两边SE定的是元透传给安卓AcitivityTread。现在有对外接口，数据开发者能拿到，所以，必须元去转数据！！！！！！！！！！！！！ 后期挪动，现在这个需求仍然这么做，不影响我们 元目前接口有问题 -------》最后没有问题，把恢复和反序列化分开！！！！！！！！ 安卓还有接口： public void onPostCreate(@Nullable Bundle savedInstanceState) * public class Activity extends ApplicationContext { * protected void onCreate(Bundle savedInstanceState); * * protected void onStart(); * * protected void onRestart(); * * protected void onResume(); * * protected void onPause(); * * protected void onStop(); * * protected void onDestroy(); * } ----------》总揽这个事情，给一个大反思： 为什么之前没想到是元去转？？？因为之前定的是透传！！！！！ 一度把他的对外接口给忘记了！！！！！！ 关于容器Bundle的由来： // ActivityThread.java ActivityClientRecord r = mActivities.get(tmp.token); ActivityThread里维护了所有activity的记录Record，Record持有记录activity状态的Bundle 最开始，Bundle是为null的----》问题：问题在于为什么每次取到的都是null？（即使你修改了这个值） // ActivityThread.java private void callActivityOnSaveInstanceState(ActivityClientRecord r) { r.state = new Bundle(); // 这里赋值的！！！（初始化时，默认mParcelledByNative = false），时机：在Save流程最开始的时候 r.state.setAllowFds(false); if (r.isPersistable()) { r.persistentState = new PersistableBundle(); mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state, r.persistentState); } else { mInstrumentation.callActivityOnSaveInstanceState(r.activity, r.state); } } 即使初始化时修改mParcelledByNative = true-----》也无用----》序列化开关不是这里。到底是哪里？？？？？？ 关于序列化： // （1）PendingTransactionActions.java ---》调用栈见上。具体触发的消息是啥？？ ActivityTaskManager.getService().activityStopped( mActivity.token, mState, mPersistentState, mDescription); //（2） ActivityTaskManagerService.java --->到系统进程 public final void activityStopped( // 存储在ActivityRecord里：Bundle icicle; // last saved activity state -------》（1）（2）之间跨进程传输，把state跨进程传给ActivityTaskManagerService系统进程了！！！！！！！（本质）所以这是状态保存需要序列化的本质原因（证据：确实可以看到先序列化，后跨了进程）！！！！！！！！！，这是序列化的地方！！！！！！！！！ 结论：（1）mParcelledByNative------》不是序列化的原因（TODO:那这个是干啥的？？？？） （2）不同于Book的跨进程序列化传输，这里系统进程拿到了二进制，没有再反序列化出对象（实际上，系统进程也不可能反序列化出对象，因为类是在App进程里。。。而之前Book demo，是两边都有要传输的类！！！！！，可以做到反序列化！！！！） 证明：ActivityRecord的Bundle持有的是native侧的指针 addCallback:75, ClientTransaction (android.app.servertransaction) transactionWithCallback:125, ClientLifecycleManager (com.android.server.wm) scheduleTransaction:83, ClientLifecycleManager (com.android.server.wm) scheduleTopResumedActivityChanged:724, ActivityRecord (com.android.server.wm) updateTopResumedActivityIfNeeded:2318, ActivityStackSupervisor (com.android.server.wm) setResumedActivity:2610, ActivityStack (com.android.server.wm) onActivityStateChanged:555, ActivityStack (com.android.server.wm) onActivityStateChanged:1870, TaskRecord (com.android.server.wm) setState:1869, ActivityRecord (com.android.server.wm) startPausingLocked:1686, ActivityStack (com.android.server.wm) resumeTopActivityInnerLocked:2748, ActivityStack (com.android.server.wm) resumeTopActivityUncheckedLocked:2575, ActivityStack (com.android.server.wm) resumeFocusedStacksTopActivities:1158, RootActivityContainer (com.android.server.wm) startActivityUnchecked:1728, ActivityStarter (com.android.server.wm) startActivity:1394, ActivityStarter (com.android.server.wm) startActivity:933, ActivityStarter (com.android.server.wm) startActivity:583, ActivityStarter (com.android.server.wm) startActivityMayWait:1288, ActivityStarter (com.android.server.wm) execute:514, ActivityStarter (com.android.server.wm) startActivityAsUser:1058, ActivityTaskManagerService (com.android.server.wm) startActivityAsUser:1032, ActivityTaskManagerService (com.android.server.wm) startActivity:1009, ActivityTaskManagerService (com.android.server.wm) onTransact:1486, IActivityTaskManager$Stub (android.app) execTransactInternal:1021, Binder (android.os) execTransact:994, Binder (android.os) -----------》首要任务：（1）classLoader （2） 制造crash 21.1.4. 关于Binder https://carsonho.blog.csdn.net/article/details/73560642?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7EBlogCommendFromMachineLearnPai2%7Edefault-1.control 21.2. 关于线程的理解： 21.2.1. 什么是线程？ 执行的控制流 被包含在进程（进程内存共享）中 21.2.2. 什么是主线程？ 注意： 对于java，主线程指的是启动main函数的线程 ----》TODO：java的进程号，与主线程号？？？？ 对于安卓，主线程即是UI线程 ----》为什么这么说？启动的main函数线程，1、即是ActivityTread的（即UI？？？？） 2、初始化了线程号，作为后续校验UI操作的线程号？？（TODO：代码） 21.2.3. 安卓主线程是一个死循环 （在Looper.loop()里取消息时死循环）： （0）机制： App本身就运行在一个Looper里，以消息驱动。代码证明：？？？？ （1）可能会休眠!!!!!!!!!!？？？？ （2）既然是死循环，为什么没有ANR？ ANR是为安卓的四大组件设置的？？？？ 无非也就是是个线程，线程是有生命周期的，任务执行结束，或者在执行任务过程中抛了异常，线程就结束了。在 Android 中，正式由于 Looper 维护的这个死循环才能保证主线程不退出，至于为什么不会被卡死，这个说法本身就不成立，loop 方法一直循环处理任务，如果没有任务，进程会休眠。不是一直在循环。至于程序 anr，不是由于死循环，而是由于在 mainlooper 维护这个线程中，执行耗时任务，在规定时间内没有完成，才触发了 Android 系统的 anr 机制！这个跟这个死循环没有任何关系 （3）既然是死循环，又如何退出主线程？---->TODO：线程的生命周期 （4）UI线程的死循环，会进入休眠嘛？ 22. 输入法 见InputMethod 23. 安卓逆向 目的： 1、有时候，不能确定环境中的jar、apk是否含自己的修改(非常重要) ----------> 从手机环境中pull出来jar或者apk，反编译看代码 2、看别人的实现方式 工具一：jadx https://juejin.cn/post/7168086915445424136 范围： APK，AAR，JAR，DEX，AAB，ZIP -------> Java 类 APK，AAR，AAB，ZIP 中的资源 (根本原因：在于资源不可能混淆，系统要识别的) 工具二： apktool + dex2jar + jd-gui 组合： https://juejin.cn/post/7158107697907236878 难点：混淆 参考： https://juejin.cn/post/7168086915445424136 https://www.youtube.com/watch?v=aEEYM0QbnO4&list=PLwIrqQCQ5pQlBNwwf9afQNNUChwdYPVLr 视频教程 24. 计算机基础 24.1. 操作系统之进程管理 TODO: https://mp.weixin.qq.com/s/OCtpPLoBUyVBw2wUlEj1Kw 只有三种状态： 25. 性能专题 见AndriodSystem_Others 25.1. 其他 网络性能优化、APK 大小优化、App 耗电 https://www.androidperformance.com/ https://androidperformance.com/2018/05/07/Android-performance-optimization-skills-and-tools/ 极好的文章 26. 面试 安卓系统最新面试题 ------》问题永远是第一位重要的 https://blog.csdn.net/kai_zone/article/details/81117644 26.1. 项目相关问题： 华为IDP流程里，你担任什么角色？遇到需求交不了，你是怎么解决的 26.1.1. 开发 开发中遇到哪些问题，你是怎么解决的 26.1.2. 软件经理 软件经理，项目管理方面能力 ：需求管理方面的能力 ----> 技术leader角色 华为的项目线和人力线是两条线：软件经理是项目线角色 所做的事情 组织开发交付，细化并规范化交付流程。定时推动项目进展。 和各个部门协商开发人员，以及开发周期。-----> 针对于要求时间过多的？1、让他们解释为什么要这么多时间，代码量评估多少、验证用例多少 2、对于模块开发，固定的，以往开发时间多少 3、技巧： 让他们都报多一些，越多越好，激化矛盾 ，然后拉各地主管，狠狠批斗 技巧：和硬件沟通时间，都会给软件预留一定时间 遇到需求交不了，你是怎么解决的： 1、首先确保不会有延期的情况出现。需求的开发过程中，先按功能模块划分待开发代码，评估工作量。按照各功能模块给出计划、以及联调时间计划、转测试时间等。设计桌面也有进度，让他们自己更新，所有人都能看到 对于重要的项目，每天会议跟踪计划，发日报周报进展 2、万一有延期的风险。比如，SE、MDE前期分析不到位等，通过每天会议及时发现风险，知会人力PL。 要根据风险点，到底是技术难题，还是验证量过大，让PL协调投入技术专家，还是其他普通开发。让他们手中不是那么急的任务优先级放低 7*24小时 3、等项目风险释放开发后，AAR回溯问题。回溯不针对人，而是针对问题，改进措施。完善checkList 遇到很多领域都没完成的 比如，排查问题、自验证版本。 ------> 发邮件通报前三。一直通报前三 对某一个项目中遇到的问题，举一反三 通知其他项目 说的很顺畅，流程很顺畅 26.2. 面试技术问题 26.2.1. 帧数据的流转 surface对应一个buffer，那么APP进程的Buffer，如何流转到 surfaceFlinger？ ----->TODO: 这实际上涉及到两个进程了！！！？ 用到了surfaceQueue？，类似于MesseageQueue 26.2.2. 需要补充的知识点： linux相关： 内存知识、pss、rss、uss kernel相关： 安卓相关： AMS、WMS、显示相关、PMS 26.3. 一些好的点 商泰面试答复： 您好，不好意思，这两天公司阳太多人了，一直在处理问题，上次面试的确和我们招聘的需求有点差距，对于上层关联的一些系统源码有阅读和自己的理解，个人的算法意识不错，Android系统框架层深入学习研究的经验可能会欠缺一些，所以还是比较抱歉了 ------> 个人的算法意识不错: 这个是由于，回答算法题之前先说了异常边界情况（优） ------> Android系统框架层深入学习研究的经验可能会欠缺一些： 应该值得是WMS、AMS那块 26.4. 问面试官的问题 1、让面试官介绍自己的业务 2、 看源码，如何更深刻的理解呢 26.5. 谈薪资 参考视频： 产品老曾 面试谈薪资，这个东西也变成套路了啊，就跟演电影一样，你就照着一个方式演一遍就可以了: HR:哎呀，我们家这个晋级大概就这个级别，然后在这个级别下我们已经聊了，可能按照这个薪酬的标准啊。我们大概给你的薪酬是这样，你看要不然你无法接了吧， 我：然后你就说我还挺喜欢你们公司对我的认可。然后呢我也相信你们帮我去争取过，但是呢确实因为原来的公司是这样，如果是只给我涨这么点的。吸引力可能没有那么大 HR: 未来未来还有奖金呢，是吧？我们还有福利，是不是啊？你就接了吧，这是一个话术，对吧？ 我：然后你就说我觉得你对我也挺好的，我们俩这个经历这么长时间我的面试过程，对吧？同学其实对我的支持和帮助这些。这样的话我才能拿到这个，最后能跟你们谈这个，但是呢因为现在呢还是有其他的一些公司在正在跟我接触， 而且有一些公司他们开的这个薪酬确实比你们这边给的我还是高比较多，当然了，我倒不是说只是说因为钱我就非要去他们那儿，是说我是觉得这个第一呢，这个能证明这个我自己在市场上的一个价值。第二个呢我也是因为很想去你们公司，所以我才跟你们聊这个事情。 我们俩反正比较直接坦白的讲。就是您这边也帮我挺多的，你就在帮帮我跟公司再争取争， HR: 然后这个hr同学就是说这个还是挺为难的，因为我们公司没有这个先例啊，这个一般就定完了以后，其实我也没有办法再去改变，如果你不接的话，你现在外面有一些公司在跟你接触吗？他们开多少呢？ 我：你就说啊，巴拉巴拉稍微高一点的。然后你说他们开的确实也比较有吸引力，但是我还是很想加入你们公司，因为我们我还挺喜欢跟你们交流的，就不要跟让他变成你的敌对去了啊，注意就是不要让他变成说你们在干嘛呢？不要说这些东西，你说你跟我是一边的。 一直在说这个东西啊，就是说还是希望你能尽力帮我争取一下来回拉扯，现在都是这样，你就照这个来就好了，反正大家都心知肚明，就是肯定要拉扯一两个，你知道这个东西我跟你讲一线的hr的，它确实权限比较小，所以呢如果你的那个薪酬你感觉不满意。 他最多最多能够在他自己权利范围内给你加10%，他看你薪酬的话，比如说假设你原来薪酬是1万多2万，然后他给你加个什么一两千，那就算是他的权限范围超过这个范围，比如说你说我要个30场数。50涨幅，这是一定要向上面的HR的那个老大去申报了， 而那个人在想的就是成本问题，成本性价比，业务那边是不是对你非常认可，那你就有机会，但是有机会你就要还是要跟他讲好话，然后让他愿意去帮你去做这个申请，因为他申请很艰难，他是要跟他老板打报告的 。你不要以为说反正你们就压我这，反正我无所谓，就你自己解决去，那你其实就没有帮别人提供一个理由来帮你加薪，你明白了这个东西以后你就要知道说你要给这个跟你聊天的这个圈儿一个合适的理由让他去。 是的，比如说你在外面有一些其他公司在竞争力这是一种，对吧，还有就是我其实对于我们公司做的这个事儿比较了解，我比较胜任，而且业务对我很认可，这也是一种就是这些东西都是可以给你加成你的性价比， 你注意啊，最终公司给不给你家选不选你这是性价比问题，所以他压薪资他一定会压，你一定会争取大家就拉手拉手就跟你在那个菜市场买菜一样的。这个青菜多少钱啊？青菜一块便宜点呗，哎呀，便宜不了，便宜不了，小本生意，便宜不便宜，我拿两把呢，你在送我点算。 哎呀，这个赔不了，就说那这样吧，你拿三把给我三块，然后我再给你两块算，好吧？哎呀。都是牢固主了，对不对？给我便宜点嘛，一般菜市场聊天就这样，大家都是惯例，所以你也按惯例来就行。 最后聊完就是有理有据，把这个圈拉在你自己这一边，请他去帮你去申请给他申请的理由，然后最后你跟他讲你说不申请的结果如何？注意这句话啊， 不管你帮我申请的结果如何，我都一定会感激你的， 他的感受就是说你其实比较认可他的工作 但是你不太认可公司的那个决定，我知道你很为难。我也知道是公司决定，你其实是愿意帮我加，但是公司不愿意我加，但是我还是给了你一些理由。让你帮我再争取一下，不管你争取的成功不成功，我都会感激你，我感激你，我也不一定来，听懂了吗？ 然后这个圈呢就明白了，他自己会酌情，如果你要求是第一，他可能就回去过来跟你说。他说我就申请了，好不容易再给你加个1000多，那接了吧，如果你还要求更高，你说我要加5000才行，他接受不了，他回去打报告，要不然我们跟业务聊一下吧，这个是不是他们非常喜欢这个东西， 然后呢因为现在这个新城已经超出我们的工资帽了，但是这个同学呢好像确实还不错，然后他在外面。有几家其他公司在挖他，他说那挖多少钱给他高个五六千，你说啊进队里面给这么高吗？那我们再看看其他候选人，哎，其他会员有些人没来，那这个东西好像还是确实还不错， 我们要不然这样我们给他加3000。他又没来好吧，他如果愿意，我就交了。不愿意那就算了，我们在面对的人，他们一般就这样聊完了，聊完了以后回来跟你聊，说那个我们好不容易争取了一下业务，那边呢跟我讲就是说有时候我们为了招一些比较不错的人， 我们还是稍微的可以再增加一点这个额度，但是这已经是最多了，如果你再不接的话，其实我们也没办法。大概就先加个3000左右，你看这个ok，那你自己决定吧，你要接就接，不接就算了，因为这个手摆的就是还是为什么不加5000，就是你的性价比还是不够。 所以很多时候你要把这个所谓的人家压价这个东西归因于我自己的说服人家的那个能力，或者面试的整个过程中表现的状态不够强，还有就是有些东西不在你的控制范围内，就是假设现在有很多候选人。都可以胜任这个岗位，然后背景不是背景设置，是吧？ 卷在一起了，你在这里你非要跟别人说我不行，我非要3%涨，不然你你随便，爱去哪去哪。所以你要对市场本身要有一个概念，我们讲压价这个事情，说你不要说因为你对我要求的那个钱不满意，就认为你是加价，而是说我尊重一下市场的一个基本情况好不好？ 这个怎么去谈的？艺术已经全给你了啊。那你就会发生什么我都告诉你了 27. 参考文章 https://blog.csdn.net/carson_ho/article/details/73560642 Carson带你学Android http://gityuan.com/2016/04/24/how-to-study-android/ https://jsonchao.github.io/ https://www.androidperformance.com/2021/04/24/android-systrace-smooth-in-action-1/#/%E4%BA%86%E8%A7%A3%E5%8D%A1%E9%A1%BF%E5%8E%9F%E7%90%86 性能方面的博主 28. Android开发常用网站 28.1. Android 相关 Android 开发官网：https://developer.android.google.cn/ Android源码在线查看：https://www.androidos.net.cn/sourcecode Android源码在线查看：http://androidxref.com/ Material Design：https://www.mdui.org/design/|https://material.io/components Material Design github：https://github.com/material-components Android 开发者动画：https://github.com/android/animation-samples Android 开发者ndk：https://github.com/android/ndk-samples OpenGL学习官网：https://learnopengl-cn.readthedocs.io/zh/latest/intro/ 官网镜像：https://developers.google.cn/android/images Kotlin:https://kotlinlang.org/api/latest/jvm/stdlib/ 鸿蒙系统源码：https://codechina.csdn.net/openharmony 鸿蒙开源系统入门：https://blog.csdn.net/qq_33487044/article/details/108560890 Flutter https://flutterchina.club/ springboot:https://github.com/liaozihong/SpringBoot-Learning 图标https://www.iconfont.cn/ protobuf:https://www.tizi365.com/archives/367.html https://www.jianshu.com/p/d4dfe258e796 https://developers.google.cn/protocol-buffers/docs/javatutorial SVG地图下载 https://www.amcharts.com/demos/ Gradle https://services.gradle.org/distributions/ 贝塞尔曲线在线 https://cubic-bezier.com/#.17,.67,.83,.67 29. 格式 # 自动刷入 -w双清 : 29.1. 使用逻辑： 跳转使用逻辑 29.2. 标记 IME switching Following APIs are not supported InputMethodManager#showInputMethodPicker() InputMethodManager#showInputMethodAndSubtypeEnabler() 29.3. 隐藏 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/ANR_crash.html":{"url":"coding/Andriod/ANR_crash.html","title":"ANR Crash","keywords":"","body":"1. 目录2. ANR3. crashTreeviewCopyright © aleen42 all right reserved, powered by aleen42 ANR crash 1. 目录 [TOC] 2. ANR ANR 问题 参考： ANR问题的产生机制.pdf 3. crash console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/APK_64bit_32bit.html":{"url":"coding/Andriod/APK_64bit_32bit.html","title":"APK 64 Bit 32 Bit","keywords":"","body":"1. APK的运行环境谁决定了或如何让你的app运行在64bit或32bit的运行环境1.1. 几个结论：1.2. 决定APK运行在32bit还是64bit环境下的规则1.3. 强制APK底层调用bit32库TreeviewCopyright © aleen42 all right reserved, powered by aleen42 几个结论： 决定APK运行在32bit还是64bit环境下的规则 强制APK底层调用bit32库 1. APK的运行环境谁决定了或如何让你的app运行在64bit或32bit的运行环境 1.1. 几个结论： 1、mediaserver进程只有32bit 2、32Bit进程和64bit进程间跟其他进程一样通过binder进行通信 3、app 默认运行在64bit环境（可以强制改成32bit，见后），包括：meidaplayer app 1.2. 决定APK运行在32bit还是64bit环境下的规则 https://segmentfault.com/a/1190000014161183 64bit与32bit交互，通过Binder zygote进程的建立是真正的Android运行空间 1.3. 强制APK底层调用bit32库 见 HowToReadCode.md 《断点调试环境 lib64 、lib 区分》 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/DesignPattern.html":{"url":"coding/Andriod/DesignPattern.html","title":"Design Pattern","keywords":"","body":"1. 目录2. 0层3. 面向对象设计的 目标：4. 总体目标：高内聚，低耦合5. 六大 设计基本原则：5.1. 单一职责原则SRP：5.2. 开放封闭原则OCP：5.3. 里氏替换原则LSP：5.4. 依赖倒置原则5.4.1. 安卓例子 drawable5.5. 接口隔离原则5.6. 迪米特法则5.6.1. 符合迪米特法则的设计模式 TODO：6. 设计模式6.1. 创建型模式6.1.1. 单例模式 TODO6.1.2. 简单工厂模式6.1.3. （普通）工厂模式6.1.4. 抽象工厂模式6.1.5. ------比较 简单、普通、抽象工厂模式-----6.1.6. 建造者模式（生成器模式）---重点6.1.7. 原型模式 TODO6.2. 结构型模式6.2.1. 代理模式6.2.2. 适配器模式6.2.3. 装饰器模式 TODO6.2.4. 组合模式6.2.5. 桥接模式6.2.6. 享元模式6.2.7. 外观（门面）模式 TODO6.3. 行为型模式6.3.1. 责任链模式6.3.2. 中介者模式6.3.3. 观察者模式 TODO6.3.4. 迭代器模式6.3.5. 状态模式6.3.6. 策略模式6.3.7. 模板方法模式TODO6.3.8. 例子：6.3.9. 命令模式 TODO6.3.10. 访问者模式 TODO6.3.11. 备忘录模式--->状态保存6.4. 其他设计模式6.4.1. 生产者-消费者模式7. 其他设计思想：7.1. SetLinsterner与set(this)区别：7.2. 分层设计思想8. 背后的背后：思考设计模式的维度9. 软件总结10. 视频教程 & 参考链接11. uml11.1.1. 分两类：静态图、动态图11.1.2. 关系表达11.1.3. 类的表达11.1.4. 接口的表达TreeviewCopyright © aleen42 all right reserved, powered by aleen42 0层 面向对象设计的 目标： 总体目标：高内聚，低耦合 六大 设计基本原则： 单一职责原则SRP： 开放封闭原则OCP： 里氏替换原则LSP： 依赖倒置原则 安卓例子 drawable 接口隔离原则 迪米特法则 符合迪米特法则的设计模式 TODO： 设计模式 创建型模式 单例模式 TODO 懒汉式 饿汉式 双重检锁(推荐) 静态内部类实现单例模式(非常推荐) 安卓代码中的单例模式 参考： 简单工厂模式 与建造者模式的区别 采用反射机制，可以解决开闭原则？TODO java中的例子TODO 简单工厂问题/特征： 一个具体工厂，生产多个具体产品 （普通）工厂模式 jdk中的应用： 普通工厂问题/特征： 一个具体工厂，生产一个具体产品 安卓工厂模式的应用: 抽象工厂模式 安卓中的例子： TODO 普通工厂特征： 一个具体工厂，生产一个具体产品 ------比较 简单、普通、抽象工厂模式----- 建造者模式（生成器模式）---重点 关于builder的线程安全 TODO 与工厂模式的区别: 安卓建造模式的应用1：从JDK的StringBuilder 安卓建造模式的应用2：AlertDialog 原型模式 TODO 结构型模式 代理模式 安卓代码的例子 适配器模式 安卓代码的例子 装饰器模式 TODO 组合模式 桥接模式 代码中的列子 享元模式 安卓中的享元模式的例子： 享元模式之 安卓 msg 安卓检测工具：profiler检测内存抖动 外观（门面）模式 TODO 行为型模式 责任链模式 安卓代码中的 责任链模式： 中介者模式 安卓例子： TODO: 观察者模式 TODO 迭代器模式 java 的例子 状态模式 安卓例子 TODO 策略模式 与状态模式的不同： 安卓代码的例子 TODO 模板方法模式TODO 例子： 例子： 命令模式 TODO 访问者模式 TODO 备忘录模式--->状态保存 其他设计模式 生产者-消费者模式 代码例子： 面试问题： 其他设计思想： SetLinsterner与set(this)区别： 分层设计思想 背后的背后：思考设计模式的维度 软件总结 视频教程 & 参考链接 uml 分两类：静态图、动态图 关系表达 接口的实现： 两种表达 依赖关系： 关联： 聚合 组合 类的表达 接口的表达 1. 目录 [TOC] 2. 0层 参考： https://www.youtube.com/playlist?list=PLGmd9-PCMLhb16ZxeSy00qUsBazXgJyfM GoF（Gang of Four），中文名——四人组 注意： 很多原则核心都是抽取共同的！！！！ 抽象：面向对象的六大原则 ----> 具体应用：设计模式 关于分类，为啥设计模式是三类，记忆： 关于设计模式的三种类型，其实就是说的建筑： 建筑零部件（创建型模式）、链接节点（行为型模式）、最终结构（结构型模式）————》自然，必然如此，面向对象 3. 面向对象设计的 目标： 1、 可扩展性 ：容易添加新的功能 2、灵活性 ：修改一个接口，不影响另一个接口的功能 注意：整个设计模式/设计原则的出发点都是可扩展性，即日后方便修改 也就是说，如果 日后不需要演进（修改、新增、删减），那么就不需要 设计模式/设计原则了 时刻提醒自己，从演进的角度看代码 4. 总体目标：高内聚，低耦合 对象的要求！！！！！！ 5. 六大 设计基本原则： 由目标产生了具体的 原则： 记忆： 5.1. 单一职责原则SRP： 例子： CustomerChart既查找数据库，又显示图表displayChart() => 问题：当数据库发生变化时，需要修改find方法= 用的哪个数据库 ，本来跟图表是没有任何关系的！！！！！ 一句话 ：find不是图表的方法，图表只关心数据及数据的展示！！！！！！ 抽取出find方法 抽取后：---->职责更单一 5.2. 开放封闭原则OCP： 对扩展开放，对修改封闭 例子： 如果每 新增一种char， 需要修改manager和新chart两处的代码！！！！！------> 扩展时，修改了原有代码，违反了开闭原则 方法： 抽取displayer方法到基类，manager.display() 方法入参为基类！！！ uml图： 扩展遇到的问题：现在要增加一个PieChart，自然要修改 Manager(增加依赖) 解决问题的方法： 抽取display作为 基类： 上述uml的生活化模型： 墙里电线（manager）如果直接依赖于 各种电器（各种chart），一但新增或者删除，必然影响到墙里电线（manager与chart之间的依赖）。 解决办法： 在两者之间加上一个无限大的 插座（抽象接口 BaseChart）。 需要新增电器就直接插入就好，不需要改动任何东西。 这就是把依赖于 具体对象 改成依赖于接口的好处 新增一个类时，原来所有代码不需要动！！！ 开放封闭，一句话总结： 从uml角度：依赖于多个具体 ------》 变为 依赖于 多个具体的抽象基类（扩展时，基类就可不修改）。扩展没有修改的本质原因：依赖于抽象基类 从代码形式角度： 向上提取公因式（公因函数）----> 向上提取为抽象基类 这也就是，java代码有那么多抽象基类的原因。 TODO: 一个类的 不同函数中相同部分，也可以提取公因式 5.3. 里氏替换原则LSP： 好的参考： https://blog.csdn.net/Weixiaohuai/article/details/102510273 一句 总结： 里氏替换原则，子类可以替换父类，程序不会发生行为的变化 （自然，推论：满足里氏原则，子类之间也可以替换） 一句话，本质： 里氏替换原则 希望父子之间 只有复用，没有覆写（自然，覆写抽象方法除外） 从代码运行角度：希望运行的永远是父类的代码，这样，就不存在 子类互换风险。 基于本质，我们的做法是： 1、子类中可以增加自己特有的方法，不覆写 2、如果子类实在要覆写 就把要覆写的函数提出为抽象基类（基类抽象方法）（自然，原先父子公共方法也提取至抽象基类） 原先父子都继承这个抽象基类 -----> 即：父子关系 转变为 兄弟关系。。。。强行不覆写 从代码形式上来看： 就是将 覆写的方法，提取成为 抽象基类 -----> 提取公因式 成为抽象基类 （所以，java抽象基类多） 提取公因式角度：一句话总结开放封闭原则与里氏替换原则： 都是提取公因式，形成新的抽象基类 uml角度：EX1 子类一定要父类方法 参见： https://blog.csdn.net/Weixiaohuai/article/details/102510273 需要新增一个ClassA 的子类，而且 ClassB就是一定要有自己的compare，所以会覆写 -----》 提取公因式，孩子变兄弟 uml角度：EX2 子类一定不要父类方法（有时候就见到，子类覆写抛异常，不让调用的情况） 见：https://www.youtube.com/watch?v=DWkggQoxFeI&list=PLGmd9-PCMLhb16ZxeSy00qUsBazXgJyfM&index=6 需要新增一个玩具枪ToyGun 的子类，所以一定不要父类shoot杀人的功能 做法：提取公因式，没得提？？？？ 里氏替换原则的一些推论：https://blog.csdn.net/Weixiaohuai/article/details/102510273 尽量不要从可实例化的父类中继承，而是要使用基于抽象类和接口的继承(也就是面向接口和抽象编程)。 5.4. 依赖倒置原则 官方表述： 本质：依赖于抽象 ----》 非常非常基础的原则 例子：一开始将代码写成 妈妈看书 一旦日后演进，妈妈看 报纸。所要做的操作： 1、新增 报纸类 2、修改妈妈对报纸的依赖 ------》 这个修改可以避免掉 通过依赖抽象： 这种设计，后面 新增 妈妈看杂志 。只需要新增杂志类 继承于IReader即可 5.4.1. 安卓例子 drawable 5.5. 接口隔离原则 官方表述： 关注点： 依赖最小的接口 例子：找美女和模特模型 找美女： 后面，找模特，自然不需要 上面 IPrettyGirl 这么复杂的接口 --------》 抽取 IPrettyGirl 中接口，分成两个接口（接口隔离） 记忆： 接口隔离原则即拆分接口 新增一个类，依赖接口的一部分方法。。。。这个时候，根据最小依赖原则，拆分接口 注意： 很多设计原则，都是最小化思想 5.6. 迪米特法则 英文： Law of Demeter 官方表述： 关注点： 即是最少 依赖 原则： 1、从某个类的角度来看，依赖其他类的个数最少。访问其他类的方法也尽量少。 生活化模型， 迪米特吃汉堡包模型： lucy 吃汉堡包，如果自己做，那么依赖 汉堡包，牛肉，vegetable，面包........... 从lucy的角度来看： 这个依赖的类 相当多，造成结构关系复杂 证明过程，自然：依照迪米特法则-------》 减少依赖类的个数 ----》 实际上就是减少Lucy的功能，不做汉堡包了（交给其他人做），自己专心吃 ​ -----》 只吃 总结： 1、剥离一部分功能出来（做），形成新的类。可以将原本的依赖个数减少 ​ 代价：新增了类 2、迪米特法则，可以看到也符合单一职责原则 3、如果没有要新增Lily，其实只有Lucy，多依赖没有太大关系 ---------从修改角度 4、生活中，也许Lucy要吃 汉堡包 必须自己做 ------》 但是这是代码，一定可以 抽象出其他人来做的 自然，优缺点： 优点 类间解耦, 弱耦合, 耦合降低, 复用率提高; 缺点 类间的耦合性太低, 会产生大量的中转或跳转类, 会导致系统的复杂性提高, 加大维护难度; 5.6.1. 符合迪米特法则的设计模式 TODO： 6. 设计模式 6.1. 创建型模式 6.1.1. 单例模式 TODO 英文：Singleton Pattern 官方表述： 一个类只有一个实例 自然，不得不， 1、外部各个地方私自构造 问题 --------> 将造方向私有化 2、有个静态方法，实例化 3、线程安全问题 ----->加锁 安卓中的例子： 在Android系统中，我们经常会通过Context获取系统级别的服务，如WindowsManagerService、ActivityManagerService等， 这些服务会在合适的时候以单例的形式注册在系统中，在我们需要的时候就通过Context的getSystemService(String name)获取。 ------> 所以 Context 相当于一个 大管家 优点（依附于 例子）： (1) 内存空间角度：由于单例模式在内存中只有一个实例，减少内存开支，特别是一个对象需要频繁地创建销毁时，而且创建或销毁时性能又无法优化,单例模式就非常明显了 (2) 内存时间角度：由于单例模式只生成一个实例，所以，减少系统的性能开销，当一个对象产生需要比较多的资源时，如读取配置，产生其他依赖对象时，则可以通过在应用启动时直接产生一个单例对象，然后永久驻留内存的方式来解决。 (3) 单例模式可以避免对资源的多重占用，例如一个写文件操作，由于只有一个实例存在内存中，避免对同一个资源文件的同时写操作 (4)代码角度： 单例模式可以在系统设置全局的访问点，优化和共享资源访问，例如，可以设计一个单例类，负责所有数据表的映射处理。 ​ 使用对象的好处 缺点： (1) 单例模式没有抽象层，扩展很困难，若要扩展，除了修改代码基本上没有第二种途径可以实现。 (2) 单例类的职责过重，在一定程度上违背了“单一职责原则”。 (3) 滥用单例将带来一些负面问题，如：为了节省资源将数据库连接池对象设计为的单例类，可能会导致共享连接池对象的程序过多而出现连接池溢出； 又比如：在多个线程中操作单例类的成员时，但单例中并没有对该成员进行线程互斥处理。 （4）对于安卓，单例对象如果持有 Context，容易造成内存泄漏（） 懒汉式 饿汉式 双重检锁(推荐) 静态内部类实现单例模式(非常推荐) 安卓代码中的单例模式 很多manager 只需要一个实例， 比如 1、安卓的 ResourcesManager // public static ResourcesManager getInstance() { synchronized (ResourcesManager.class) { if (sResourcesManager == null) { sResourcesManager = new ResourcesManager(); } return sResourcesManager; } } 2、注意：java侧的 serviceManager 不是 ----> 工具类 ​ native侧的 serviceManager 是单例！！ 参考： https://blog.csdn.net/qq_36639105/article/details/126745002 6.1.2. 简单工厂模式 简单工厂模式： 可以根据参数的不同（一个参数）返回不同的实例 专门创建一个类来创建其他类的实例 被创建的实例通常具有共同的父类 生活化模型： 具体工厂：手机工厂 具体产品：HW手机、苹果手机 简单工厂中的角色: 1、抽象产品类 2、产品子类 3、 工厂类 uml： // 抽象产品 abstract class Product{ public void use() { } } // 具体产品A class ProductA extends Product { public void use(){ System.out.println(\"使用了产品A\"); } } // 具体产品B class ProductB extends Product { public void use(){ System.out.println(\"使用了产品B\"); } } class Factory{ // 工厂 ​ public static Product createProduct(String type){ ​ if (type.equals(\"A\")){ ​ return new ProductA(); ​ }else if (type.equals(\"B\")) { ​ return new ProductB(); ​ } ​ return new ProductA(); ​ } } 优点，对比new的形式： （或者说要解决的问题：） 1、把对象的创建交给工厂，客户端不用关注 ---> 建造与使用分离，实现解耦 注意：与建造者模式的区别在于： 工厂模式，客户端只会指定某一个Product，比如 \"A\" ；而 建造者模式，会传入很多参数 缺点：（即是后面要改进的） 基于生活化模型，可见，站在工厂的角度，如果新增小米手机，要修改工厂的代码，违背了开闭原则 自然，工厂模式适用的一些场景(对比直接New): 1、对象的创建过程/实例化准备工作很复杂,需要初始化很多参数、查询数据库等。 ---------》 每次new的时候，创建会用很多行；工厂模式将 创建的复杂代码封装进工厂对象里 2、类本身有好多子类,这些类的创建过程在业务中容易发生改变,或者对类的调用容易发生改变。 从代码形式上，相比于new，其本质： 就是将new的复杂代码，封装 与建造者模式的区别 采用反射机制，可以解决开闭原则？TODO java中的例子TODO 简单工厂问题/特征： 一个具体工厂，生产多个具体产品 所以，新增产品时，违背开闭原则 6.1.3. （普通）工厂模式 英文： Factory pattern 基于简单工厂模式，为什么要有普通工厂模式？ 因为前文提到 前者违背了开闭原则。修改方法：将工厂内部的修改，用继承的方式下沉到子类里：-------》 （注意：这似乎是一个 通用规则：利用 继承方式体现差异化，同时满足开闭原则） 1、自然，下沉后，工厂变抽象工厂（客户依赖抽象的工厂） 2、自然，下沉后，实例化由 工厂子类完成。 从uml，本质： 抽象的工厂生产 抽象的产品；具体的工厂 生产对应的具体的 产品 ----》 记忆，本质： 抽象生产抽象，具体生产具体 客户端用 FactoryA 生产 ProductA 生活化模型： 抽象工厂：手机工厂 具体工厂：HW手机工厂、苹果手机工厂 具体产品：HW手机、苹果手机 基于生活化模型， 优点(比简单工厂模式): 1、符合开闭原则。即需要增加生产小米手机，只需要在新增一个小米手机具体工厂 缺点： 1、太过浪费，一个工厂只能生产一个产品，即 生产手机，就不能生产平板 从代码形式上，相比于 简单工厂，其本质： 一个具体工厂，生产一个具体产品 jdk中的应用： 抽象的工厂Collection生产 抽象的产品Iterator；具体的工厂ArrayList 生产对应的具体的 产品Itr public interface Collection extends Iterable { Iterator iterator(); // 抽象Collection生产抽象Iterator boolean add(E var1); boolean remove(Object var1); } 普通工厂问题/特征： 一个具体工厂，生产一个具体产品 矫枉过正，一个工厂只能生产一个产品 安卓工厂模式的应用: 有什参考： https://blog.csdn.net/weixin_35092037/article/details/117346981 抽象的Activity生产抽象的view。具体的MainActivity生产具体的ViewGroup。 ----》 工厂方法是onCreate 6.1.4. 抽象工厂模式 英文： Abstract Factory Pattern 要解决的问题： 普通工厂模式： 抽象生产抽象，具体生产具体 -------》 那还有什么问题呢？ 原因在于 具体的 FactoryA只能 生产 ProductA ​ 一个产品对应一个具体工厂是很浪费的。比如生产 手机和平板， 是可以在同一个具体工厂内完成（复用相同功能的代码） 优点，相比于普通工厂模式：参考https://www.cnblogs.com/it-deepinmind/p/13283562.html1、 相似的 一类产品族，可以放到一个具体工厂中生产 记忆： 即一个工厂，有多个流水线 缺点： 1、违背了开闭原则：新增产品，抽象工厂和具体工厂（即所有工厂类）都新增了 创建新产品的方法 注意： 如果一个具体工厂，生产的两个产品之间不相似（没有代码复用的可能），比如 生产手机和生产口罩 ----》 应该拆成两个工厂，即使用普通工厂模式 安卓中的例子： TODO 普通工厂特征： 一个具体工厂，生产一个具体产品 介于简单和普通之间，一个工厂能生产相似的一类产品 6.1.5. ------比较 简单、普通、抽象工厂模式----- 参考视频： https://www.bilibili.com/video/BV1524y1y79F/?spm_id_from=333.337.search-card.all.click 6.1.6. 建造者模式（生成器模式）---重点 参考链接： https://blog.csdn.net/nugongahou110/article/details/50395698 ---》 好文：一步一步解释了为啥用建造者模式 https://blog.csdn.net/u011814346/article/details/70312214?spm=1001.2101.3001.6650.15&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-70312214-blog-119713865.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-15-70312214-blog-119713865.pc_relevant_default&utm_relevant_index=18 要解决的问题，直接new的问题： 构造函数 把 表达 与 构造绑死了，造成表达不灵活 解释见下 一句话，记忆： 建造者模式解决的就是表达灵活性问题 英文： Builder Pattern 官方表述： 生活化模型： 建造一台电脑：装机人员Builder根据 用户 Client 需求进行沟通。装机人员将电脑的主机划分成各个部件：CPU（必选）、内存（必选）、硬盘（必选）、音响（可选）、鼠标（可选）、鼠标垫（可选） 根据用户的指定各种参数setXXX，装机人员 一把组建build电脑。（再找装机人换内存，不会鸟你了） 建构与表示分离： https://blog.csdn.net/langfeiyes/article/details/124142430 TODO 表示：即用户指定的 CPU（i7）、内存（DDR4 48g）、硬盘500G、音响一个、鼠标一个、鼠标垫不选 即set 构建：装机人员帮忙装机，组装成一台电脑，即build 分离：可见这是两个部分嗯，隔离了： 1、表示set多少个属性，与构建过程完全没有关系。 即： 这样使得同样的构建过程 可以 创建出不同的表现。 2、为什么要隔离？变与不变的相隔离，自然：隔离左边是 剧烈变化的，右边是稳定不变的 直接new 对象 的问题： 做不到 构建与表达 隔离： // https://blog.csdn.net/nugongahou110/article/details/50395698 public class Student { private final int stuId;//必须 private final String name;//必须 private final int age;//可选 private final int gender;//可选 private final int address;//可选 ...//还有很多可选属性 public Student(int stuId,String name){ //【1】 this(stuId,name,0,1,\"\"); } public Student(int stuId,String name,int age){ // 【2】 this(stuId,name,age,1,\"\"); } public Student(int stuId,String name,int age,int gender){ this(stuId,name,age,gender,\"\"); } public Student(int stuId,String name,int age,int gender,String address){ this.stuId = stuId; this.name = name; this.age = age; this.gender = gender; this.address = address; } } 所有的构造方法，都将 表达（参数）与 构造 绑定了，比如【1】要求表达一定有 stuId 和 name 所以new的构造方式问题在于： 表达不灵活了，都被构造函数的参数限定死了 为了表达的灵活性，表示出可选与必选： 【1】表达了必选的含义 【2】表达了age可选的含义，，，但是四个构造函数 远远不够， 应该需要 2的3次方个构造函数 ---》 太多了 这里也说明了：当参数不多的时候，可以用不同构造方法表达灵活性。---》 过多时，只能用builder 适用场景: 其建造的东西, 是由多个东西组合而成(显示上就是多个参数)-----》主要如何组合是由外界决定(工厂模式, 如何组合不是由外界决定?) UML: 代码特征： 建造者模式的格式如下: ·目标类的构造方法要求传入Builder对象 //【】 自然，目标类的构造函数应该是private， 不给外面用。 ·Builder建造者类位于目标类内部且用static描述 ·Builder建造者对象提供内置属性与各种set方法,注意set方法返回Builder对象本身 ·Builder建造者类提供build()方法实现目标类对象的创建 //【】 使用： // 在客户端代码中: new Builder().setA(\"a\") // partA .setB(\"b\") // partB .setC(\"c\") ....... .build() 1、通过把参数一个个set 给builder，然后统一一次 build。 2、Set方法 return this 从生活模型中(从代码可以看出)，build一把做的。 自然：之后再 set 是无效的（再找装机人换内存，不鸟你了。只有build才真正有效），只给了builder，保护了 “不可变对象”的密封性 基于生活化模型优缺点： https://blog.csdn.net/a734474820/article/details/128386628?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-128386628-blog-119713865.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-2-128386628-blog-119713865.pc_relevant_default&utm_relevant_index=5 优点： 1、良好的封装性，使用建造者模式可以使客户端不必知道产品内部组成的细节； 2、变与不变相隔离。变的部分，有很好的灵活性 2、易于拓展：增加新的具体创建者无需修改原有的内部代码，符合开闭原则。 缺点： 产生多余的Builder以及Director对象，消耗内存； 代码上的优点： 1、建造者模式很好的表达了可选与必选： Builder构造方法是必选。Set方法可选。 ---》 技巧 2、通过build可以很明确的告诉别人，我们的对象已经创建完毕。 代码形式的记忆： 从代码形式上看，先创建了一个内部student类（即builder）。再把这个内部对象赋值给student。---》 这也就解释了为啥setXXX方法有两套。 关于builder的线程安全 TODO https://blog.csdn.net/nugongahou110/article/details/50395698 先new 再校验参数 与工厂模式的区别: 相同点： 1、都是给客户端构造对象的 Builder 跟 Factory 是不是很像？？？ 工厂模式: 客户端代码中，只是指定了 生产哪种产品。大量的参数封装在工厂中？ 建造者模式: 客户端代码中设置了大量参数 建造者模式注重零部件的组装过程，而工厂方法模式更注重零部件的创建过程。 https://blog.csdn.net/qq_26460841/article/details/119713865 安卓建造模式的应用1：从JDK的StringBuilder 安卓建造模式的应用2：AlertDialog 详细代码： // 使用 AlertDialog.Builder builder = new AlertDialog.Builder(this).setIcon(R.mipmap.ic_launcher).setTitle(\"\") .setMessage(\"\").setPositiveButton(\"确定\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }).setNegativeButton(\"取消\", new DialogInterface.OnClickListener() { @Override public void onClick(DialogInterface dialogInterface, int i) { } }); builder.create().show(); 为什么用建造者模式呢？其实就是方便用户使用的时候，知道要传哪些参数，方便且正确。 6.1.7. 原型模式 TODO 6.2. 结构型模式 6.2.1. 代理模式 生活化模型： 张三躲到 寺庙里不想见人， 所有事情， 由其管家代理 通知 张三 目的(基于生活化模型)： 控制对对象的访问（站在被代理对象的角度）---》 自然，张三不想被打扰 补充：站在client来看，没啥意义。但对于被代理对象，很有意义，保护了被代理对象 UML: EX1: EX2: 上网代理 和装饰器的区别: 侧重点不同：一个是功能扩展。一个仅仅做一层代理 安卓代码的例子 安卓例子： 1、远程调用AIDL。反推代码： 2、网络服务（跨设备了） 6.2.2. 适配器模式 一句话理解: 适配器模式，就是转换，把不能直接用的数据，转换成能用的。 本质上，是一个不得不的东西 生活模型： 电源适配器。 我想要直流电给手机充电，但是 目前有的是交流电，所以需要一个 适配器，把交流转直流 可以这样表达： 直流电适配器(交流电) ----》 即是直流电 自然，适配器，必然实现输出直流电的接口（抽象接口） 为什么要这样做？不得不的理由是什么？ UML：涉及的角色： 适配器模式涉及了三个角色： ①Target(适配器接口)： ②Adaptee(被适配角色)： ③Adapter(具体适配器)： 实现方式： 即 拥有别人能力的方式，自然： 1、组合方式：Adapter(A_Structure) 即： 把被适配对象放到适配器里 2、继承方式：通过继承，拿到 被适配对象的能力 注意： 使用继承方式时，Adapter extends Adaptee implement Interface ​ -----》可见，Adapter是一个既A又Z的东西 推论：对于继承方式 A extends B ，我们认为 A就是B ​ 组合方式， A(B), B 成为A一个持有的对象 ----》 理解上，化简为：没有B，B的能力都给了A (有点儿向内部类) Z如果想要用Andriod的数据结构，不能直接用。做一个Adapter 转Z可以使用的数据结构 Adapter(A_Structure) 代码EX2： 视频教程：https://www.bilibili.com/video/BV1Hz411e7sA/?-Arouter=story&buvid=XYA50C4AE9D0FD435535889530C0CC38FFE8A&is_story_h5=false&mid=3rb72hWRTB8TwF8P3lhSvg%3D%3D&p=1&plat_id=163&share_from=ugc&share_medium=android&share_plat=android&share_session_id=b529db63-da75-4196-b81b-9ac27310644a&share_source=WEIXIN&share_tag=s_i&timestamp=1675149493&unique_k=jdoUprV&up_id=59546029 EX3：安卓例子 TODO!!!! https://blog.csdn.net/zenmela2011/article/details/124591585 TODO: 适配器模式与装饰器模式区别？ 安卓代码的例子 6.2.3. 装饰器模式 TODO 装饰器模式: 扩功能两种方式: 1、继承方式,在子类中扩展 2、关联方式,把原来的类嵌入到新的类里,比如,把机器人装进箱子,箱子里装上手和脚---》即装饰器模式 静态?动态?为啥更加灵活? 优缺点: 6.2.4. 组合模式 参考： https://www.jianshu.com/p/2ef80f857153 作用： 将类和对象组装成 一个较大的 结构（必定是树形结构） ----> 所以，组合模式，是一种组织的方式 生活化模型： 树进行光合作用 -----》 记忆：组合树 如何组织一棵树？即树干（容器） : 容纳树叶及叶子 整体是树干，局部也是树干 效果： 整体与局部具有同样功能 ------》 不得不：自然：整体和局部有相同的功能和接口 模型推论，自然： 1、树干的方法： 树干是容器，自然，有 管理子元素的方法，add和remove 树干需要向下传递工作，自然，有工作的 方法 2、自然，具体工作光合作用只能leaf 完成；树干 只是向下传递工作，最终传给子元素（子树干和叶子） ​ 自然，树干和叶子都继承 光合作用的接口 uml： 适用范围： 任何可以组织为 树结构的。EX1: 统计全国人数 EX2: 安卓中View 和 ViewGroup 是典型的组合模式 基于模型（创造知识）反推安卓代码： 1、反推1：如何组织一个界面所有控件呢？用树可以 自然 2、反推2：树 可以用 组合模式组织 自然 3、反推3：控件和控件容器用组合模式---> 控件容器 必然有addview，remove 自然 必然有哪些工作方法呢？TODO 符合六大原则哪些： 符合开闭原则？ 6.2.5. 桥接模式 参考： https://blog.csdn.net/qq_16240393/article/details/89304453?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-89304453-blog-103319743.pc_relevant_aa&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-89304453-blog-103319743.pc_relevant_aa&utm_relevant_index=1 《Android源码设计模式》之桥接模式 https://www.bilibili.com/video/BV1Pp4y167DG/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 五分钟学设计模式.21.桥接模式 https://www.bilibili.com/video/BV1vU4y117qL/?spm_id_from=333.337.search-card.all.click&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 桥接模式的要解决的问题，即使用场景： 多维度变化类，新增时，类暴涨问题。 比如：两个维度：种类 m*n -----》 如果要新增一种，则 文件、类爆炸式增长 例子：华为曲面屏手机类 ----》 明显是两个(三个)维度的类 维度一：水滴屏、挖孔屏、曲面屏 ----》 抽象为 屏幕形式 维度二：华为、小米、vivio ----》抽象为 手机品牌 ------》 类的个数：m*n，新增 oppo的手机，会新增三个类 其实，这个是自然的，因为生活中，就是如此： 华为水滴屏手机P30、华为曲面屏手机Mate30 将抽象与实现分离，使他们可以独立变化。 用组合关系，替代继承关系 疑问： 为什么叫桥接? 两个维度，为什么叫抽象和具体？ 精髓在于，独立开，单独演进；类的个数减少 手段：以组合方式替代继承关系 代码中的列子 6.2.6. 享元模式 字面记忆：原本是多个元素，现在共享一个元素 -------享元 英文： Flyweight Pattern 生活中模型： 共享单车----即享元 好处：减少了整个社会的资源开销（只有一辆车） 特征：原本应该是两个对象，现在一个对象，被重复使用了（自然，对象内部包裹的内容，是变化的） 特别 注意：享元隐含着的意思/前提条件：原本应该是两个对象 ----> 比如：妈妈使用家里的锅，我使用家里的锅。这个锅本身就应该是一个，家庭级别的。所以，不是享元模式 uml图： 三个角色的理解： 1、共享单车模型：车子：享元、 车的其userName：不可共享的 -----------> 两者共同 组成 client 所使用的车 享元工厂：美团 2、安卓msg msg 空的对象：享元 msg 内的各种属性值：不可共享的 -----------> 两者共同组成 msg 从信息的角度看，享元模式的 精髓： 更新对象里的数据，不更新对象本身 优点： 可以极大的减少创建对象的数量，使得相同或者相似对象在内存中只保留一份。 即1、可以大大节约内存资源和系统开销 2、对于快速频繁创建的对象，解决了内存抖动问题 享元模式的缺点： （1）为了使对象可以共享，需要将一些状态外部化，这使得程序的逻辑复杂化。 （2）享元模式需要额外维护对象缓存池。 使用场景： 1、 2、短时间内频繁创建的对象 安卓中的享元模式的例子： java：字符串常量、线程池、 安卓：Messege、recycleView复用机制、手机相机预览图片(跟recyleView好像) ​ 对象池（parcel、Messege、） 享元模式之 安卓 msg 享元模式：对于快速频繁创建的对象，解决了内存抖动问题(即 Memory Churn 问题) 参考： https://blog.csdn.net/zenmela2011/article/details/125070508 现象： 频繁创建对象（内存迅速攀升）---> 达到一定临界程度，又会触发GC（内存使用迅速减小）---》之后又，，，，，， 即短时间内造成内存使用的迅速攀升于迅速衰减 例子： msg、binder、如果在view.onDraw里创建对象（每次重新绘制都会触发，16.7ms一次） 大循环里创建对象 原理： 短时间(抖动)内产生一批 使用一次的对象，会被分配内存，当数量达到一定的时候，垃圾内存会触发GC，------》 这一刻，就会骤减 内存抖动的危害： 总之，时间上，空间上 1、内存抖动伴随着频繁的GC，而GC有一个特性，就是STW(stop the world)，STW就会使程序（表现为界面卡顿）出现卡顿。(GC会占时间) ----》 根本原因：不能频繁的GC，GC 会占用时间2、导致OOM： 抖动太厉害的时候，此时如果新建一个大对象（比如5M）时，就会出现内存溢出OOM（内存碎片会造成无法提供连续的内存空间） -----》 根本原因：内存抖动会产生内存碎片 安卓 msg 复用具体代码： // Message.java void recycleUnchecked() { what = 0; arg1 = 0; arg2 = 0;// 数据置空 synchronized (sPoolSync) { if (sPoolSize 所以，msg存在两个 链表： 一个通过表示 queue 另一个sPool，是对象池 安卓检测工具：profiler检测内存抖动 可截取某段时间进行对象分析，查看哪些对象被频繁创建。---》 TODO: 实操一下 解决办法： 1、大循环引起的内存抖动，解决办法就是将对象创建放到循环外， 2、对于无法避免的创建对象情况，可采用对象池模型进行缓存，复用对象，需注意用完后要手动释放对象池中对象 3、其他： https://blog.csdn.net/m0_64420071/article/details/127303447?spm=1001.2101.3001.6650.7&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-127303447-blog-125070508.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-7-127303447-blog-125070508.pc_relevant_recovery_v2&utm_relevant_index=10 6.2.7. 外观（门面）模式 TODO 6.3. 行为型模式 6.3.1. 责任链模式 生活化模型： 请假责任链：张三请假，根据请假不同的天数，不同人去审批 一句话记忆： 责任链，本质就是处理链 明显的特征： 1、有链条（责任链可能是一条直线，一个环链或者一个树结构的一部分。） 2、真正的处理者，只会是链条上的某一个 官方表述： 责任链模式是一种处理请求的模式。他让多个处理器都有机会处理该请求，直到其中某个处理成功为止。责任链模式把多个处理器串成链。然后让请求在链上传递 UML： 特征，有链条 next 注： 无论啥模式，都尽量依赖抽象 代码： 优点: 从请求者角度：将请求者和处理者分开（原来是依赖关系）请求者不需要知道处理者。处理者也不需要知道请求者全貌。 ----》 自然提高系统灵活性 新增一个处理器到链条中的代价是非常小的 缺点： 也比较明显，就是他会降低整个系统的性能，因为处理者可能最坏的情况可能处于链条的末尾 安卓代码中的 责任链模式： 参考： https://mp.weixin.qq.com/s/sSPFz3E5gncYiMMFtF_xlg 好文 从责任链模式看Android事件分发 事件分发中的责任链模式 (外层责任链) TODO : 指的是input 事件那一套 事件处理中的责任链模式（内层责任链）: Activity -> PhoneWindow -> DecorView -> ViewGroup -> …View （在view段，是沿着树形结构分发的） 安卓的高超优化： ------------- mFirstTouchTarget 责任链 背景： 上述讲的是一个事件分发 （树责任链），但是 真正的 事件是事件流：1个 ACTION_DOWN、n个 ACTION_MOVE、1个ACTION_UP 引入的问题： n+2 个事件，沿着 树分发，复杂度太高 解决办法：第一个ACTION_DOWN事件的分发，会找出一个 分发线路（即给 mFirstTouchTarget 赋值）。后面同一事件序列的ACTION_MOVE、ACTION_UP 都按照这个线路分发（【1】） 这个分发线路即图中 mFirstTouchTarget 单链表 （这本身就是责任链模式） 【1】这个逻辑，其实也是符合生活尝试的，比如 TODO 总之： 安卓事件分发机制： 是双责任链模式（树责任链 + 链表责任链），见图 从代码中总结： 1、责任链不一定是单链表 2、分发流程 天然适合责任链 6.3.2. 中介者模式 英文： mediator pattern 生活化模型： 飞机降落模型： 多架飞机 ------> 存在的问题， 每两个对象之间都存在联系 即 多对多的关系 中介者模式： 飞机角度： 通过一个中介对象 转化为 一对多 从中介角度： 是调度者 基于生活化模型，自然： 优点： 降低类的关系复杂度，将多对多转化成一对多，实现解耦。 自然 符合迪米特原则（最少知识原则） 缺点 中介者要做很多事，会变得庞大且难以维护。 官方表述： 中介者模式是一种行为设计模式，能让你减少对象之间混乱无序的依赖关系。该模式会限制对象之间的直接交互，迫使他们通过一个中介对象进行合作 优缺点： uml： ConcreteMediator：具体的中介者角色 安卓例子： TODO: 6.3.3. 观察者模式 TODO 6.3.4. 迭代器模式 迭代器模式是一种行为设计模式,让你能在不暴露集合底层表现形式(列 表、栈和树等)的情况下遍历集合中所有的元素。 接化发 希望对集合类，有统一的迭代接口，方便人使用 for (String str : set) { } // 集合类（Set或list），是一个可迭代对象： 必然持有迭代器 public interface Iterable { Iterator iterator(); // 返回迭代器 } // 迭代器接口： public interface Iterator { boolean hasNext(); E next(); remove(); } uml： 可迭代 持有 迭代器 理解：迭代器的本质就是遍历元素 不同的迭代器 遍历算法不同，比如：深度优先遍历和宽度优先遍历 java 的例子 集合类 set List Collection实现了 Iterable 接口 如何使用迭代器 public class RunoobTest { public static void main(String[] args) { ArrayList sites = new ArrayList(); sites.add(\"Google\"); sites.add(\"Runoob\"); sites.add(\"Taobao\"); sites.add(\"Weibo\"); for (String i : sites) { // 背后使用了迭代器 System.out.println(i); } } } 6.3.5. 状态模式 生活化模型： 不同状态下做的工作不一样。比如： 高兴 ---》 工作认真。 被人打了心情难过 ---》 不工作 饿着肚子---》无精打采的工作 本质： 封装转化，即状态 到 行为的转化 UML： 优缺点： 优点，（相比于不用状态模式）： ①将繁琐的状态判断转换成结构清晰的状态类族，在避免代码膨胀的同时也保证了可扩展性和可维护性。 ②体现了开闭原则和单一职责原则，每个状态都是一个子类，要增加状态只需增加子类，要修改状态只需修改一个子类即可。 ③符合迪米特法则。 缺点：会增加系统类和对象的个数。 ---》 似乎是一个通用的法则：通过增加类来减小系统的复杂度。 代码 从代码形式角度，本质：参考：https://blog.csdn.net/zenmela2011/article/details/126508765 把if else用多态继承的方式来实现。 与策略模式的不同点： 见策略模式。 安卓例子 TODO 6.3.6. 策略模式 生活化模型： 上班模型：针对于去公司这一件事情，封装算法，客户端不关心算法实现细节 开车去（算法1：取车、停车、开车的路线，红绿灯、停车地点） 坐公交车（算法2：查找公交线路，公交站点。走路去公交站点，下公交） 骑车（算法3：） 走路（算法4：） 记忆： 达到同一目的 的不同策略。 官方表述： 注意，1、可以相互替换（自然，~因为各个策略都干了相同一件事情，去公司） 2、好处，算法可以独立于客户端而变化。（优点：如果没有封装，客户端是要 实现具体算法的，则耦合） 优点， 相对于没有封装算法的做法： 见上 缺点： UML： 与状态模式的不同： uml两者一模一样 不同点： 1、关注点不同： 状态模式的关注点：关注点在于转化，状态到行为的转换。不同状态下不同行为。一个状态下，可能有不同的行为。 ​ -----》 例子：今天状态是不开心，转化为行为：不想学习，不想吃饭，不想工作，只想睡觉 策略模式的关注点： 关注点在于封装一组算法，将每一种算法都封装到具有具体类中 ​ -----》 例子：打游戏。我是自己玩儿还是找朋友玩儿？还是找陪玩儿 2、目标不同： 策略模式的行为是可相互替换的（因为不同策略都干成了同一件事情）----》 即不同策略，目标相同。 状态模式 的不同行为，基本上不是干同一件事情 ----》 不同状态，行为不同，目标也不同。 安卓代码的例子 TODO jdk中例子： 代码： 6.3.7. 模板方法模式TODO 生活化模型, 读书模型： 幼儿园、小学、中学、大学… ------> 抽象 每个人的经历都是特别的… ------> 具体 UML: 参考： https://blog.csdn.net/weixin_39578432/article/details/118553952 例子： 6.3.8. 例子： 安卓的Actvity的生命周期： onCreate onStart onResume onPause onStop onDestroy -----》 操控了Activity 的一生 6.3.9. 命令模式 TODO 6.3.10. 访问者模式 TODO 6.3.11. 备忘录模式--->状态保存 6.4. 其他设计模式 非 GOF提出的23种设计模式 6.4.1. 生产者-消费者模式 英文： producer-consumer 生活化模型： 机场工作人员（生产者线程）-----机场传送带（缓存队列） --取行李的乘客（消费者线程） 行李（数据，比如msg） 由生活化模型，该设计模式需要满足以下三点要求： （1）自然，生产者生产数据到缓冲区中，消费者从缓冲区中取数据。 （2）自然，如果缓冲区已经满了，则生产者线程阻塞；---》安卓如何做的？ （3）自然，如果缓冲区为空，那么消费者线程阻塞。---》安卓epoll 生活化模型，自然优点： 1、数据的传递是解耦的 2、支持并发 ------ 多个工作人员同时 往 传动带投递行李 3、支持忙闲不均 代码例子： EX1: ui线程产生绘制数据 ---> render线程去消费 EX2: input？？ EX3: 安卓Handler 参考： https://carsonho.blog.csdn.net/article/details/121468054?spm=1001.2014.3001.5502 https://blog.csdn.net/haigand/article/details/90551070 https://zhuanlan.zhihu.com/p/73442055 经典并发同步模式：生产者-消费者设计模式 面试问题： 单生产者和单消费者共同操作同一个消息队列需要加锁吗 https://www.cnblogs.com/codingmengmeng/p/14420573.html 答案：不需要 7. 其他设计思想： 7.1. SetLinsterner与set(this)区别： 都是用于回调类似的操作 设计模式上，一般希望单项依赖。 好处：层级关系明确 linsterner与this区别： linsterner比较固定，大部分时候实现接口，固定不变。。。。这样，this其他部分改动，不影响B的开发 7.2. 分层设计思想 见《0层结构---一次Binder通信》 8. 背后的背后：思考设计模式的维度 生活化模型、一句话理解、uml（涉及的角色）、为什么要这样做？不得不的理由是什么？、解决什么问题、应用场景、应用范围 有缺点（和....对比的优点），比如：对于new的形式： 设计模式，一定是站在某一个类的角度考虑的问题。站在哪个对象角度去看（比如代理模式，站在client来看，没啥意义。但对于被代理对象，很有意义，保护了被代理对象） 安卓例子、如何用设计模式反推安卓代码(创造知识) 和。。。设计模式的区别 明显的特征（如何从代码中识别何种设计模式？） 9. 软件总结 1、不让开发者用的接口，但是又对外了， 最好是抛异常---->这样开发者能感知到 Log.error不容易感知到 10. 视频教程 & 参考链接 https://www.bilibili.com/video/BV1PJ411y7iL/?p=7&spm_id_from=333.880.my_history.page.click 骆诗琪 https://www.bilibili.com/video/BV1hK4y1L7zV/?spm_id_from=333.788&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 子烁爱学习 11. uml 11.1.1. 分两类：静态图、动态图 静态图： 动态图： 状态机 11.1.2. 关系表达 接口的实现： 两种表达 依赖关系： 使用关系《用到了 use a！！！！ 代码中的临时变量、入参、import 尽量不要相互依赖 关联： ​ 记忆之 锚：具体分为两种：有+同生同死、有+非 。。。。 有或者包含（has a 或 contains a） 即代码中的成员变量 关联关系可以继续分为： 聚合 ----->记忆：关联符号尾端， 空心 has a 整体与部分关系 组合 ---->关联符号尾端，实心 contains a 同生同死 11.1.3. 类的表达 11.1.4. 接口的表达 尽量用label形式？？？ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/Graphic.html":{"url":"coding/Andriod/Graphic.html","title":"Graphic","keywords":"","body":"1. 图形系统（脱离安卓来看）1.1. 图形系统0层1.2. 图形系统1层1.2.1. 渲染系统1.2.2. Window系统（图形视角）1.2.3. 显示系统2. 显示驱动模型DRM架构介绍（一）TreeviewCopyright © aleen42 all right reserved, powered by aleen42 图形系统0层 图形系统1层 渲染系统 Window系统（图形视角） 显示系统 显示驱动模型DRM架构介绍（一） 1. 图形系统（脱离安卓来看） 1.1. 图形系统0层 图片： https://mp.weixin.qq.com/s/LVVR1IGrn_PopGUkefjKvA 深入理解Android图形系统, Linux阅码场;) 对于任何图形系统（抛开安卓不谈），为什么需要这些？ 不得不： GUI需要： 1、Render系统： ​ 作用： view界面数据 到Buffer上（实际上是绘制控件）： 即 执行GUI的绘图指令集 ​ 位置：Render线程 2、window系统 ： （1）窗口的管理器 ，对于安卓，位于WMS 中 ​ （2）窗口的合成器 ----> 注：对于安卓是surfaceFlinger 3、DisPlay系统： ​ 作用：把Buffer的位图显示出来 ​ 位置：内核驱动 总之： 图形系统 = window系统 + Render系统 + DisPlay系统 1.2. 图形系统1层 render系统: 1、是以 lib（.so）形式存在 2、运行时：在App GUI进程里 1.2.1. 渲染系统 目标： view数据转buffer数据 基于目标，渲染引擎有哪些？ 2D引擎 Skia，3D引擎 OpenGL ES，RenderScript，OpenCV和Vulkan 1.2.2. Window系统（图形视角） 目标： 区别各个窗口之间 协调各窗口之间的关系 1.2.3. 显示系统 目标： 将buffer数据，最终到显示屏上 2. 显示驱动模型DRM架构介绍（一） https://www.eet-china.com/mp/a178945.html Linux阅码场 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/HowToReadCode.html":{"url":"coding/Andriod/HowToReadCode.html","title":"How To Read Code","keywords":"","body":"1. 目录2. 待整理TODO:3. 理解代码架构3.1. 代码就是一片很多岔路口的森林3.2. 为什么我记不住代码？3.3. 多画0层图、1层图3.4. 0层之子系统间关系图3.5. 0层之模型图/结构图3.6. 0层时序图3.7. 1层之核心类图+作用3.8. N层之核心类继承关系3.9. N层之模型图拆解（注释）3.10. N层之基础设施3.11. N层之使用3.12. TODO:其他3.13. 自然法则：3.14. 给出0层设计、一层设计、二层设计3.15. 更深的理解来源于本质的实现3.16. 用面向对象的语言去描述事情！3.17. 为什么我不能从代码中抽象出xu的图？3.18. 一些经验：3.18.1. 覆写的作用，3.18.2. 类的本质：3.18.3. 画结构图技巧：3.18.4. 实现了某个接口，即拥有某种能力3.18.5. 工具类3.19. 知全局而做局部3.20. 代码框架的收集3.21. 如何阅读别人的代码4. 文章TODO: 链到你的文章结构里4.1. gitYUan4.2. 罗升阳4.3. wangyin4.3.1. Talk is not cheap4.4. xu4.5. 以信息流的方式理解代码结构：：4.6. AS 中引入其他盘的java代码作为source4.7. 解bug体会、查找：4.7.1. 看问题，都要正向看+反向看4.7.2. 如何识别一个对象，唯一化？4.7.3. 对于快速变化的问题4.8. 永远不要用模糊性词语，4.9. 思考问题，一定要闭上眼睛4.10. 答案永远在代码之外4.11. 代码脑中简化技巧4.11.1. 0层综述4.11.2. 记忆之房间：4.11.3. 化简之框架：逻辑上舍弃已知框架4.11.4. 化简之 大概就是、大部分情况就是4.11.5. 化简之包裹4.11.6. 化简之内部类（次要类）：4.11.7. 化简之内部类2（解决java单继承问题）：4.11.8. 化简之同胞类4.11.9. 函数化简之 信息流4.11.10. 函数化简之 return4.11.11. 化简之透传（可大量化简）4.11.12. 化简之合理性（围绕目标的）4.11.13. 化简之目标4.11.14. 化简之if else4.11.15. 化简之名词4.11.16. 化简之类比4.11.17. 化简之 减少逻辑调用链4.11.18. 如何识别模块的主类：4.11.19. 如何识别类的主方法:4.11.20. 化简之解耦思想4.11.21. 化简之设计模式4.11.22. 化简之 功能逻辑 驱动 函数记忆4.11.23. 化简之按功能点拆解（写技术文章方法）4.11.24. 化简之 按照变量抽离4.11.25. 化简之大流程4.11.26. 化简之小函数4.11.27. 化简之函数调用栈Tree4.11.28. 化简之忽略 handler4.11.29. 化简工具 之BookMarks4.11.30. 化简之持有4.11.31. 化简之new bing4.11.32. 化简之 设置的值4.11.33. 跳转化简之AIDL4.12. 秒解技巧4.13. 常见代码框架4.13.1. TODO: 为什么框架是这个样子？何时要用这个框架？4.13.2. 解决JAVA不能多继承问题4.14. 方法集key (清单)4.14.1. 仅限于代码的方法 list4.14.2. 生活4.14.3. 文章\\文字5. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 待整理TODO: 理解代码架构 代码就是一片很多岔路口的森林 为什么我记不住代码？ 多画0层图、1层图 0层之运行时0层 0层之子系统间关系图 0层之模型图/结构图 0层时序图 1层之核心类图+作用 N层之核心类继承关系 N层之模型图拆解（注释） N层之基础设施 N层之使用 TODO:其他 自然法则： 给出0层设计、一层设计、二层设计 更深的理解来源于本质的实现 用面向对象的语言去描述事情！ 为什么我不能从代码中抽象出xu的图？ 一些经验： 覆写的作用， 类的本质： 画结构图技巧： 实现了某个接口，即拥有某种能力 工具类 知全局而做局部 代码框架的收集 如何阅读别人的代码 文章TODO: 链到你的文章结构里 gitYUan 罗升阳 wangyin Talk is not cheap xu 以信息流的方式理解代码结构：： AS 中引入其他盘的java代码作为source 解bug体会、查找： 看问题，都要正向看+反向看 如何识别一个对象，唯一化？ 对于快速变化的问题 永远不要用模糊性词语， 思考问题，一定要闭上眼睛 答案永远在代码之外 代码脑中简化技巧 0层综述 记忆之房间： 化简之框架：逻辑上舍弃已知框架 化简之 大概就是、大部分情况就是 化简之包裹 化简之内部类（次要类）： 化简之内部类2（解决java单继承问题）： 化简之同胞类 函数化简之 信息流 函数化简之 return 化简之透传（可大量化简） 化简之合理性（围绕目标的） 化简之目标 化简之if else 化简之名词 化简之类比 化简之 减少逻辑调用链 如何识别模块的主类： 如何识别类的主方法: 化简之解耦思想 化简之设计模式 化简之 功能逻辑 驱动 函数记忆 化简之按功能点拆解（写技术文章方法） 化简之 按照变量抽离 化简之大流程 化简之小函数 化简之函数调用栈Tree 化简之忽略 handler 化简工具 之BookMarks 化简之持有 化简之new bing 化简之 设置的值 跳转化简之AIDL 秒解技巧 常见代码框架 TODO: 为什么框架是这个样子？何时要用这个框架？ 解决JAVA不能多继承问题 方法集key (清单) 仅限于代码的方法 list 生活 文章\\文字 技术文章目录，要呈现代码架构 化简 格式 1. 目录 [TOC] 2. 待整理TODO: 面向对象精髓： 1、对象+关系 （全局视角） 2、入口与出口（个体视角） 代码的精髓：流（小蝌蚪的涌动） 时时刻刻把握住入口和出口！ + 时刻把握位置 + 时刻要有对象的思想（就是一个人！！！！！） 一个模块的入口和出口 一个类的入口和出口 同理，任何系统无非干两件事：输入和输出，接收到外部输入信号后经过操作系统处理后输出信息。 位置： 哪个线程、哪个模块、哪个层！！！！ 看代码，按照功能块来看。。。。比如一个类太大，森林太大=>功能块总是 相对独立的，我们看一个功能块就行。。比如森林里的一块池塘，比如人体的消化系统 识别了类的一个功能块，就ok了，心里不要慌 看代码一定要有层的概念。。。比对象概念高一级 其实有对象的地方，就有层 比如，应用和我们以及内核--------->就是层的概念 提升工程架构思维，软件工程思想都是相通的，境界会得到提升！！！！只要一个领域做到极致， 换新领域你也能做到极致。 好奇心比雄心走得更远：很多人对未来空有满腔的雄心壮志，往往不如对技术要有一份好奇心，一份探索欲，再加上一份执着的人。 思考，问题，好奇心 一个类的主要功能，接口 不要做很详细的笔记，很烂，因为很具体，你根本记不住 干事的进展，要记录下来。这样有叠加性，后期可以追溯。关键写在纸上，可以分析 常常问一下你能说出个123嘛？ 说出123，倒逼你了解细节，以输出倒逼理解 要重视你的话，称呼，反应了你对事物的理解： 比如Z无障碍，你可以把它称为Z无障碍服务（Z的adpter+A的无障碍服务） contentview粒度 systemui，空指针，会重启 lunyin surface是内存，是内存的数据结构，理解为像素 canvas是抽象的画布 client，sendEvent那条路，你没有说清楚 命令的多句并列执行 价值，问题有没有价值,xuji 差异化，改动，才能认识深刻 比如，改变颜色，看看。改动大小 通过问题，熟悉代码很快 冲突，问题，差异化都是好东西 冲突，问题，差异化，不要死磕，先一定思考+求助别人>最后反思成文 调用别人接口， 1、会不会耗时， 2、多线程调用 把握住入口和出口：1、理解代码。2、记忆。3、打log也是。 最好是唯一的入口和出口，任何bug都可以倒逼 出口和入口表现为： 模块的 类的，即public 如何提高调试的效率和精确度？技巧： 1、在log里设置起始标志，之前log的全删 2、所有view里的log，加地址+宽高>区分 对于应用，设置不同颜色 3、分层 分层， 代码，应用与底层，社会 为什么要分层？ 为啥做编写代码时，整一个空的接口？ 1、先搭架子 2、符合计算机思维，拆解问题 3、本质原因：人脑子有限，只能想清楚一个调用frame里的逻辑 注意：上一frame定义了getNextString ------>该接口功能必须定义清楚，下一frame实现起来才清楚 ------->规定：必须文字写上 3. 理解代码架构 3.1. 代码就是一片很多岔路口的森林 又如人之间 我们如何认识森林，就如何理解代码 （0）如果有现成的地图----架构图（文档），先看地图 如何理解人物，就如何理解代码。类即是人！！！！ 如何认识一个新类？----->如何认识一个新人？？先看表象： （1）先看长的怎么样：对外接口-------->猜测做啥的，人物关系 对于陌生代码，先画地图，然后跟着地图分析具体过程 画地图---->调用栈+plantUml，可以无脑画 看log，第一步，一定是用空行分层 不要用人脑直接对抗机器 （2）看源码目录结构 为什么输出不了xuji的0层图？？？--->即静态的架构图？？？ 原因在于： 你只走了地图中的一条路，只熟悉了一条路。你看不到其他路是怎么样的 3.2. 为什么我记不住代码？ -------->如何记忆代码 永远不要记代码，因为你也永远无法记忆一片森林，记的是： ​ (1)自己的话！！！！！！！！，而非英文代码 ​ (2)记忆森林中关键路，关键路上的一些关键标志，比如凉亭：要记关键流程的 时序图。注意：记忆时序图，也只是记忆关键类的关键方法（最大限度的抽象，才能成为记忆之锚，理解之锚）。。。 （3）记忆流程按照块来记，模块指定了流程的方向，不得不 规定：一个流程，必须回答： 从进程角度看整个 核心类是啥，在哪个进程里？？？主要功能是啥？？？有哪些对外接口 =>不要记忆动态的流程！！！ ​ 动态的调用流程太长，你记不住的！！！！！------> 记忆每个类的功能，方向是自然的！！！不得不的！！！！ 做了啥（做事的直接时机是啥？间接时机？与主干哪个时机挂钩？---> 记忆之锚） 业务场景是啥（用户点击等） 入口在哪，交互点 该流程的启动时机 涉及哪几个进程----->即模块架构 模块之间的通信是怎样的？ 有哪些关键流程点 时机：何时新建的？初始化时机比较重要 变量的流转流程 是否是单例？--->为什么要用单例？ 不断去抽象，更高层、更高层、更高层（方向）！！！！！！！=>甚至0层！！更容易记忆 主干的生命周期是啥？（其实任何一个事物都是一个对象，都有生命周期）对象的生命周期，线程的生命周期，模块的生命周期 3.3. 多画0层图、1层图 体会：如果要真正理解一个东西，一定要走向抽象、走向简单、甚至走向忘记。无论是知识、方法、习惯、、、、、、、、 包括画图本身，也是抽象过程：具体代码 ---> N层 ---> 2层 ---> 1层 ---> 0层 注意：没必要N层很熟悉了，再画0层；对于一个新项目，先画0层（根据接口），后期再修正 ​ 对于设计，一定是抽象走向具体：设计0层 ---> 设计1层 --->........具体代码 ​ 封装性，也体现了代码实现过程，抽象到具体：leetcode 在主要函数里，先加空实现函数A(), 之后再实现 记忆与理解的关键做好链接： 0层代码与0层图的链接（其实是映射） 1层代码与1层图的链接（其实是映射） 0层代码与1层代码的链接 0层图与1层图的链接： 链接方向： 实际物体—0层架构-1层架构（0层放大）-1层流程图 TODO: 反过来呢？是不是应该让实际依附0层架构呢？ **规定**：0层时序，必须有方向简化 **规定**：研究完0层时序（纵向），必须横向看 **规定：**借鉴土木画图的方法，1层架构图必须基于0层架构图，放大版（保证方向和形状不变）！！！！！否则，认为无效 ## 0层之运行时0层 对于多线程的流程，运行时0层，`从进程、线程的角度去分析，更本质` ------> 线程结构 + 数据流转 才是 真正意义上的 0层架构，表达了运行时的0层 EX1: 0层需要关注（需要回答的问题）：数据运行在哪个进程的线程 EX2: IMM-IMMS-IMS 之间关系 问题： 图中，以线还是 框 代表线程呢？ 如果以框，一定要在框里区别，这是IMS还是IMS线程！！！！！！ 3.4. 0层之子系统间关系图 0层之子系统间关系，即系统功能划分---->当前模块在整个系统中的位置，与其他的联系 例子1，xu view框架---0层 具体技巧：对于一个新项目，先画子系统间关系（根据接口），后期再修正 例子2： 3.5. 0层之模型图/结构图 我们记忆的是模型，而不是代码实现 面试讨论的也是模型 你要增长的核心能力，也是理解模型能力（更甚者，发展模型，建立模型的能力） 模型的本质就是数据结构(模型是更生活化的语言)： (1)、什么样的模型：一堆数据，如何组织起来 比如，flutter的三棵树 (2)模型承载了啥、主要作用是啥------>从层的角度来看 比如： (2)模型(数据结构)的建立过程 (3) 模型的维护过程 (4) 模型的生命周期 (5)基于模型，分析其他重要流程 问题在于：TODO: 对于现有代码，如何在代码里抽象出最核心的模型？ TODO: 每个子系统都有模型图吗？输入法有吗？ 程序的本质：信息沿着 结构图流动 结构图的缺陷：能展现正常运行态，但是展示不了，搭建结构的过程 补齐能力：0层时序 3.6. 0层时序图 一般时序不是0层。但是需要一个0层时序，串起来整个系统（至少多个子系统）。串起来所有模块，保证所有模块有条不紊。 方式一： A- uiTask- IOTask- GPU Task 方式二（推荐方式）：用思维导图方式 优点： 1、折叠起非1层------> 便是0层大的时序，不会陷入细节: 1层时序a ---> 2层时序a ---> 1层时序b 0层的几个绿色框---->记忆之锚，即使是不能折叠的情况下，也只关注0层的几个绿框关系，锚要牢记 2、展开情况下，又能看到0层与其他层的链接关系。在方式1做不到这一点，要么过于细致，要么只有0层，没有链接其他层 3、很好的契合了人脑的思维+记忆方式：frame + 链接。三个frame + 链接 4、方向性要比方式1好，易于记忆：信息的流动总是 先向右再向下 5、很好地链接了代码 6、折叠性解决了调用栈的复杂性 总之：思维导图画时序图核心在于，善于利用折叠，牢记0层的锚点顺序。 规定：（1）0层时序第一个子主题必须用中文描述，干了啥 （2）看0层时序时，必须想着0层架构图或实际图。。。让0层时序依附0层架构图或实际场景--》原因在于，时序图不适合用于记忆？ 3.7. 1层之核心类图+作用 例子，xu view框架---Native简图 3.8. N层之核心类继承关系 3.9. N层之模型图拆解（注释） 3.10. N层之基础设施 基础设施是桥梁，拿来用的，你知道怎么过桥就行; 但是 至少有一次要了解桥怎么搭建的 基础设施，比如：IPC桥梁、JNI桥梁、高低软注册桥梁 1、怎么过桥：(1)怎么写代码 (2)怎么快速索引代码，比如上述三个 2、桥怎么搭建：背后机制具体实现 3.11. N层之使用 从开发者或者新开发一个控件角度去看，如何使用一个已经有的框架：需要做哪些 比如，xu view框架---无障碍、事件和手势 3.12. TODO:其他 关于进程，区分在哪一张图里呢？？还是每一张图 如何了解一个类做了啥？接口+doc，看public API（包括.h） 如何了解一个模块做了啥？找两个模块之间的API （统一的interface，比如aidl、interface；非统一的，A调B的public函数）-----> 抽象：横向看调了哪些方法，不看某一方法实现细节 关于模型，关于自然法则，一定要找到物理模型（生活模型），这样才更好理解 3.13. 自然法则： 给出上述每一张图背后的自然法则： 为什么会是这样？背后的美学在哪里？必然性在哪里？生活(哲学)原理在哪里？ 有没有不好的地方？违背自然法则的地方？ 设计模式----------无模式，不代码 像解答 证明题一样，证明代码为什么是这样写的 3.14. 给出0层设计、一层设计、二层设计 规定:任意一个项目，至少给出0层设计、一层设计！！！！ 按照提交人，看代码---->剥离出特定功能 记忆：主要类图（静）和主要时序图（动）------>相辅相成 时刻把类想象成一个人 一个人，有哪些东西 一个人，可以有哪些能力 其实，任何事情都是？ 有没有深刻理解，一定要看有没有回答很多问题，尤其是本质的一些问题！！！！！！！！以问题驱动理解 那么，如何提一些常见性问题、以后后续的本质问题？ 避免模糊性词语，会欺骗你 比如安卓画的>就把所有细节掩盖过去了，欺骗了你自己 安卓进程还是z进程？ 安卓的类？还是z的类？ 安卓的哪个进程？ 具体怎么画的？哪个类负责的？ 画在哪个surfaceview上？ 怎么画的？ 如果是在A的view上，怎么处理与Z的surface view关系？遮挡 3.15. 更深的理解来源于本质的实现 比如bep一致性；再比如 进程的理解：进程实体、 ------>所以，深入理解计算机系统非常重要！！！！ 需要了解到什么程度？具体技巧：理解了一个功能的实现机制，并能画出实现机制的模型图。。。比如： 3.16. 用面向对象的语言去描述事情！ 永远不要说，A类调了B类的 onTouchEvent(MotionEvent event)接口！！！！！！！ 而是： （1）A将事件（MotionEvent）让B处理了（onTouchEvent） （2）或：A分发事件给B，让B去处理 -------->可见，整个代码体系，从来都没有代码，只是背后的对象本质 3.17. 为什么我不能从代码中抽象出xu的图？ ---->如何从代码中提炼主要类图和主要时序图？-->即如何寻找主干？ 寻找代码主干的方法： （0）你无法在森林里找到主路的，除非你有地图： 找他人，网上要地图：设计文档，流程图 但是有一点你要保证： 别人告诉了你路的大致方向后，只有你自己走一遍路，路才是你的！！！！！否则记忆别人说的，不可靠！！！！！ 什么叫走一遍：沿着log，回答上面问题 （1）初步用ea自动生成类图，找出主要类（以及主要调用方向） 一群人干了几件事情 （2）运行起来，打调用栈及log------->无法识别主干 技巧：网上下载的项目，如何运行起来？？？？？很多报错 尤其是版本对不上。。。。。代码和sdk和手机版本对 ----->比较好的方法是：注释掉！！！ 因为版本错位的代码都非主干代码！！！ 比如编译时报错： 错误：找不到符号 类XXX 位置：程序包 com.xxx.xxx 3、为什么我听不懂别人说话？ 大致方向： 阅读代码有两种模式: top-down和bottom- upo Top-down模式,就是先设定一个use case, 比如说打开一个文件。然后静态跟着代码看, 或者用debugger跟着看。每次出现函数识m 的时候,把函数的执行层次纪录下来。大 下: func1( ) ​ func2( ​ func3( 具体方法： 优先级：断点调试----->调用栈----->log----->走读（静态） 如何看发消息的log？？？ 因为有很多同类的消息，一条消息会调整个流程 >多条消息会造成log错综复杂 方法： 1、先挑一条典型的消息，串好整个流程 2、再广度：看一组消息是怎样的，有哪些（用过滤器） 3.18. 一些经验： 3.18.1. 覆写的作用， （1）完善子类功能，比如TextView覆写view方法，完善自己特有的，然后调用super方法 （2）恶意阻断，屏蔽父类方法：子类将父类方法重写，直接return出去。那么开发者调用这个方法永远失效！！！！！ （3）把调用流程和参数拦截到子类里 3.18.2. 类的本质： 即对外功能的总和，即一切方法的总和（是方法的抽象） 推论：通过对外API来认识一个新的类（横向看所有类） 一对多，一定是模型，尝尝是一定要画图的 3.18.3. 画结构图技巧： 1、 结构为主+重点信息方向 画图，重点在画方向，关键流程的方向，核心信息的流转方向！！！！大的箭头流动 为什么要这样子？因为信息流动的是要依靠结构流动的 举例子：Y侧graphic图 3.18.4. 实现了某个接口，即拥有某种能力 ！！！！！！---->实现了Parcelable接口，就有了打包的能力 接口的另一个作用：协议 --->我实现了某个接口，你便可以用这个接口实现类 3.18.5. 工具类 工具类都是静态方法 比如：Utils 安卓的Process.java /** * Tools for managing OS processes. */ public class Process { .......... } 3.19. 知全局而做局部 ------>如果你没有全局的视野，做局部毫无意义！！！！！！（因为你理解不深刻，做了也是很快忘记！！！！！） 3.20. 代码框架的收集 3.21. 如何阅读别人的代码 https://www.yinwang.org/blog-cn/2020/02/05/how-to-read-code -----wangyin 比起阅读代码，我更喜欢别人给我讲解他们的代码，用简单的语言或者图形来解释他们的思想。有了思想，我自然知道如何把它变成代码，而且是优雅的代码。很多人的代码我不会去看，但如果他们给我讲，我是可以接受的。 如果有同事请我帮他改进代码，我不会拿起代码埋头就看，因为我知道看代码往往是事倍功半，甚至完全没用。我会让他们先在白板上给我解释那些代码是什么意思。我的同事们都发现，把我讲明白是需要费一番工夫的。因为我的要求非常高，只要有一点不明白，我就会让他们重新讲。还得画图，我会让他们反复改进画出来的图，直到我能一眼看明白为止。如果图形是 3D 的，我会让他们给我压缩成 2D 的，理解了之后再推广到 3D。我无法理解复杂的，高维度的概念，他们必须把它给我变得很简单。 很多人都不知道，有一天我用不到一百行 Scheme 代码就写出了一个「深度学习框架」，它其实是一个小的编程语言。虽然没有性能可言，没有 GPU 加速，功能也不完善，但它抓住了 PyTorch 等大型框架的本质——用这个语言写出来的函数能自动求导。这种洞察力才是最关键的东西，只要抓住了关键，细节都可以在需要的时候琢磨出来。几十行代码反复琢磨，往往能帮助你看透上百万行的项目里隐藏的秘密。 很多人以为看大型项目可以提升自己，而没有看到大型项目不过是几十行核心代码的扩展，很多部分是低水平重复。几十行平庸甚至晦涩的代码，重复一万次，就成了几十万行。看那些低水平重复的部分，是得不到什么提升的。造就我今天的编程能力和洞察力的，不是几百万行的大型项目，而是小到几行，几十行之短的练习。不要小看了这些短小的代码，它们就是编程最精髓的东西。反反复复琢磨这些短小的代码，不断改进和提炼里面的结构，磨砺自己的思维。逐渐的，你的认识水平就超越了这些几百万行，让人头痛的项目。 注：目的性要明确 ----> 比如了解view显示，那么事件的流程就不要考虑 解耦思想 4. 文章TODO: 链到你的文章结构里 4.1. gitYUan https://mp.weixin.qq.com/s/saps9pV-HEAon4majH1-aQ Android系统之博大精深，包括Linux内核、Native、虚拟机、Framework，通过系统调用连通内核与用户空间，通过JNI打通用户空间的Java层和Native层，通过Binder、Socket、Handler等打通跨进程、跨线程的信息交换。 只有真正阅读并理解系统核心架构的设计，解决问题和设计方案才能做到心中无剑胜有剑，才能做到知其然知其所以然。当修炼到此，恭喜你对系统有了更高一个层次的理解，正如太极剑法，忘记了所有招式，也就练成了太极剑法。 再回过头去看看那些API，看到的将不再是一行行代码、一个个接口的调用，而是各种信息的传递与交互工作，而是背后成千上万个小蝌蚪的动态执行流。记得《侠客行>里面的龙木二岛主终其一生也无法参透太玄经，石破天却短短数日练成绝世神功，究其根源是龙木二岛主以静态视角去解读太玄经，而石破天把墙壁的图案想象成无数游动的蝌蚪，最终成就绝世神功。一言以蔽之，程序代码是死的，系统运转是活的，要以动态视角去理解系统架构。 我们看代码时，要抱着的一个目的就是弄懂它的骨架和脉络，细节无需记忆。毕竟对于一个系统来说，它是有很多细节的，我们无法在短时间把它们都完全吃透。但是主要我们掌握了它的骨架和脉络，以后无论是要了解它的什么细节，都可以很轻轻地找到相关的源文件，并且可以很容易进入主题。 似懂非懂的感觉，实际上就是不懂！ 理念总结： ​ 1. 从代码中找答案——Read The Fucking Source Code。 ​ 2. 以不变应万变——坚持看一个版本的代码直至理清它的骨架和脉络。细节无需记忆 对于优秀的开源项目来说，不去读一下它的源代码，简直就是暴殄天物啊。读代码有什么好处呢？太多了，除了可以学到别人的优秀代码、架构之外，最重要的是，我们能从中找到答案，从而可以解决自己项目上的燃眉之急。 拿Android系统来说，你在至少得懂点Linux内核基础吧！ 4.2. 罗升阳 对Linux内核有大概的了解之后，就开始学习Android应用开发，因为我觉这是学习Android系统的切入点：知道怎么用一个东西之后，才能更好地知道它是怎么实现的。 -------->所以，测试demo以及测试demo比源码实现重要！！！！ ---->要经常写demo = 输出比输入重要！！！！ 我一直相信潜意识这种东西：只要你相信你能解决一个问题，并且坚持住不放弃，潜意识就会帮助你去加工和组织各种信息。因此，自信很重要，它是一种软实力：有自信不一定能成功，但是没有自信就很难成功。 淡定。淡定是一种人生态度，它能使人不功利，不浮躁，从容地面对得与失，找到一条更合适自己长远发展的路。往往梦想都是一个比较长期的东西，不是短期内就能看到效益的。 4.3. wangyin 4.3.1. Talk is not cheap https://www.yinwang.org/blog-cn/2019/09/11/talk-is-not-cheap 4.4. xu CHEN: https://www.jianshu.com/p/37370c1d17fc 这个文章很好。但是又长又臭,过一两年后可能就忘记了。作为技术专 家, 到底记得的是啥? 如果要记得这么多知识点,又该怎么化简做减法呢? 越能做减法,cover的知识树越大。我是这样理解的 XU: 看软件先看架构、再看关键流程,它们是软件的骨架,支撑起组件和无数实现细节。这个帖子介绍了关键流程、细节满满,你可以跳过细节看大纲, 然后尝试去解释每个启动步骤的合理性。解释通了就算初步理解了, 至于流程的 细节不用看,看了不用也记不住的。 大纲 cache 在脑子里,有需要知道怎么去查, 就够了 CHEN: 解释每个步骤的合理性。这是一个不错的想法。如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 理念总结，只有一个关注点就是骨架自然性： 1、骨架： 架构图、关键流程图 肉：组件、具体代码实现细节 无论什么时候(新项目第一次看，还是老项目复习知识点)，都是 关注骨架、忽略细节。不看代码，更不记忆！ 看帖子，也要跳过细节 2、对于骨架，也不记忆！！！ （1）尝试去解释每个步骤的合理性，如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 （2）编故事，生活化模型去理解，在生活模型中找不得不！ 3、不能有复杂的图，复杂的图，只能当做字典 自然，代码是最大的字典 4.5. 以信息流的方式理解代码结构：： 信息流 ---->是代码的本质 1、类是一个信息流-->类信息流的流向，决定了类的持有关系 2、方法也是一个信息流 ----->决定了方法的调用关系 方法信息流查看ide：alt + F7 ，调用关系 3、变量是信息流 --->决定变量的信息传递流向 变量信息流：双击选中 --->会给你信息流 （计算机的本质） --->x信息最终给到了touchBounds ​ --->在此之前x信息被getScrollx改写了 利用信息流的例子： 1、问题：view.setTranslationX(float translationX) ---->(1)这个接口会造成view显示变化了，那么touch时的热区变化了嘛？ ----> (2)如果没变化，那么又是如何做到的？？ ​ ---->（1)可以通过event的x,y来断定 下面分析（2）： 信息流思维：translationX 信息只流向了类mRenderNode，没有停留在view里 ------>所以最后要用，只能由mRenderNode流出 ------->方法1：查看mRenderNode方法调用点 ------->方法2：用trace暴力，看调到RenderNode哪个方法 ------>方法3：反向，不得不 ---->从event入手，event的x,y需要translationX 信息 ----->跟踪event的x, y ，必然会找到拿到translationX的地方 只抓一点，不及其余！！！！！！！比如这里的位置，只看event的位置！！！！ ------>虽然调用栈很深、方法很多、方法体很长 ------->但是某一问题，关心的量只有一个，死盯着一个量，只跟踪一个量的信息流！！！！！！！ ----->这样就容易很多 这里，追踪MotionEvent ev的,x与y，便可以跟踪到方法： 4.6. AS 中引入其他盘的java代码作为source 1、进步:云帆引入方法，可以将其他盘代码引入As工程源码作为source 基于进步的拓展:那么可以做的事情就非常多了，比如将Z侧计算云代码引入source断点调试，依赖源码 再拓展: 打通ndk调试（A侧和Z侧），以同样方法引入cpp 4.7. 解bug体会、查找： 4.7.1. 看问题，都要正向看+反向看 每前进任何一步，都要正向看+反向看，然后再下一步（方法便可以指数增长） ----》 基于这一进步，我们可以做很多事情 。 以bug为例子: 正向: 不断找crash来源 反向: 对比正确的例子，寻找差异点 主动制造冲突: 修改某一个量，比如，增加颜色，改变view大小（as可以临时）、view相同大小获取其父亲 找到任何一个差异点后，1，都可以尝试用as去修正（反向） 2，追踪差异点来源（正向） 例子：无障碍下手表应用commonDialog无法触摸获得焦点 ------>反向可以对比的元素：无障碍+非、手表+手机、Dialog+ ability、无法触摸焦点+可以触摸焦点 手表的Dialog window没有liearlayout ------>1、正向 断点加在构造函数里 2、反向： 结果，有swipelayout 正向:何时生成 （反向:在冲突点修改值，看能否正常） 反向，与其他手表应用对比？ 改好，改差 这个不行，对比其他 正向:把这个改好 反向:把其他改差 多个因素对比，比如手表手机，dialog和ability 非代码区别:describtion，打印父子关系 代码中区别:hash 一心只为提高自己，偏离这个即使有利益，放弃 xuji 反面看事物=>提问题，去怀疑 如何理解深刻？>要问的尖锐深刻+回答得清晰 跳出代码看问题 过年的影响0:消费 投资和个人一样，本质都是价值 如果你想要变得聪明，你必须不停地追问的问题是“为什么，为什么，为什么” 严格分析——使用科学方法和有效的检查清单能够最大限度地减少错误和疏忽 耐心——克制人类天生爱行动的偏好 ● “复利是世界第八大奇迹”（爱因斯坦），不到必要的时候，别去打断它 4.7.2. 如何识别一个对象，唯一化？ 在log中---->内存地址 非log中---->直观：增加颜色，改变view大小（as可以临时）、view相同大小获取其父亲 断点调试中--->比如在xml里，给一个控件一个ID 4.7.3. 对于快速变化的问题 ---->一大利器就是：放慢！！！！ 放慢例子1：快速变化的代码---->log 放慢例子2：快速变化的代码---->断点调试 放慢例子3：对于动态快速变化的显示现象 ------->手机拍视频 + virtualbud一帧帧放慢 放慢例子4：基于1和3 ---->现象的时间序列 与 log的时间序列 一一对应了！！！！！ 基于3，可以做： 现象的时间序列----->如果足够细，可以预测每个现象变化的时刻点（无法精准）（从而预测每段现象的时间段！！！！） 例子： 问题描述：commonDialog在销毁的时候很快闪了一下（就像闪屏一样） 规定 ，记忆：永远不要用模糊性词语，欺骗人，更欺骗自己！！！ --->要求精准描述，才发现自己的问题，根本答不上来，什么叫闪了一下？？？？？？完全是忽悠人的词！！！！！ ----->快速变化，必须用拍视频放慢----->从而才有精准描述：Dialog先消失（1、销毁时刻点），然后隔了50ms后，又出现了（2、再次显现时刻点）又隔了10ms，又消失（3、又消失时刻点） 比起正常流程，多了2和3时刻 TODO：上面的例子，已经分析到了各个现象时间 + log是正常的 ---->可我为什么没有想到这时就可以断定一部有问题？？？？ 逻辑链条断了？？？ 4.8. 永远不要用模糊性词语， 欺骗人，更欺骗自己----->时刻要有感性词(模糊词) + 理性语句 感性词用于理解与记忆《------->理性语句，用于精确描述，翻译感性词 规定： 任何时候，都要有 感性+理性 ------------>尤其感性词，绝不允许感性词单独存在！！！ ​ 感性词 容易骗自己。。。。。。。理性语句又不够抽象，不能记忆 例子1: 数学：极限、无线逼近 《--------->ε，无论正整数N为多少，都存在某个n>N，使得|xn-a|≥ε 语言 例子2: 计算机：dialog闪一下 《----------->隐藏后，50ms又显示，又过了10ms隐藏了 4.9. 思考问题，一定要闭上眼睛 1、换脑子 2、 留在脑子里的是本质 3、 眼睛传入的信息，会障碍人 记忆与理解，也要闭上眼睛。。想图像（避免注意力停留在文字上） 4.10. 答案永远在代码之外 1、一个线程可以有几个Looper？可以有几个Handler？ 从模型角度： Looper.looper() 是驱动整个线程运行的 拉磨驴----> 自然，只有一个 ​ Handler是对外接口，send.msg和处理msg，自然，可以有多个 从代码角度：Looper.prepare()创建Looper之前，会判断当前线程的Looper是不是存在，存在会抛异常 --------> 所以，问题的深层次答案，只能从模型中得出（代码只能给出浅显的答案） 4.11. 代码脑中简化技巧 4.11.1. 0层综述 解决混乱的方法就是，化简。----》找出主次 上面画图、0层都是化简 化简有多简单，决定领悟有多深刻。 化简有多简单，决定能hold得住多大代码量 规定： 看源码，第一件事情，就是超级化简、之后大化简（超级化简弄懂后）、化简（大化简弄懂后）、不化简 -----> 大流程遵守上述、小流程遵守上述、函数级（行数多的）也要遵守上述 为啥要化简？1层剖析： 1、纵向：点击代码跳转过多，脑子内存不够用！！！！！！！堆栈溢出 ----》自然，另一种方法：增加脑子内存，截图 2、横向：脑子里的类过多，脑子内存不够用 ----》自然，另一种方法：增加脑子内存，截图 3、横向关联：一个函数里，四五百行，if else 嵌套过深刻, 造成逻辑过于复杂 -----》 挑选重要的if else 分支，那如何挑选重要的呢？ 4.11.2. 记忆之房间： 例子： //SystemServer.java // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg: ATMS ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( // cg: AMS mSystemServiceManager, atm); SystemServer.java 房间中, 有两个人 mSystemServiceManager和Lifecycle 4.11.3. 化简之框架：逻辑上舍弃已知框架 总结框架，桥梁 ---------> 见 《代码框架的收集》 ---------> 已知框架，桥梁，作为化简工具。 高低软架构----》 如何索引，如何添加新接口 4.11.4. 化简之 大概就是、大部分情况就是 即，把握主要： //viewGroup.java protected int getChildDrawingOrder(int childCount, int drawingPosition) { return drawingPosition; } 该方法，只有少数子类复写了，所以认为，大部分情况，返回值就是输入值 ---> 忽略掉小量 4.11.5. 化简之包裹 简化之包裹（主次之包裹），那么内核是。。。为什么包裹，要一层皮 4.11.6. 化简之内部类（次要类）： 内部类是次要结构，可以被简化掉 逻辑上，内部类是外部类的一部分，调用内部类，就认为是调用外部类。 比如： // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg：ActivityTaskManagerService ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( mSystemServiceManager, atm); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // cg：PowerManagerService AMS和ATMS通过 Lifecycle（SystemService） 传参给 SystemServiceManager PMS 传的是本身 PowerManagerService（SystemService） ----》 本质上，两者是一样的，因为 Lifecycle是内部类，即等同于外部类。 Lifecycle抽出了 生命周期相关的方法（onStart），感觉更集中 4.11.7. 化简之内部类2（解决java单继承问题）： java只能单继承，如何在功能上实现多继承呢？ 4.11.8. 化简之同胞类 内部类在逻辑上，可以认为是一个类 功能相同的同包类 可以认为都是一个核心类（核心类拆出来的：比如：ATMS、栈管理、生命周期同步器.........等等，脑子中都认为是AMS，见小了逻辑链 自然，持有关系，如果功能相近，认为是一个类 ------> 减小逻辑链 4.11.9. 函数化简之 信息流 如何找函数中核心代码？ 思想：高亮重要入参，重要入参流淌的代码就是重要代码。 因为核心代码就两三行，这样看代码就省事多了 例子： 比如InputMethodManager.startInputInner() 方法，总共两百行 -------》 softInputMode表征IMS的一个重要参数 -------》 核心必然是mService.startInputOrWindowGainedFocus() 一个推论？两个核心函数之间，变量是怎么演变的？？ 优点（使用场景）： 快速找到主要调用栈 缺点：忽略的太多，比如if条件等 4.11.10. 函数化简之 return 可以找到绝对的主干，而且是从上至下找（优）： （调用栈是从下往上） EX1: //ActivityStarter.java private int startActivity(final ActivityRecord r, ActivityRecord sourceRecord, IVoiceInteractionSession voiceSession, IVoiceInteractor voiceInteractor, int startFlags, boolean doResume, ActivityOptions options, TaskRecord inTask, ActivityRecord[] outActivity, boolean restrictedBgActivity) { int result = START_CANCELED; final ActivityStack startedActivityStack; try { mService.mWindowManager.deferSurfaceLayout(); result = startActivityUnchecked(r, sourceRecord, voiceSession, voiceInteractor, // 【1】cg: startFlags, doResume, options, inTask, outActivity, restrictedBgActivity); } finally { ........... return result; //【2】 } 从return点的result，跟踪result，找到赋值点，就是主干 4.11.11. 化简之透传（可大量化简） 透传的，逻辑上直接可以忽略掉 因为核心代码只有一两行，那么：90%的代码都是透传，都可以从逻辑上删掉 记忆与关注点： 非透传的核心代码 + 核心代码的外面一层层洋葱皮（判空、其他分支） -规定。技巧：透传函数不能注释齐功能，只能注释 // 透传 只有扎到根，才是非透传代码 EX1: 比如 startSystemServer、forkSystemServer 都是透传，只能注明 // 透传 4.11.12. 化简之合理性（围绕目标的） 适用范围： 这一条，适合理解、记忆软件的整体架构 延拓，记忆、理解任何流程性的东西都合适 ----> 天生适合记忆0层 纵向流程 步骤： 目标（目的）功能是啥？这个对于软件来说，一般是明确的 关注目标， 给出存在合理性、时序合理性 -----》 便可以删除了，仅仅留下目标 这个合理性，本质上 是路径（实现手段），便是代码流程 EX1: 炒菜 流程：不需要记忆去买菜（买菜之前还去拿钱、拿钱后还对比了与网上菜贵还是便宜）、买酱油、砍价、回来的路上还买了锅 炒菜还查了教程、洗菜、切菜、炒菜五分钟、然后加水............. -----》所以，炒菜流程远比软件流程复杂的多 你是如何记炒菜的，你就应该如何记忆代码流程： 1、我没有记忆流程，一点也没有 2、提到炒菜，我的第一印象（目标）就是 菜在锅里炒 3、其他的都是 合理性推出来的 （这是人的天性，只是面对代码，迷失了本性） EX2: 图：startApp.eddx 总结： 化简：init进程与zygote是一样的，一个拉起cpp的服务进程，一个孵化Java的进程 ---> zygote可删 化简之合理性：整张图，目标就是启动native和java的服务 ​ 自然：先启动native服务，之后java ​ 自然： 启动native众多服务之前，自然要先启动serverManager来管理 ---> ~~serverManager可删 ​ 自然：启动java 服务之前，自然要 树立起java-native的墙jvm、搭建好梯子jni ----> ~~Runtime 自然，可删 ​ 自然：zygote只是为了 fork java服务进程而存在的 ---> ~~zygote可以删掉 总之： 1、启动自下而上；调用，自上而下（最终内核驱动，自然） 2、只需要记：整张图，目标就是启动native和java的服务。其他的都可以删了（是合理性下的必然）。 4.11.13. 化简之目标 永远不要按照调用栈 或者 时间顺序 去理解，尤其是记忆代码流程 而是 先想着核心点（一行代码、一个功能结果），反推其他辅助流程（这才是真正的理解，不得不在里面） ------》这和 合理性 是一个思想 比如：视频11 activity启动流程 ---》 重新看 4.11.14. 化简之if else 一般情况下，if else下是两个对等的分支，只要看一个就可以！！！ 4.11.15. 化简之名词 IMM是InputMethodManager化简。不要小看名词化简：方便搜索；且方便记忆 4.11.16. 化简之类比 核心：理解与记忆时，找寻已有的东西类比 。书写时，亦如此 禁止用Y的类名，为啥，因为类名这种情况下不重要了，没必要用两套。基于A来记忆Y的。 Y_IMS 4.11.17. 化简之 减少逻辑调用链 如何减少? 1、多个函数调用,只关注一行代码 (基本上是底层函数的) 2、回看最外层函数,一行代码逻辑挂到最外层函数 3、关注点:入口---关键函数,链接 规定：强制删减 ? 4.11.18. 如何识别模块的主类： 4.11.19. 如何识别类的主方法: 即这个类的主要职责： 1、横向看看对外函数: h文件/public 接口(无法区分主次要) 2、索引属性, 属性做了哪些事情?------>牵强,属性太多,用处太多 3、看被谁持有。在持有的类中,索引改属性,看属性生命周期图谱中,怎么用的这个类 上层类主要流程怎么用这个类 4、类之间明显存在一对多的情况 规定:画类图,只允许添加关键属性、关键方法 但:如何识别一个类的关键属性,关键方法呢------>用于画图, 用于理解和记忆 1、次要属性之透传: 横向索引属性, 只有透传------>排除掉（这也是逻辑化简的方法） 2、主要方法:一个属性创建地方, 最终传递到的地方(该类的主要属性) 4.11.20. 化简之解耦思想 解耦方法的应用场景: 1、对于不理解的东西, 先记忆为框架能力, 后面再弄懂。 2、对于复杂的耦合问题（AB相互影响），假装一部分是正确的、 已经验证过了的框架, 先记忆。等其他的弄明白了,再来理解框架原理。 举例子：看代码的时候，遇到AIDL架构，链接直接用 AIDL.stub，先忽略背后的架构 -解耦 延拓: frame+ 链接-的记忆, 所以，记忆本身就是解耦 ​ 0层 ----> 1层局部放大, 本身就是解耦。 举例子：土木结构的放大、代码结构 0层-1层的放大 解耦的根本思想就是把两个相关联的问题，强行拆解成不相关的，一一击破; 解耦的具体办法，1、就是先假定（假定没有关系，假定是正确的） 2、解耦的最后，一定要回到这个假定上来，考虑这个假定的正确性 举例子：力学中很常见，比如10N的力推动一个 三角结构：A和B之间一定是相互影响的（力和位移） ----------> 解耦具体办法：先假设AB没有关系，A有一个位移；B有一个位移 后面再考虑关系： A的位移 = -B的位移 4.11.21. 化简之设计模式 很多代码为啥这样写，就是设计模式规定死了的 4.11.22. 化简之 功能逻辑 驱动 函数记忆 记忆也如此： 以功能，驱动函数（不能反过来） -注意力一定在功能上，不是在函数和类上。 比如： Activity起来之后（window也准备好了），那么如何与view绑定 -----》setContentView 不是去记忆 setContentView，反推绑定关系 写文章也是如此。。。。各个章节标题永远都是 功能点，而不是 setContentView这种函数 比如： Activity绑定viewTree，setContentView 4.11.23. 化简之按功能点拆解（写技术文章方法） 按功能点去拆解，小功能点单独列一节 -------》 原因：1、 因为一个功能点的内部，在逻辑上天然 链接的 ​ 2、防止小功能点，阻碍主要流程的 思考、书写、画图 例： handler机制，主要功能： 至于：次要功能 when、epollwait详细在另外章节里讲、在另外的图里画！！！！！ TODO： 看代码、思考也是如此；；；；说话更是如此 4.11.24. 化简之 按照变量抽离 按照变量来抽离 按照变量抽离------变量代表功能点，实际上是按照功能抽离 4.11.25. 化简之大流程 起点----目标反推法： 1、其他函数都是次要的，都理解为透传 ---->逻辑上 删除所有 调用链 2、同函数下，其他代码都是 为 核心代码服务的(逻辑上可以推断出来，不得不的) --->可以删除 ----> 逻辑上删除 -规定： 1、直接保留核心代码，删除其他所有 ---》 逻辑上、记忆上、画图上 2、以 核心代码替代 最外层函数 来记忆 ​ 写技术文章时，以核心代码 替代 最外层函数 作为 标题 原因：最外层函数 太空，而且做了很多件事情 突出核心的话，其他的可以逻辑推导 -总结，起点----目标反推法： 1、一个大流程，永远只有一行代码是核心代码 ------》目标 ​ 用文字描述，永远不超过十个字 2、其他代码都逻辑上删除。要用的时候反推，基于起点与目标 TODO: 一些推论： 按照时间线记忆， 流程性东西，害死人！！！！ 方法优点： 1、记忆量就一行，十几个字 2、以始为终：一切自然。否则是看不懂代码的 3、说到一个大流程，脑子第一时刻就知道这个流程主要做了啥。不会陷入细节 4、记忆长久 例子： 我以 runSelectLoop作为章节标题，因为 runSelectLoop是fork最外层函数 ------》很有问题，长时间只记得looper，不知道looper里面做了啥 但是突出核心 fork就不一样 ----》记得fork，逻辑上必然以后死循环Looper读取消息， 必然有fork之前，参数解析 必然有fork之后，基础建设 runtime和binder驱动 最后的目的，也是逻辑上必然： 反射主线程的main函数 4.11.26. 化简之小函数 也用 起点----目标反推法 4.11.27. 化简之函数调用栈Tree 我们可以画全量调用栈图：比如图形的 ----》 当做字典 但是记忆与理解： 1、记忆关键大流程，作为锚点（一定要足够大，足够关键）2、基于锚点，记忆其他关键函数（即核心代码） 3、逻辑上删除所有其他函数调用 ----> 总结，以上是对调用栈Tree的化简 4.11.28. 化简之忽略 handler 知道 跨线程，忽略 handler 转换 尤其是Binder线程的转换 4.11.29. 化简工具 之BookMarks （1）保存一份固定不变的源码，不更新 （2）重要的纵向流程中，关键分支、核心函数，用BookMarks标记 -------> 作为记忆的锚点、也是快速查询的锚点、经常复习的锚点 补充： breakpoint和BookMarks的点不一样： 前者尽量在边界处、最底层------> 方便得到完整得调用栈 后者 在关键函数和关键分支处 -----> 锚点处 BookMarks 好处在于 锚的好处： 1、快速查找 2、利用它支撑起整个框架 4.11.30. 化简之持有 持有一个类，可以认为是一个类的扩展 前提： 两个类的名字很相似（因为还持有其他） 比如： AppWindowToken 持有 IApplicationToken token 所以 AppWindowToken 扩展了 IApplicationToken 4.11.31. 化简之new bing 让chatGpt给你： 1、先给出模块框架 2、再给出主要功能点 3、指出沿着功能点的关键函数 4、函数每一行代码的解释 4.11.32. 化简之 设置的值 C语言的阅读： 设置（挂表）与运行 共同点： 1、找一个变量（指针）来源，会有栈 ----》 需要记忆 这是经常用的，脑子内存不够用了？有啥办法呢----》 截图屏幕、txt作为缓冲 2、信息流 4.11.33. 跳转化简之AIDL 全局搜II........... IInputMethodPrivilegedOperations ops = mOps.getAndWarnIfNull() 要找下游跨进程的调用（即定义处）: 搜IInputMethodPrivilegedOperations： extends IInputMethodPrivilegedOperations.Stub 4.12. 秒解技巧 4.13. 常见代码框架 4.13.1. TODO: 为什么框架是这个样子？何时要用这个框架？ 很多时候，看完代码，即使理解了其调用的结构，也不明白其中框架 -------》不明白为什么框架是这个样子？ 如何解决这一类问题呢？ -即：回答不出来，不得不！！！！ 4.13.2. 解决JAVA不能多继承问题 java语言只能单继承，如何支持多继承呢? 方法：通过内部类 继承另一个 。因为：内部类，等同于外部类。 例子: AMS与其内部类lifecycle extends SystemServer 实际上，希望AMS extends SystemServer , 但是 AMS 涉及到 与APP通信，所以也要继承 stub -不得不： AMS 涉及到 与APP通信，所以要继承 stub。也要继承 SystemService 。 ----> 涉及到多继承，所以，只能取一个。 EX1：AMS extends stub， 内部类Lifecycle extends SystemService, EX2，也可以反过来：PowerManagerService extends SystemService，其内部类继承 stub 4.14. 方法集key (清单) --—>常看、内化 1、正反角度 2、信息流（本质） 跳转 3、不得不 （最次：很可能）---->然后拦截 4、动态调试万能方法：trace，搜索所有类((已知类的时候) + 所有方法 5、简化demo--->唯一性 6、放慢 ：放到最慢看 --->放到次慢看 --->放到快看 7、方法： 对比、差 好的与不好的 8、动态断点调试方法： 修改-----夸张、弄坏、抛异常、激化矛盾。 9、log方法：绑定 10、方法：步步推进 11、断点调试：动态一般方法 ---->很容易走岔，得一行行调试 纲要性的东西，每天看 迁移： 在不同的事物上，迁移推广相同的机制。与比喻类似，但比喻是已知存在的两个物体，迁移是一个OK，另一个待迁移。。。。。。比如：嗑瓜子理论，迁移到学习上 13、本质 14、自然法则 技巧：规定，对于技巧集、本质集，剥离出原文，经常单独复习 自信（说话感觉离两米） 精力十足。管理 假装。1、以假装是主管，以主管的视角看问题，说话，解决问题 2、模仿技术达人所做的事情。所呈现出的总结 知识立体化。多个角度 代码技巧： 对于经常要看 + 稳定不变的源码，可以在代码中注释关键分支和核心函数。比如aosp源码。为什么要这样做？ 1、因为你要看千百遍的aosp，下一次看，一定要站在前一次的肩膀上。否则浪费大量精力！！！！！！ 2、代码最垃圾的地方就是 没有重点，通过注释标记重点、核心代码、关键分支 框架，桥0梁 化简 观察角度： 触发点（是一个锚点）------从调用栈能获得 观察角度： 0层结构、核心结构（对应关键函数） 规定：为了体现主次：对主要调用栈， 标注： cheduleTransaction(clientTransaction);// main process 比喻 5w法 洞察力（观察人、观察事务，观察知识） 分层思想。。。精髓在于：隔层之间，不能有交集。分层看待，结构分层 搭积木思想。。。。。积木架构图+木块原理图（更重要） 帧+链接。。。链接，一定要以逻辑为链接。如果以记忆为链接，很容易忘，而且很难记忆 依附与链接：窗口级的。。。 闭眼睛 读大师的事迹、文章 解耦思想：先假装。。回头考虑假装的东西 过河弃筏思想 思想上，已经过河，就要弃筏（负担） 例子：架构是桥梁，过了河，就要放弃？？？？ 记忆方法之 扫词（单词、知识点、题目）--- > 对于大量知识点的方法 记忆方法之：逻辑链、不得不 一句话总结（最强简化）。1、锚点：一句话是 无招 ，一切演化的锚点 2、检验标准：真传一句话 所以，你要是不能总结到一句话。那么你没有真正理解 化简一切（减法）: 通过链接一切，做到极致化简 大方向 延拓、推广 优秀实践 心置一处，身置一处 写文字性东西，给出关键词。比如：技巧层面，理解层面，功能层面，本质： 从.....角度，例子 ​ ​ 穿针引线，串起来 层 提纲文章：如何写复杂技术文章？ ----> 用一整篇文章，来做提纲，说明引用关系： http://gityuan.com/2015/10/31/binder-prepare/ 背后是啥：干任何事情，看到任何事情，都想一下背后是啥 图解一切（理解之后的事情，便于记忆+整体结构的理解） 降低难度---否则会痛苦。例子：技术博客看不懂，看视频 看评论区 按功能拆解 可复制：模板可复制、搭建环境流程可复制、知识点可复制 ---> 任何能力，做到可复制，尤其容易复制 ​ 可复制之应用：免安装版本 (就是 安装后copy的版本) 免安装版本，好处在于：----> 基于可复制、可迁移思想 1、持久化-----独立于系统（即使系统重装） 2、最关键的是设置，可以持久化。优点： 不同电脑无需重新配置 规定： 1、免安装版本库 需要及时更新。对本地做了设置，要及时更新到 免安装版本库里 2、对于 安装复杂 或 配置复杂 的软件，规定必须 同步到免安装库里 规定： 有些软件如果做不到免安装，但是设置复杂 ----> 尽量把设置导出来，做持久化 学习上建立正反馈机制：成瘾的根本原因是：有一套反馈机制在里面。。。。例子，写技术文章，写到所有知识点，都是不得不的逻辑链接（不存在记忆链接时）-----> 好文章；是一个大奖励；超越了所有人；幻想 化简之精力管理： 最简单的，才是最有效的(也才是最节省精力的) 方法之闭眼： https://www.campzhe.com/archives/1440 我闭上眼睛，目的是为了看 给出关注点 清单：避免犯错的利器。例子：方法集、交付checkList、购物清单 笔记：1、给大脑减压的工具 2、达到可复制的目的 -----> 大脑永远留给用来思考与理解，记忆不应该是大脑做的事情！！！！！！在思考的过程中，人的大脑其实一边维持记忆，一边进行分析，两面开战。而笔记，能够释放掉大脑记忆所占用的精力，专注思考。我看见，优秀的思考者，往往善于使用笔记本、白纸和白板。摘自： https://www.campzhe.com/archives/551 结构化：思考更全面&表达更清晰。EX： 树状图 及时激励： 比如 思想世界中，工具的个数 兴奋点：又得到了一个思想工具 commit方法：任何事情，过了一个阶段要commit，像git一样。人生也是如此，基于上一个commit，做下一个 ------》 如果两个阶段之间没有传承，那你肯定走不深 合理性要求(设计合理性、存在合理性)：对于代码架构： 解释每个步骤的合理性，如果解释的很合乎自然, 就不用记忆力, 靠逻辑、靠自然 生活化模型 ----> 任何知识点都可以，大利器 时间利用方法：并行化。但是要警惕，不能切换太多，消耗精力。主要思考（学习、工作） 与 耗时无需操作过程（下载、docker 加载jar等）并行化 夜间运行：人要多休息，计算机不要休息 主次应用之主要路径：考虑软件性能要在主要（高频）路径上。不是关键路径上 学习要非常重视纵向：1、入门可以沿着一条线先熟悉 2、能串起来很多知识点！！！（否则，知识是零散的） 旋涡中心 + 链接 要多角度： 比如回答问题：1、从模型角度（本质） 2、从代码角度 眼睛是障碍、文字也是：文字障碍事物表面、眼睛障碍事物本质 ----------> 规定：看了文字(尤其核心知识点)，就眼睛，在脑袋里想 。目的: 消灭文字！ 理解、行文工具：出发---目标----不得不 对于传递，文字是竹筏 对于进步，文字是障碍 问题、知识点，睡醒前想、洗澡想、吃饭想 -----> 为什么要这样做？ 对境生迷 ，所以只能离开境 这一点有个问题，违背了活在当下 洗脑：每天反复给自己洗脑。我爱代码架构，我爱原理。我爱控场的感觉 数学是一种修身养性的方式-------柳智宇。。。。。。代码也应如是（虽然差很多） 大脑最害怕的就是凌乱。比如：1、有多处记忆点，记忆点之间没有任何联系（办法：链接和锚点） 2、介绍AMS的内容，分散到不同的技术文章里 （解决办法：一个专门文章AMS，然后引用）3、 0层（模型、记忆的锚点）---》1层（具体业务场景、面试要回答一层内容，比如Activity切换时生命周期）----》 N层，技术细节 ---》代码 ---》相关面试问题（衡量标准、反馈） 给出观察主干的固定角度。 ----》1、观察枝叶。越来越乱 2、对一类事物有固定角度，那么 对新事物分析，就完善了。比如，一个新的设计模式 角度： 核心类做了什么（属性+方法） ，更重要的是，核心模块做了什么（模块的接口） 技巧： 认识 记忆核心类的主要功能的方法： 把核心类的 主要功能 归结到其属性，记忆其属性（与周边的关系） ----》反推类的功能，自然无需记忆 例子： TODO: 认识核心类可以吗？ 4.14.1. 仅限于代码的方法 list 代码分析的三角度：1、运行态（内存） 2、文件系统（编译后在真机中的结果、可执行文件） 3、源码 进程视角、模块视角 不要使用无意义的名词、术语：比如0号进程，鬼知道0号进程干啥的，名字至少要体现本质，就像给小孩纸起名字一样，要有所寓意 技术文章的引用：为了链接更聚焦，规定： 不同技术文章之间的引用，只能引用总结部分。 4.14.2. 生活 走路在练功、吃饭也在练功 走路在当下（冥想）、吃饭也在当下（冥想） 4.14.3. 文章\\文字 -无提示，不写字：任何文字、文章，必须要加 提示词 EX: 技术文章目录，要呈现代码架构 不能让文章目录，破坏 代码架构 比如： window、WMS是一个级别的东西 ​ view只是window的一部分 填充，所以： 1、不能和window、WMS一个目录级别 2、如果想要 详细写view, 当前文章插桩。链接另一篇view文章 ​ --------》 跟搭积木一模一样：（1）不要破坏整体结构 （2）要详细了解的，另起一个视角 化简 不仅代码需要化简才能记忆，生活需要化简 文章需要化简。小到一句话也要化简，规定，技术文字写法： 规定：主要动作五六个字说完。（其他内容，加括号补充说明） 注意： 这个技巧，很像英语语言 5. 格式 规定，记忆：永远不要用模糊性词语，欺骗人，更欺骗自己！！！ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/HowWritecode.html":{"url":"coding/Andriod/HowWritecode.html","title":"How Writecode","keywords":"","body":"1. 一些原则1.1. 0层：一点点思想1.2. 1层1.2.1. 代码一点点增加（然后验证）1.2.2. git commit一点点1.2.3. 写代码第一步：一个干净的环境1.2.4. 能编译OK，极大程度意味着可以运行1.2.5. 修改bug，尽量限制范围1.2.6. 做好备份TreeviewCopyright © aleen42 all right reserved, powered by aleen42 一些原则 0层：一点点思想 1层 代码一点点增加（然后验证） git commit一点点 写代码第一步：一个干净的环境 能编译OK，极大程度意味着可以运行 修改bug，尽量限制范围 做好备份 1. 一些原则 1.1. 0层：一点点思想 为什么会这样？因为代码的易错性造成的，一个符号都就会造成大问题 ---------> 对于易错的东西，最好的办法，就是一点点 1.2. 1层 1.2.1. 代码一点点增加（然后验证） 极限：每次只增加一行，验证一行........ 例子： 写反射的时候，很容易出错 1.2.2. git commit一点点 每验证好一个小功能，前进一小步，commit一次，且分开 1.2.3. 写代码第一步：一个干净的环境 一个可以debug的环境 1.2.4. 能编译OK，极大程度意味着可以运行 为什么呢？因为编译是协议 ，协议即通顺，即运行 1.2.5. 修改bug，尽量限制范围 if (严格条件) { //修改 } 条件尽量严格，限制不影响其他场景 1.2.6. 做好备份 最忌讳的是重复劳动，所以代码备份 ,方式： commit、提一个链接 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/InitSystem.html":{"url":"coding/Andriod/InitSystem.html","title":"Init System","keywords":"","body":"1. 目录2. 系统启动流程（纵向主线）2.1. 0层图2.2. 各个层的简介2.2.1. Loader层：2.2.2. Linux内核层2.2.3. 硬件抽象层 (HAL)2.2.4. Android Runtime & 系统库2.2.5. Framework层2.2.6. App层2.2.7. 墙 Syscall && JNI2.2.8. 进程关系2.3. 各个进程简介2.4. -------流程start，基于0层-------2.5. 内核加载2.6. 0号进程fork出init进程2.7. init进程解析init.rc文件2.7.1. init进程解析init.rc文件，拉起各种进程2.7.2. 各个进程被拉起的时序2.8. serviceManager启动流程2.9. zygote进程启动native main2.9.1. runtime的启动runtime.start2.9.2. 虚拟机的启动startVm(&mJavaVM, &env)2.9.3. startReg(env) 注册JNI函数2.10. ZygoteInit.java main 世界2.10.1. 加载资源preload()2.10.2. forkSystemServer2.10.3. ZygoteInit.runSelectLoop2.11. SystemServer进程启动2.11.1. 向下分析核心代码mSystemServiceManager.startService2.11.2. publishBinderService 向Native注册Ibinder（核心）2.11.3. AMS new后，由AMS注册一堆进程相关服务2.11.4. AMS 让 zygote 创建 launcher进程2.12. -------流程end，基于0层------2.13. 基于0层，补充次要linux进程：2.14. 几大重要进程之间的通信2.15. 参考链接：2.16. 疑问2.17. 面试题:2.17.1. 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？2.17.2. Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？2.18. 参考TreeviewCopyright © aleen42 all right reserved, powered by aleen42 系统启动流程（纵向主线） 0层图 各个层的简介 Loader层： Linux内核层 硬件抽象层 (HAL) Android Runtime & 系统库 Framework层 App层 墙 Syscall && JNI 进程关系 各个进程简介 -------流程start，基于0层------- 内核加载 0号进程fork出init进程 init进程解析init.rc文件 init进程解析init.rc文件，拉起各种进程 各个进程被拉起的时序 serviceManager启动流程 zygote进程启动native main runtime的启动runtime.start 虚拟机的启动startVm(&mJavaVM, &env) startReg(env) 注册JNI函数 ZygoteInit.java main 世界 加载资源preload() forkSystemServer ZygoteInit.runSelectLoop SystemServer进程启动 向下分析核心代码mSystemServiceManager.startService publishBinderService 向Native注册Ibinder（核心） AMS new后，由AMS注册一堆进程相关服务 AMS 让 zygote 创建 launcher进程 -------流程end，基于0层------ 基于0层，补充次要linux进程： 几大重要进程之间的通信 参考链接： 疑问 面试题: 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？ Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？ 参考 1. 目录 [TOC] 2. 系统启动流程（纵向主线） 主线：开机 ----> 桌面（launcher + systemUI） 2.1. 0层图 图：startApp.eddx 总结： 化简：init进程与zygote是一样的，一个拉起cpp的服务进程，一个孵化Java的进程 ---> zygote可删 化简之合理性：整张图，目标就是启动native和java的服务 ​ 自然：先启动native服务，之后java ​ 自然： 启动native众多服务之前，自然要先启动serverManager来管理 ---> ~~serverManager可删 ​ 自然：启动java 服务之前，java-native的自然有语言墙、搭建好梯子jni ----> ~~Runtime 自然，可删 ​ 自然：zygote存在合理性：只是为了 fork java服务进程而存在的 ---> ~~zygote可以删掉 总之： 1、启动自下而上；调用，自上而下（最终内核驱动，自然） 2、只需要记：整张图，目标就是启动native和java的服务。其他的都可以删了（是合理性下的必然）。 盘古开天辟地、女娲造人、女人生孩子模型： 人（类图），事（流程图）： 盘古，pid=0 内核进程： 自然的： 天地未开，宇宙混沌如鸡蛋（即kernel）一片----》 即当时只有kernel，自然 目标：开天辟地 流程： ​ （0）触发点：TODO ​ （1） 盘古 处于混沌中，即 pid=0 内核进程在内核中，自然 ​ （2） 盘古开天辟地： 辟地-------- pid=0 内核进程， 加载驱动，这是设备运行的基础（即地），自然 ​ 开天-------pid=0 内核进程，孵化了第一个 用户空间 进程init(pid=1) 女娲 ，自然 宇宙混沌：kernel 自然，里面有盘古 天与地之间，人间：用户空间 造人的 女娲： 自然：init进程 pid=1。。。。。。为啥叫init进程？ 第一个来到天地间的，来 创造人的（init的），自然 目标：造人 流程： ​ （0）触发点：女娲是被盘古叫来 创世的，自然。 女娲呆在 院子里（native） 创造人 ​ （1）根据天书，因为女娲目标是造人，那么先有管理者。首先 创建了一个管理天地的 玉皇大帝： init进程 解析 init.rc，首先创建了1 ServiceManager ​ （2）根据天书，因为目标是造人，所以先创建了人的眼睛（显示服务进程surfaceFlinger）、创建人的耳朵（Media Server） ​ （3）根据天书，因为目标是造人，最后在院子里（native）捏了一个 女人（zygote native进程） init.rc: 天书：如何创世的天书 玉皇大帝： ServiceManager， 自然的： 管理天地一切(java和native两个世界的所有服务)，比如2 世间一切视觉的显示（显示服务进程），比如3 一切声音（媒体服务进程），眼（显示）、耳（声音）、鼻、舌、身（触觉：inputManagerService）、意； 自然 女人：zygote native进程 天然的： 女人，天生就是 生孩子的（孵化java进程的），自然 目标： 生一个完整的家庭 流程： ​ （1） 触发点：女娲在院子里造出了女人 ​ （2）女人想要从院内跑到院外，自然： 院内的女人 要搬梯子 ：zygote native进程 安卓的Runtime（包括jvm、注册jni） ​ （3）女人通过梯子 翻墙。自然：zygote native进程 通过 反射 调用了 zygoteInit.java的main函数 ​ （4）翻墙到了院外，便是院外的女人： zygote运行在java环境中了 ​ （5）院外有大量的自然资源，自然。女人 先弄了一些 花草树叶 给自己穿衣：加载类、加载资源color、库so到jvm ​ （6）弄好了自己，拿出来自己一个肋骨，变成了自己的丈夫： SystemSever。。。注意：只有生 丈夫，是女人自己主动触发的；而其他孩子，都是别人让的 ​ （7）有了丈夫，怎么与丈夫之间联系呢？ 女人买了个 对讲机 ：起了一个socket 服务，一直循环，等待丈夫的消息 ​ 注意：不得不：女人只听丈夫的，自然： 女人只通过socket与丈夫交流 ​ 自然： 只有丈夫能让女人生孩子。孩子则不能直接让，需要告诉父亲，让妈妈生个弟弟，父亲再让女人生。 ​ 丈夫： SystemSever ​ 自然，他的作用是，给儿子们(APP)，提供服务： SystemSever给APP 提供核心服务 目标：丈夫有了，可是还没有孩子，生一个家庭对外的 接口人 流程： （1）触发点：女人 “生”了丈夫 （2）丈夫告诉女人，要生一个 家庭对外的 接口人，看客户有啥需求： 即AMS 让 zygote 创建 launcher进程 家庭对外的 接口人 ：launcher进程 ​ 根据 客户需要什么样的孩子，就让女人去生 院子里：native 院子外：java 墙：cpp与java的语言隔离 墙上的梯子： 安卓的Runtime、jni、jvm 一句话总结， 盘古开天辟地、女娲造人、女人生孩子模型： 记忆三个目标，忘记其他所有。 补充： 2、3、4，为啥是这个顺序？：自然女娲先 捏眼耳鼻舌身意，最后才捏了一个完整的人（此时Zygote就是可以调用surfaceFlinger等的） TODO: 上面模型的 文字描述，也是写文章的思路（即文字版的 类图和时序图）。待详细完善 TODO: 上面是通过联想模型记忆，如果 通过 不得不 来记忆呢？ 2.2. 各个层的简介 2.2.1. Loader层： Boot ROM: 当手机处于关机状态时，长按Power键开机，引导芯片开始从固化在ROM里的预设代码开始执行，然后加载引导程序到RAM； Boot Loader：这是启动Android系统之前的引导程序，主要是检查RAM，初始化硬件参数等功能。 2.2.2. Linux内核层 Android平台的基础是Linux内核，比如ART虚拟机最终调用底层Linux内核来执行功能，自然 启动Kernel的swapper进程(pid=0)：该进程又称为idle进程, 系统初始化过程Kernel由无到有开创的第一个进程, 用于初始化进程管理、内存管理，加载 驱动（Display、Camera、Binder）等相关工作，自然； 启动kthreadd进程（pid=2）：是Linux系统的内核进程，会创建内核工作线程kworkder，软中断线程ksoftirqd，thermal等内核守护进程。kthreadd进程是所有内核进程的鼻祖。----》TODO: 不懂 2.2.3. 硬件抽象层 (HAL) 硬件抽象层 (HAL) 提供标准接口，HAL包含多个库模块，其中每个模块都为特定类型的硬件组件实现一组接口，比如WIFI/蓝牙模块，当框架API请求访问设备硬件时，Android系统将为该硬件加载相应的库模块。 2.2.4. Android Runtime & 系统库 每个应用都在其自己的进程中运行，都有自己的虚拟机实例。ART通过执行DEX文件可在设备运行多个虚拟机，DEX文件是一种专为Android设计的字节码格式文件，经过优化，使用内存很少。ART主要功能包括：预先(AOT)和即时(JIT)编译，优化的垃圾回收(GC)，以及调试相关的支持。 这里的Native系统库主要包括init孵化来的用户空间的守护进程、HAL层以及开机动画等。启动init进程(pid=1),是Linux系统的用户进程，记忆：init进程是所有用户进程的鼻祖。 init进程会孵化出ueventd、logd、healthd、installd、adbd、lmkd等用户守护进程； init进程还启动servicemanager(binder服务管家)、bootanim(开机动画)等重要服务 init进程孵化出Zygote进程，Zygote进程是Android系统的第一个Java进程(即虚拟机进程)，Zygote是所有Java进程的父进程，Zygote进程本身是由init进程孵化而来的。 2.2.5. Framework层 Zygote进程，是由init进程通过解析init.rc文件后fork生成的，Zygote进程主要包含： 加载ZygoteInit类，注册Zygote Socket服务端套接字 加载虚拟机 提前加载类preloadClasses 提前加载资源preloadResouces System Server进程，是由Zygote进程fork而来，System Server是Zygote孵化的第一个进程，System Server负责启动和管理整个Java framework，包含ActivityManager，WindowManager，PackageManager，PowerManager等服务。 Media Server进程，是由init进程fork而来，负责启动和管理整个C++ framework，包含AudioFlinger，Camera Service等服务。 2.2.6. App层 Zygote进程孵化出的第一个App进程是Launcher，这是用户看到的桌面App； Zygote进程还会创建Browser，Phone，Email等App进程，每个App至少运行在一个进程上。 所有的App进程都是由Zygote进程fork生成的。 2.2.7. 墙 Syscall && JNI Native与Kernel之间有一层系统调用(SysCall)层，见Linux系统调用(Syscall)原理; Java层与Native(C/C++)层之间的纽带JNI，见Android JNI原理分析。 2.2.8. 进程关系 // ps -ef 显示用户空间进程 UID PID PPID C STIME TTY TIME CMD root 1 0 0 13:30:36 ? 00:00:02 init // 一号进程，父进程PPID 0号 ............... root 16 2 0 13:30:36 ? 00:00:04 [rcuc/1] ............... root 623 1 0 13:30:39 ? 00:00:09 zygote64 //Zygote 进程 root 624 1 0 13:30:39 ? 00:00:07 zygote ............... system 8951 623 0 14:10:30 ? 00:00:00 com.android.settings // 应用进程在 Zygote 进程 之后 u0_a81 9022 623 0 14:10:31 ? 00:00:00 com.android.dialer u0_a37 12510 623 0 13:41:05 ? 00:00:01 android.process.acore ps 显示进程号: init是1号进程（自然，其父进程PPID = 0号进程） 自然，0号进程属于 内核态，所以ps没有显示 Linux整个进程树形成：TODO Zygote 进程: 所有java进程(系统+APP都) 孵化机。自然，皇妃 Init 的可执行文件: x 可执行 ---》 对于cpp/java编译出来的，且可执行------> 自然，一定含main函数 2.3. 各个进程简介 2.4. -------流程start，基于0层------- 2.5. 内核加载 linux内核启动（再具体：），包括驱动加载，例如Binder驱动 2.6. 0号进程fork出init进程 开天辟地，第一个进程 0号进程（swapper），内核进程 驱动加载的流程 孵化出init进程 ----》用户空间的始祖进程（非内核进程，自然） 2.7. init进程解析init.rc文件 2.7.1. init进程解析init.rc文件，拉起各种进程 三角度： 1、从进程角度：基于0层图，init进程由0号进程孵化而来 自然 2、从文件角度：根目录下init文件执行 3、从源码角度： //system/core/init/init.cpp static void LoadBootScripts() { .......... if (bootscript.empty()) { parser.ParseConfig(\"/init.rc\"); // 解析init.rc if (!parser.ParseConfig(\"/system/etc/init\")) { late_import_paths.emplace_back(\"/system/etc/init\"); } if (!parser.ParseConfig(\"/product/etc/init\")) { late_import_paths.emplace_back(\"/product/etc/init\"); } if (!parser.ParseConfig(\"/product_services/etc/init\")) { late_import_paths.emplace_back(\"/product_services/etc/init\"); } if (!parser.ParseConfig(\"/odm/etc/init\")) { late_import_paths.emplace_back(\"/odm/etc/init\"); } if (!parser.ParseConfig(\"/vendor/etc/init\")) { late_import_paths.emplace_back(\"/vendor/etc/init\"); } init.rc 命令文件 : import /init.environ.rc // 给linux系统，设置了各种环境变量 import /init.usb.rc import /init.${ro.hardware}.rc import /vendor/etc/init/hw/init.${ro.hardware}.rc import /init.usb.configfs.rc import /init.${ro.zygote}.rc //import start zygote //【】启动zygote进程 start servicemanager //【】启动servicemanager // init.zygote64_32.rc // 【】定义了服务:zygote service zygote /system/bin/app_process64 -Xzygote /system/bin --zygote --start-system-server --socket-name=zygote //【1】 /system/bin/app_process64 // 【2】 --zygote // 【3】 --start-system-server 启动 SystemServer class main priority -20 user root // /说明以用户root身份运行，自然 group root readproc reserved_disk socket zygote stream 660 root system //【】 //socket关键字表示这个zygote进程需要一个名称为\"zygote\"的socket资源，这样，系统启动后，我们就可以在/dev/socket目录下看到有一个名为zygote的文件。这里定义的socket的类型为unix domain socket，它是用来作本地进程间通信用的 socket usap_pool_primary stream 660 root system onrestart write /sys/android_power/request_state wake onrestart write /sys/power/state on onrestart restart audioserver onrestart restart cameraserver onrestart restart media // 当zygote重启时,则会重启media ---> 背后的机制是啥，如何保证的？ onrestart restart netd onrestart restart wificond writepid /dev/cpuset/foreground/tasks // 同理 servicemanager // frameworks/native/cmds/servicemanager/servicemanager.rc service servicemanager /system/bin/servicemanager 具体如何启动？ TODO: 即 命令如何执行，如何生成新进程？ 由【1】可见，zygote进程 运行的可执行文件是 app_process64（原来名字就叫 app process 见 attach)） 【2】 对应代码： if (zygote) { runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote); 补充rc文件知识：TODO https://wenku.baidu.com/view/2955b4df740bf78a6529647d27284b73f24236c7.html?_wkts_=1670062987073&bdQuery=%E5%AE%89%E5%8D%93rc%E6%96%87%E4%BB%B6+%E6%A0%BC%E5%BC%8F android代码.rc文件结构解析 https://www.jb51.net/article/208558.htm Android ServiceManager的启动和工作原理 2.7.2. 各个进程被拉起的时序 记忆，大致顺序如下： ServiceManager是在各种Binder服务之前起来。自然，非常合理，因为要管理 Zygote是非常靠后的，自然，因为先native，最后进入java世界 验证： 可以通过进程pid得到验证 代码层面的验证：https://blog.csdn.net/u013463707/article/details/100926522?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100926522-blog-116968113.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-100926522-blog-116968113.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=1 1) early-init a) wait_for_coldboot_done b) property_init c) keychord_int d) console_init e) set_init_properties 2) init 3) late-init 4) early-fs 5) fs 6) post-fs f) property_service_init g) signal_init h) check_startup 7) early-boot 8) boot 9) service TODO: serviceManager启动流程、surfaceFling流程 2.8. serviceManager启动流程 2.9. zygote进程启动native main 三角度： 进程角度：zygote进程 ：java进程的始祖进程，自然 可执行文件角度： /system/bin/app_process64 ，自然，因为又叫 所以，源码角度：frameworks/base/cmds/app_process/app_main.cpp 三w： when： what： how： //frameworks/base/cmds/app_process/app_main.cpp //zygote进程入口 int main(int argc, char* const argv[]){ //zygote 是由init进程fork而来，init.rc文件中为zygote进程设置的启动参数如下 //argc = 4 //argv = [-Xzygote, /system/bin, --zygote, --start-system-server] AppRuntime runtime(argv[0]); //【1】 创建AndroidRuntime对象，没有启动 if (zygote) { runtime.start(\"com.android.internal.os.ZygoteInit\", args, zygote);//【2】runtime启动 } else if (className) { runtime.start(\"com.android.internal.os.RuntimeInit\", args, zygote); } else { fprintf(stderr, \"Error: no class name or --zygote supplied.\\n\"); app_usage(); LOG_ALWAYS_FATAL(\"app_process: no class name or --zygote supplied.\"); } } 【1】 创建AndroidRuntime对象，无他 【2】runtime启动，runtime包括哪些东西呢，见下 : （1）Dalvik虚拟机启动 （2）利用虚拟器，启动java的ZygoteInit 和 RuntimeInit 功能视角：TODO Zygote进程包含两个主要模块： 1. Socket服务端，该Socket服务端用于接收启动新的Dalvik进程命令。 2. Framework共享类及共享资源，当Zygote进程启动后，会装载一些共享类和资源，共享类是在preload-classes文件中定义的，共享资源是在preload-resources文件中定义。因为其他Dalvik进程是由Zygote进程孵化出来的，因此只要Zygote装载好了这些类和资源后，新的Dalvik进程就不需要在装载这些类和资源了，它们共享Zygote进程的资源和类。 原文链接：https://blog.csdn.net/yangwen123/article/details/17258023 2.9.1. runtime的启动runtime.start 三角度： 进程角度：zygote native进程中。不得不的，因为都是为java程序做准备工作的 可执行文件角度： /system/lib64/libandroid_runtime.so 所以，源码角度：frameworks/base/core/jni/AndroidRuntime.cpp //frameworks/base/core/jni/AndroidRuntime.cpp void AndroidRuntime::start(const char* className, const Vector& options, bool zygote) { JNIEnv* env; if (startVm(&mJavaVM, &env, zygote) != 0) { //【1】启动Dalvik Virtual Machine，拿到返回值mJavaVM和env return; } if (startReg(env) FindClass(\"java/lang/String\"); assert(stringClass != NULL); strArray = env->NewObjectArray(options.size() + 1, stringClass, NULL); assert(strArray != NULL); //创建字符串classNameStr //对于zygote进程： classNameStr = new String(\"com.android.internal.os.ZygoteInit\") //对于启动应用进程：classNameStr = new String(\"com.android.internal.os.RuntimeInit\") classNameStr = env->NewStringUTF(className); env->SetObjectArrayElement(strArray, 0, classNameStr); ............ char* slashClassName = toSlashClassName(className != NULL ? className : \"\"); jclass startClass = env->FindClass(slashClassName); if (startClass == NULL) { ............ } else { //找到ZygoteInit类的静态main方法的jMethodID jmethodID startMeth = env->GetStaticMethodID(startClass, \"main\", \"([Ljava/lang/String;)V\"); } else { env->CallStaticVoidMethod(startClass, startMeth, strArray);//【3】通过虚拟机调用java的 ZygoteInit的main方法，zygote进程就进入了java世界 } } //.......【4】........ } 【2】非常自然，只有在虚拟机启动完后，才能注册jni函数（native函数） 注意：【3】zygote主线程，贯通native与java世界。自然，在java侧没有结束（正常情况下，不会结束），不会走【4】 记忆：AndroidRuntime::start()中完成：即RunTime做了啥？四个任务 ①　startVm(&mJavaVM, &env) 启动虚拟机 。自然，必须第一个，java-native之间的墙 ②　onVmCreated(env) 虚拟机启动后的初始化 ③　startReg(env) 注册JNI函数。 自然，基于墙，架起梯子 ④　env->CallStaticVoidMethod(startClass, startMeth, strArray) 调用ZygoteInit类的main函数开创java世界。自然，架起梯子，翻过native，进入java世界大门 2.9.2. 虚拟机的启动startVm(&mJavaVM, &env) 见四任务 ，第一个任务 int AndroidRuntime::startVm(JavaVM** pJavaVM, JNIEnv** pEnv, bool zygote) { JavaVMInitArgs initArgs; ............各种参数的解析与初始化................ /* * Initialize the VM. * * The JavaVM* is essentially per-process, and the JNIEnv* is per-thread. * If this call succeeds, the VM is ready, and we can start issuing * JNI calls. */ if (JNI_CreateJavaVM(pJavaVM, pEnv, &initArgs) 【1】拿到env后（自然，native可以反射调用java方法），标志着javaVM已经初始化完毕了 JNI_CreateJavaVM 是c的函数，具体做了啥？ TODO 2.9.3. startReg(env) 注册JNI函数 见四任务 ，第三个任务 向虚拟机注册 jni函数(后面让java侧调用) 三角度： 进程角度：zygote native进程 。自然，因为要搭建 墙上的梯子 可执行文件角度： /system/lib64/libandroid_runtime.so 所以，源码角度：frameworks/base/core/jni/AndroidRuntime.cpp 三w： when：在虚拟机起来之后。自然，墙都没有，怎么搭建墙上的梯子？ what： how：不知道底层机制 int AndroidRuntime::startReg(JNIEnv* env) { /* * This hook causes all future threads created in this process to be * attached to the JavaVM. (This needs to go away in favor of JNI * Attach calls.) */ androidSetCreateThreadFunc((android_create_thread_fn) javaCreateThreadEtc); if (register_jni_procs(gRegJNI, NELEM(gRegJNI), env) PopLocalFrame(NULL); return -1; } env->PopLocalFrame(NULL); return 0; } // gRegJNI封装了各种注册函数,近两百个成员函数 static const RegJNIRec gRegJNI[] = { REG_JNI(register_com_android_internal_os_RuntimeInit), // 展开见下 REG_JNI(register_com_android_internal_os_ZygoteInit_nativeZygoteInit), REG_JNI(register_android_os_SystemClock), REG_JNI(register_android_util_EventLog), REG_JNI(register_android_util_Log), REG_JNI(register_android_util_MemoryIntArray), REG_JNI(register_android_util_PathParser), REG_JNI(register_android_util_StatsLog), REG_JNI(register_android_util_StatsLogInternal), REG_JNI(register_android_app_admin_SecurityLog), REG_JNI(register_android_content_AssetManager), REG_JNI(register_android_content_StringBlock), REG_JNI(register_android_content_XmlBlock), REG_JNI(register_android_content_res_ApkAssets), REG_JNI(register_android_text_AndroidCharacter), REG_JNI(register_android_text_Hyphenator), REG_JNI(register_android_view_InputDevice), REG_JNI(register_android_os_Binder), // REG_JNI(register_android_os_Parcel), // ................. 本质上，Oracle提供的注册API是：记忆： jniRegisterNativeMethods(env, java的类名，映射关系 数组) int register_com_android_internal_os_RuntimeInit(JNIEnv* env) { const JNINativeMethod methods[] = { //【1】 自然，映射关系为：java函数名string + java函数参数签名 ------》 native函数名 { \"nativeFinishInit\", \"()V\", (void*) com_android_internal_os_RuntimeInit_nativeFinishInit }, { \"nativeSetExitWithoutCleanup\", \"(Z)V\", (void*) com_android_internal_os_RuntimeInit_nativeSetExitWithoutCleanup }, }; return jniRegisterNativeMethods(env, \"com/android/internal/os/RuntimeInit\", methods, NELEM(methods)); } 那么，jniRegisterNativeMethods 机制原理是什么呢？TODO: 2.10. ZygoteInit.java main 世界 见四任务 ，第四个任务 三角度： 进程角度：zygote main进程 。自然，已经翻过墙，进入java世界 可执行文件角度： framework.jar(见/frameworks/base/Android.bp ) 所以，源码角度：/frameworks/base/core/java/com/android/internal/os/ZygoteInit.java 三w： when：在虚拟机起来之后。自然，墙都没有，怎么搭建墙上的梯子？ what： how：jni调的 public static void main(String argv[]) { // 【】参数argv，从信息流角度: rc文件里的参数 ，传给 native（TODO:native用来标志启动java zygote,d），之后native又传给java侧（用来标志启动system-server） try { boolean startSystemServer = false; String zygoteSocketName = \"zygote\"; String abiList = null; boolean enableLazyPreload = false; for (int i = 1; i 2.10.1. 加载资源preload() static void preload(TimingsTraceLog bootTimingsTraceLog) { preloadClasses(); //【1】预加载类资源到jvm里，比如：view、actvity、Service等7600个类 存于文件\"/system/etc/preloaded-classes\" preloadResources(); //【2】预加载资源，包含drawable和color资源 nativePreloadAppProcessHALs(); maybePreloadGraphicsDriver(); //【3】预加载\"android\",\"compiler_rt\",\"jnigraphics\"这3个共享库（通过System.loadLibrary()方法） preloadSharedLibraries(); preloadTextResources(); WebViewFactory.prepareWebViewInZygote(); } 【1】 类加载，最终采用反射机制 java的Class.forName()方法来加载。自然，必然是反射，因为给定的是字符串 类预加载的原因：所有APP进程共用一份类资源（注意，不是对象，还没实例化！） 理解，本质：类、普通的图片jpg资源、xml 本质并无差别** ---> 都是没有实例化的资源 去重思想: 提取重复的。放到 Zygote 进程里 ------》 注意：此时的jvm属于 Zygote进程，所以资源也在 Zygote进程。 zygote进程内加载了preload()方法中的所有资源，当需要fork新进程时，采用copy on write技术，如下： 参考： https://github.com/huanzhiyazi/articles/issues/25 ​ https://blog.51cto.com/u_15375308/5216330 深入理解 Android 内核设计思想（二）内存管理 copy on write 原则：所有的子进程与父进程默认都共享所有资源，父进程 fork 一个子进程之后，子进程只需要生成共享资源的引用即可。只有当子进程需要对某个资源进行写入时，才需要拷贝一份原资源，从而保证资源的独立性。 ----> 自然，好处是： 安全性上：保证共享资源的访问安全（每个java进程都加载资源也可以实现） 1、时间上：只有一个进程加载资源（无需每个java进程都去加载系统资源，加载流程很消耗时间） 2、空间上：只有一个进程内存持有资源。 推论：TODO: 验证 1、VM实例每个进程参数不一样，所以涉及修改，会copy一个VM实例 2、其他资源，尤其类资源，很可能就一份。 来自：https://blog.csdn.net/m0_37999066/article/details/127271879 TODO: Class.forName() 加载类资源到jvm 原理 从资源加载的角度，理解设计zygote的必要性(合理性)：主要需要一个共享资源的祖先 （去重思想的推论，时间上去重、空间上去重） 2.10.2. forkSystemServer 非常自然，加载完共用资源，然后启动 java进程。 // ZygoteInit.java private static boolean startSystemServer(String abiList, String socketName) { ... pid = Zygote.forkSystemServer( //【1】 透传 parsedArgs.uid, parsedArgs.gid, parsedArgs.gids, parsedArgs.debugFlags, null, parsedArgs.permittedCapabilities, parsedArgs.effectiveCapabilities); ... if (pid == 0) { if (hasSecondZygote(abiList)) { waitForSecondaryZygote(socketName); } handleSystemServerProcess(parsedArgs); //进入system_server进程 } return true; } 【1】 处， //Zygote.java int pid = nativeForkSystemServer( // 走native uid, gid, gids, runtimeFlags, rlimits, permittedCapabilities, effectiveCapabilities); 所以，更本质的，还是native去fork的 TODO: native侧： pid = fork() //最终系统调用 2.10.3. ZygoteInit.runSelectLoop 自然，创建完systemServer之后，Zygote线程进入Looper。随时待命，当接收到请求创建新进程请求时立即唤醒并执行相应工作。 TODO: Zygote采用高效的I/O多路复用机制，保证在没有客户端连接请求或数据处理时休眠，否则响应客户端的请求。 private static void runSelectLoop(String abiList) throws MethodAndArgsCaller { ArrayList fds = new ArrayList(); ArrayList peers = new ArrayList(); //sServerSocket是socket通信中的服务端，即zygote进程 fds.add(sServerSocket.getFileDescriptor()); peers.add(null); while (true) { StructPollfd[] pollFds = new StructPollfd[fds.size()]; for (int i = 0; i = 0; --i) { //采用I/O多路复用机制，当客户端发出 连接请求或者数据处理请求时，则执行continue if ((pollFds[i].revents & POLLIN) == 0) { continue; } if (i == 0) { //创建客户端连接 ZygoteConnection newPeer = acceptCommandPeer(abiList); peers.add(newPeer); fds.add(newPeer.getFileDesciptor()); } else { //处理客户端数据事务 boolean done = peers.get(i).runOnce(); if (done) { peers.remove(i); fds.remove(i); } } } } } 参考:http://gityuan.com/2016/02/01/android-booting/ 【1】 TODO: https://www.cnblogs.com/laosiji888/articles/5524067.html http://gityuan.com/2019/01/06/linux-epoll/ 源码解读epoll内核机制 http://gityuan.com/2019/01/05/linux-poll-select/ 源码解读poll/select内核机制 本质：socket服务端。 TODO: 总结安卓通信socket 2.11. SystemServer进程启动 参考： http://gityuan.com/2016/02/14/android-system-server/ https://www.jianshu.com/p/9912a556734f Android开机流程启动的系统服务以及功能介绍列表 问题：SystemServer如何被创建，如何执行的main？主要做了啥？ main流程，总共启动90多个系统服务：自然，太多了，需要一个管理类mSystemServiceManager SystemServer.java 房间中 // Start services. try { //cg: https://www.jianshu.com/p/9912a556734f startBootstrapServices(); // cg: Bootstrap 启动引导服务: AMS, PMS, powerMS, Lights, startCoreServices(); // cg: CoreService: BatteryService, webview startOtherServices(); // cg: Other: InputMS, CameraService, // 具体启动核心代码 ActivityTaskManagerService atm = mSystemServiceManager.startService( // cg: ATMS ActivityTaskManagerService.Lifecycle.class).getService(); mActivityManagerService = ActivityManagerService.Lifecycle.startService( // cg: AMS（注意AMS这里没有注册，在setSystemProcess中注册的） mSystemServiceManager, atm); mPowerManagerService = mSystemServiceManager.startService(PowerManagerService.class); // cg：PowerManagerService mSystemServiceManager.startService(\"com.google.android.clockwork.sidekick.SidekickService\"); //cg：直接通过 类名 反射 AMS和ATMS通过内部类 Lifecycle（SystemService） 传参给 SystemServiceManager PMS 传的是本身 PowerManagerService（SystemService） ----> 本质上， 1、两者是一样的，因为 Lifecycle是内部类，即等同于外部类。 Lifecycle抽出了 生命周期相关的方法（onStart），感觉更集中 2、既然一样，为啥要有不同写法？ -不得不： AMS 涉及到 与APP通信，所以要继承 stub。也要继承 SystemService 。 ----> 涉及到多继承，所以，只能取一个。 EX1：AMS extends stub， 内部类Lifecycle extends SystemService, EX2，也可以反过来：PowerManagerService extends SystemService，其内部类继承 stub Q: 设计上为什么要有SystemService？ A: 目的：让所有被管理者继承，传给manager，统一管理 --------》 或者说：SystemService 是被管理接口 ，是所有被管理者 被管理部分的抽象 2.11.1. 向下分析核心代码mSystemServiceManager.startService 核心代码： // SystemServiceManager.java Constructor constructor = serviceClass.getConstructor(Context.class); //cg: reflect, serviceClass 用反射来统一new AMS、PMS等 service = constructor.newInstance(mContext); // Register it. ---->自然，管理，自然要向SystemServiceManager注册，java侧？？？？ mServices.add(service); 为啥一定要用反射呢？ TODO 可能原因：1、有90个服务，依赖太多，可能编译有问题，所以统一用反射？ 疑问： AMS、ATMS启动了，但是启动线程是在哪里可以看出来的？ 2.11.2. publishBinderService 向Native注册Ibinder（核心） 注册： // ActivityTaskManagerService.java publishBinderService(Context.ACTIVITY_TASK_SERVICE, mService); //cg: used by APP process,saved to serviceManger LocalServices.addService(ActivityTaskManagerInternal.class, mInternal);//cg: used by systemServer -ATMS 向native注册, 即是向 APP 公布出去publishBinderService ServiceManager的本质： 维护了一个列表，存储 “服务名” 与 binder驱动 疑问： 非Binder形式的service不用注册了？ 疑问： 与 registerService(Context.ACTIVITY_TASK_SERVICE, ActivityTaskManager.class, 差别？ ----》 后者是应用侧的，前者系统侧 2.11.3. AMS new后，由AMS注册一堆进程相关服务 // SystemServer.java mActivityManagerService.setSystemProcess(); //cg: register service AMS管理各个应用进程，所以由其注册的相关服务有(自然，与进程相关的服务)： public void setSystemProcess() { try { ServiceManager.addService(Context.ACTIVITY_SERVICE, this, /* allowIsolated= */ true, DUMP_FLAG_PRIORITY_CRITICAL | DUMP_FLAG_PRIORITY_NORMAL | DUMP_FLAG_PROTO);// cg: register AMS(this)， AMS 本身 ServiceManager.addService(ProcessStats.SERVICE_NAME, mProcessStats); // cg: ProcessStats of APP, APP进程信息 ServiceManager.addService(\"meminfo\", new MemBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_HIGH); // cg: register meminfo(of App) service ServiceManager.addService(\"gfxinfo\", new GraphicsBinder(this)); ServiceManager.addService(\"dbinfo\", new DbBinder(this)); if (MONITOR_CPU_USAGE) { ServiceManager.addService(\"cpuinfo\", new CpuBinder(this), /* allowIsolated= */ false, DUMP_FLAG_PRIORITY_CRITICAL); } ServiceManager.addService(\"permission\", new PermissionController(this)); // cg: register permission权限 ServiceManager.addService(\"processinfo\", new ProcessInfoService(this)); // cg: register ProcessInfo(of APP) service ........ synchronized (this) { ProcessRecord app = mProcessList.newProcessRecordLocked(info, info.processName, false, 0, new HostingRecord(\"system\")); ........ mProcessList.updateLruProcessLocked(app, false, null); // cg: add ProcessRecord updateOomAdjLocked(OomAdjuster.OOM_ADJ_REASON_NONE); } 2.11.4. AMS 让 zygote 创建 launcher进程 2.12. -------流程end，基于0层------ 2.13. 基于0层，补充次要linux进程： 参考：https://blog.csdn.net/yjzl1911/article/details/5613569 2.14. 几大重要进程之间的通信 -------> Todo：重新画 servicemanager 管理Binder的 2.15. 参考链接： http://gityuan.com/android/ https://blog.csdn.net/yangwen123/article/details/17258023 Zygote进程启动过程源代码分析 http://gityuan.com/2016/02/13/android-zygote/ 2.16. 疑问 https://blog.csdn.net/yangwen123/article/details/17258023 上面serviceManager画法是对的。管理java和native ----> 本质都是native做的 这个图画得挺好，为什么？ https://blog.csdn.net/wcsbhwy/article/details/105965932 Zygote如何fork一个进程 疑问：所有独立进程，都是靠 死循环loop() + epoll唤醒而存活。见上面图 - 那么线程呢？比如WMS与AMS？ 2.17. 面试题: 2.17.1. 孵化应用进程这种事为什么不交给SystemServer来做，而专门设计一个Zygote？ ---> 问题的本质：Zygote的存在合理性(0层图需要考虑的) 效率角度： 应用在启动的时候需要做很多准备工作，包括启动虚拟机，加载各类系统资源等等，这些都是非常耗时的，如果能在zygote里就给这些必要的初始化工作做好，子进程在fork的时候就能直接共享，那么这样的话效率就会非常高。这个就是zygote存在的价值，这一点呢SystemServer是替代不了的，主要是因为SystemServer里跑了一堆系统服务，这些是不能继承到应用进程的。 内存角度： -应用进程在启动的时候，内存空间除了必要的资源外，最好是干干净净的，不要继承一堆乱七八糟的东西。所以呢，不如给SystemServer和应用进程里都要用到的资源抽出来单独放在一个进程里，也就是这的zygote进程，然后zygote进程再分别孵化出SystemServer进程和应用进程。孵化出来之后，SystemServer进程和应用进程就可以各干各的事了。 原文链接：https://blog.csdn.net/m0_37999066/article/details/127271879 2.17.2. Zygote的IPC通信机制为什么不采用binder？如果采用binder的话会有什么问题么？ 原文链接：https://blog.csdn.net/m0_37999066/article/details/127271879 高频考点 2.18. 参考 https://blog.csdn.net/hzwailll/article/details/85339714 ActivityThread的理解和APP的启动过程 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/Input.html":{"url":"coding/Andriod/Input.html","title":"Input","keywords":"","body":"1. input系统1.1. 0层结构1.2. 1层流程2. Android事件的分发------从viewRootImpl到Activity3. Android事件的分发------从Activity开始3.1. 简介3.2. 模型3.3. 基于模型，viewGroup的分发 详解3.4. 基于模型，view的分发 详解3.5. 基于模型，view的处理onTouchEvent 详解3.6. 从事件流的角度3.6.1. 面试题4. Android事件的处理5. 其他细节5.1. android 触摸(Touch)事件、点击(Click)事件的区别5.2. 从设计模式角度理解：6. 滑动冲突问题7. 疑问8. 方法9. 一切皆文件：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 input系统 0层结构 1层流程 Android事件的分发------从viewRootImpl到Activity Android事件的分发------从Activity开始 简介 模型 基于模型，viewGroup的分发 详解 基于模型，view的分发 详解 基于模型，view的处理onTouchEvent 详解 从事件流的角度 面试题 Android事件的处理 其他细节 android 触摸(Touch)事件、点击(Click)事件的区别 从设计模式角度理解： 滑动冲突问题 疑问 方法 一切皆文件： 1. input系统 1.1. 0层结构 （比较laji） 1.2. 1层流程 见： http://gityuan.com/2016/12/31/input-ipc/ 自然，HOME事件不能让它到应用层，所以会被提前拦截： 2. Android事件的分发------从viewRootImpl到Activity 总结为，先有一个环 3. Android事件的分发------从Activity开始 3.1. 简介 注意点： Q: 分发事件的对象是MotionEvent，没有touchevent与click事件？ A: 没有Touch事件（TouchEvent）， 没有click事件（ClickEvent）。原因： motion用的很恰当。手指触摸，必然是一段时间，一段距离——》即 motion移动 click表示一瞬，其实是没有的 ----》 虽然有时候表达成 touch事件、click事件 3.2. 模型 参考，好文： https://blog.csdn.net/pgg_cold/article/details/79472193?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-79472193-blog-125568753.pc_relevant_multi_platform_whitelistv3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 生活化模型： 项目经理分发任务模型： 项目经理（Activity） 任务（事件） 主管(viewGroup) 员工（view） 友商安排进来的员工（Listener监听者） 继承表达的含义： 继承从功能的角度来看，表达 功能更多、更强 的意思 自然：主管继承员工（viewGroup继承view） 主管管理员工 ---》继承多出的功能，自然 基于模型自然有： 1、自然，每个角色都有两种能力：向下分发的任务的能力（dispatchTouchEvent）、处理事件的能力onTouchEvent 2、特例：拦截任务向下传递的能力onInterceptTouchEvent，只属于主管viewGroup。这是自然的，因为 项目经理要是拦截，项目不要干了。普通员工没有拦截必要，在最底层。 现在你所在的公司中有一项任务被派发下来了，项目经理把项目交给你的老大，你的老大老大手下有很多人，看了看觉得你做很合适，把这个任务交给你了；如果友商安排了间谍，那自然先被间谍抢去了（即view对外分发）。如果没有间谍，你一看觉得还行，你就接下来了； 3.3. 基于模型，viewGroup的分发 详解 参考： https://mp.weixin.qq.com/s/sSPFz3E5gncYiMMFtF_xlg 好文 从责任链模式看Android事件分发 https://blog.csdn.net/tony499074462/article/details/102499302 ViewGroup事件分发机制详解 https://blog.csdn.net/a553181867/article/details/51287844 Android View 事件分发机制源码详解(ViewGroup篇) 一句话总结： 安卓事件分发机制： 是双责任链（树责任链 + 链表责任链） ，见图 具体讨论见 设计模式----责任链模式 viewGroup分发核心问题： ViewGroup那么多view，dispatch如何找到对应消费的view？ A：dispatch流程里，对 根据 view可见的Z向位置，对各个子view进行排序： // ViewGroup.java buildTouchDispatchChildList() { final float currentZ = nextChild.getZ(); // insert ahead of any Views with greater Z int insertIndex = i; while (insertIndex > 0 && mPreSortedChildren.get(insertIndex - 1).getZ() > currentZ) { //找到对应的Z位置 insertIndex--; } mPreSortedChildren.add(insertIndex, nextChild); // 排序 } public boolean dispatchTouchEvent(MotionEvent ev) { final ArrayList preorderedList = buildTouchDispatchChildList(); // 排序 for (int i = childrenCount - 1; i >= 0; i--) { // 【1】倒着来遍历，自然 } } 【1】倒着来遍历，自然： 希望最上 层的View来响应的,而不是被覆盖这的底层的View来响应 ViewGroup的子元素成功处理事件的时候，mFirstTouchTarget会指向子元素，这里要留意一下 viewGroup中找view，结论： 如果down事件由某一个 view消耗了，同一个事件序列的其他所有事件也由其处理---》很自然，事件流是对一个控件的操作，不可能多个。证明: 3.4. 基于模型，view的分发 详解 参考： https://blog.csdn.net/qq_56785698/article/details/123159190 问题：按道理说，叶子节点的view没有子view，那么为啥还存在分发dispatchTouchEvent呢？ A：因为要先向注册的Listener 先分发（即view对外分发），最后才是自己处理 // view.java public boolean dispatchTouchEvent(MotionEvent event) { ............. if (onFilterTouchEventForSecurity(event)) { if ((mViewFlags & ENABLED_MASK) == ENABLED && handleScrollBarDragging(event)) { result = true; } //noinspection SimplifiableIfStatement ListenerInfo li = mListenerInfo; if (li != null && li.mOnTouchListener != null && (mViewFlags & ENABLED_MASK) == ENABLED && li.mOnTouchListener.onTouch(this, event)) {// 【1】先给了监听器 result = true; } if (!result && onTouchEvent(event)) { // 【2】后自己处理 result = true; } } return result; } 3.5. 基于模型，view的处理onTouchEvent 详解 问题：onTouchEvent 分别处理了DOWN、MOVE、UP事件，如何处理的? View.onTouchEvent()其实处理了三种情况 处理长按事件: checkForLongClick，检测长按的机制:起了一个线程，长按的计时器postDelayed，到时间发现还没有UP事件，就为长按 case MotionEvent.ACTION_DOWN: if (isInScrolling Container) { } else { // 设置DOWN状态标志 setPressed(true, x, y); break; 处理点击事件:click 处理tap事件: 3.6. 从事件流的角度 参考：https://blog.csdn.net/qq_56785698/article/details/123159190 事件传递的疑问: 1、事件指的是什么？实际上是事件流，不是单一事件。。。自然 2、为了解决多指触控的问题,TODO: 引入Pointer概念 https://www.jianshu.com/p/0c863bbdedeb 3.6.1. 面试题 4. Android事件的处理 参考：http://gityuan.com/2015/09/19/android-touch/ 问题：事件是120HZ采样，绘制只有60HZ -----> 会产生问题：有两个move没有被 绘制采样 ----》 所谓的 界面不跟手 安卓处理（滑动跟手性）方法： 整体流程： 5. 其他细节 5.1. android 触摸(Touch)事件、点击(Click)事件的区别 参考： https://blog.csdn.net/LR6666/article/details/52119167 https://blog.csdn.net/Double2hao/article/details/54374861 简易理解： 1、onTouchEvent中3个事件就是：MotionEvent.ACTION_DOWN、ACTION_MOVE、ACTION_UP -----> 自然，因为手机速度必然慢，所以手指的touch过程必然是一个时间段，比如，手指滑动scroview 2、click来源： 一波touchEvent下发ACTION_DOWN 第二波touchEvent下发ACTION_MOVE ............... 第N波touchEvent下发ACTION_UP -> onClick的 上述过程非常自然：touch结束，必然有onClick？ 其实没有Touch，也没有click 5.2. 从设计模式角度理解： 事件分发，是责任链模式的应用 见 《DesignPattern》 6. 滑动冲突问题 TODO ------->办法:事件拦截机制 7. 疑问 如果view重叠，如何找到对应的view？ 8. 方法 不讲代码，只讲逻辑 只画图 讲课视频，是按照 思维方式（1、目标-起点 2、遇到的问题）来讲的，而不是 技术文章的平铺直叙 ----》 会很深刻，从0创造知识的思维 ---------> TODO: 能否这样写技术文章呢？如果不能，能有借鉴意义嘛 数据在哪个进程的哪个线程 分析方法：1、目标-起点 2、目标到起点遇到的问题，解决问题的方法，便是核心思想-----》 实际上就是(方法、结构、流程)合理性的证明 ---------> 所以，理解的深刻与否，在于 ： （1）系统演进的历史 ，遇到了什么问题，导致这样演进的？ ----> 搜索，这一点很难知道 ​ （2）退而求其次。多问合理性的问题，为什么要这样设计？ 代码最最烂最烂的东西：没有重点、量太大、细节太多 ------> 只能作为字典 9. 一切皆文件： 参考：https://www.bilibili.com/video/BV117411H732/?spm_id_from=333.999.0.0&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/InputMethod.html":{"url":"coding/Andriod/InputMethod.html","title":"Input Method","keywords":"","body":"1. 输入法1.1. 普通输入法需要支持的功能------功能角度2. 多屏多会话输入法2.1. 目前现状：2.2. 如何开启2.3. 参考：2.4. 其他一些TODO3. 分布式输入法3.1. 分布式输入法流程4. 输入法的前提----焦点4.1. 单个display4.2. 多个display -------焦点窗口4.2.1. 单屏焦点4.2.2. 多屏焦点4.3. 焦点0层5. 预研5.1. 引用分析5.1.1. 引用分析之InputMethodManagerInternal5.1.2. 引用分析之INPUT_METHOD_SERVICE5.2. 参考：multi5.3. 修改TreeviewCopyright © aleen42 all right reserved, powered by aleen42 普通输入法需要支持的功能------功能角度 多屏多会话输入法 目前现状： 如何开启 参考： 其他一些TODO 分布式输入法 分布式输入法流程 输入法的前提----焦点 单个display 多个display -------焦点窗口 单屏焦点 多屏焦点 焦点0层 预研 引用分析 引用分析之InputMethodManagerInternal 引用分析之INPUT_METHOD_SERVICE 参考：multi 修改 1. 输入法 见AndriodSystem_Others google文档： https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn 输入法自己隐藏自己：需要向管理者请求（-------> 相当自然，自己的死不是自己能决定的） IMS.requestHideSelf ----> IMMS.hideMySoftInput ----> IMS.hideSoftInput() 注意：IMS ----> IMMS不是通过sessioncallback（TODO） 1.1. 普通输入法需要支持的功能------功能角度 也是验证角度 基础： 支持显示与隐藏功能： （1）输入对象侧控制输入法显示与隐藏IMM-->IMMS-->IMS。显示由框架层决定，隐藏由APP侧调框架层接口 （2）输入法面板自己主动隐藏。IMS--->IMMS--->IMS 支持向输入对象提交/删除文本内容。commitText() 操作：输入法可以向编辑框输入、删除 支持从输入对象获得光标信息 。 操作：手指在编辑框中移动光标，再进行输入，输入文字位置符合预期，则证明输入法获得了正确的光标位置；光标选中一段文字，删除 支持提交功能按键事件给输入对象。比如：百度搜索框下，点击输入法ENTER键，自动搜索 高阶： 支持根据系统语言类型配置键盘模式（出口国外，必须？） 支持向输入对象提交/删除富文本内容 支持输入法根据编辑框类型，自动选择不同输入法面板。 比如：姓名框是中文拼音键盘面板；数字框是数字键盘面板；密码框是安全键盘面板，还有语音键盘面板，手写键盘面板等等 输入法的全屏模式 支持setting中增加输入法设置入口：输入设置、手写设置、隐私设置等等 支持硬件键盘输入 2. 多屏多会话输入法 2.1. 目前现状： Android 9 及以前： 系统中一次最多只有一个窗口具有焦点 Android 10~12：MultiClientInputMethodManagerService （见：https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn） google解释了为什么无法通过现有的IMS，做到多会话： Android 13： MultiClientInputMethodManagerService被删除：https://android.googlesource.com/platform/frameworks/base/+/34091a5066f3 2.2. 如何开启 1、框架要支持： （1）多屏 焦点： 将 config_perDisplayFocusEnabled 设置为 true （frameworks/base/core/res/res/values/config.xml） （2）非默认屏幕显示输入法： WMS.setDispalyImePolicy(2, 0) 2---- displayId 0-----WindowManger.DISPLAY_IME_POLICY_LOCAL //作用：输入法显示在本地，非默认屏 等价于？： DisplayWindowSettings#shouldShowImeLocked() DisplayWindowSettings#setShouldShowImeLocked() ​ 2、应用侧 编译MultiClientInputMethod.apk ------> 多会话的安卓demo 见：https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn#non-default //enable: $ make -j MultiClientInputMethod $ adb install -r $OUT/system/priv-app/MultiClientInputMethod/MultiClientInputMethod.apk $ adb root $ adb shell setprop persist.debug.multi_client_ime \\ com.example.android.multiclientinputmethod/.MultiClientInputMethod -----> TODO:这行是做什么的？？？ $ adb reboot //disable: # Disable multi-client IME again adb root adb shell \"setprop persist.debug.multi_client_ime ''\" adb reboot 核心功能实现： MultiClientInputMethodManagerService ------------------》 支持每屏幕焦点是启用此功能的前提（自然，输入法是以窗口焦点为基础的） ​ 自然，需要将 config_perDisplayFocusEnabled 设置为 true TODO: 理解焦点的机制（获焦、走焦）：焦点的本质是为了获取输入（无论键盘、输入法、手指、鼠标。。。。） 2.3. 参考： 《multi-client-ime.md》 https://source.android.google.cn/devices/tech/display/multi_display/ime-support?authuser=0&hl=zh-cn#non-default 2.4. 其他一些TODO 规则：键盘（硬件或软件）的输入只能进入最顶层的 activity（最近启动的应用） ---->否则隐藏 3. 分布式输入法 见AndriodSystem_Others 3.1. 分布式输入法流程 见AndriodSystem_Others 4. 输入法的前提----焦点 焦点、焦点窗口、每屏焦点 4.1. 单个display 焦点 是window级别。在window之间切换 4.2. 多个display -------焦点窗口 4.2.1. 单屏焦点 焦点 是display级别，先看是哪个mTopFocusedDisplayId （关键词------------dump window） ​ 哪个window？（关键词mCurrentFocus=------------dump window） 即 1、 set： perDisplayFocusEnabled xml中配置false ​ 2、get： WindowManagerService#mPerDisplayFocusEnabled dump中如何判定？点击左右屏幕 只有一个focusDisplay，只有一个mCurrentFocus window （ANR的除外，也focus了） 现象： 1、分别点击左右框，输入法会切换 --------> 自然， 因为焦点只有一个 2、如果设置了在非默认屏弹输入法（setPolicy），则输入法会在两边切换 -------->自然， 因为焦点只有一个 4.2.2. 多屏焦点 判定get： WindowManagerService#mPerDisplayFocusEnabled 1、如何dump看出来？ 2、 4.3. 焦点0层 https://source.android.google.cn/docs/core/display/multi_display/displays?authuser=0&hl=zh-cn#focus 5. 预研 5.1. 引用分析 难点：IMMS的对外依赖 IMMS的依赖： ActivityManager ----> 忽略 ActivityManagerInternal ----> 忽略 mIPackageManager ----> 唯一，可以忽略 PackageManager ----> 唯一，可以忽略 PackageManagerInternal ----> 唯一，可以忽略 ResolveInfo ----> 忽略 ServiceInfo ----> 忽略 AudioManagerInternal mAudioManagerInternal ----> 忽略 KeyguardManager mKeyguardManager ----> 忽略 StatusBarManagerService mStatusBa ----> 忽略 InputManagerInternal ------>忽略 InputMethodService ------>忽略，都是引用常量 InputMethodSettings mSettings; -----> 这个依赖比较深，设置方面的 + userId userId = ActivityManager.getService().getCurrentUser().id; -----》有疑问：如果是双开，那么IMMS获取的是啥？ updateCurrentProfileIds UserManager mUserManager; -----> 使用了UserId，需注意 UserManagerInternal mUserManagerInternal ----> 使用了UserId，需注意 WindowManagerInternal mWindowManagerInternal; ----> WMS真正的内部类，很多调用点！！！！！！ ​ mWindowManagerInternal.getDisplayImePolicy(displayId); ​ mWindowManagerInternal.isUidAllowedOnDisplay(cs.selfReportedDisplayId, cs.uid)------> 不用管 ​ mWindowManagerInternal.removeWindowToken ----> 不用管，windowToken来标志 ​ mWindowManagerInternal.getTopFocusedDisplayId() -----> 这个接口很有问题 -------------------》 IMMS.setImeWindowStatus需要修改： 1、该接口标注废弃了 2、topFocusedDisplayId 没有阻碍关键路径 IWindowManager mIWindowManager; -----> 这个是wms，只有两处调用，似乎OK mIWindowManager.addWindowToken(mCurToken, LayoutParams.TYPE_INPUT_METHOD, mCurTokenDisplayId, null / options /); transferTouchFocusToImeWindow ---》 特殊场景，忽略 这个方法仅在需要手动控制焦点转移时使用，一般情况下Android系统会自动处理焦点的转移。此方法通常在特殊的UI交互场景或自定义的文本输入组件中使用。 //IMS这里需要改 mImm = (InputMethodManager)getSystemService(INPUT_METHOD_SERVICE); mIWindowManager = IWindowManager.Stub.asInterface( ServiceManager.getService(Context.WINDOW_SERVICE)); 5.1.1. 引用分析之InputMethodManagerInternal 注意： LocalServices.addService(InputMethodManagerInternal.class, -------> muti框架基本上都没有实现！影响是？？？ InputMethodManagerInternal还是有很多地方引用的 我们自己新增的service2是不是也可以不实现？？？？ //muti框架实现的，仅仅 userIdToInputMethodInfoMapper.getAsList(userId); getEnabledInputMethodListAsUser 1、RecentsAnimationController最近任务（任务概览）动画的控制和协调。系统级的任务切换动画 ​ inputMethodManagerInternal.hideCurrentInputMethod( ​ InputMethodManagerInternal.get().updateImeWindowStatus( -------> 似乎有些影响 2、 Notifier.java ​ mInputMethodManagerInternal.setInteractive(interactive); 3、AutofillManagerServiceImpl.java ----> AutofillInlineSuggestionsRequestSession.java 内联？ ​ onCreateInlineSuggestionsRequest 4、RemoteInlineSuggestionViewConnector.java remote view相关，把输入事件传给输入法 ​ onTransferTouchFocusToImeWindow() 5、PhoneWindowManager.java SHORT_PRESS_POWER_CLOSE_IME_OR_GO_HOME：当用户在任何界面（包括应用程序、设置等）中短按电源按钮时, 隐藏输入法或者进入桌面 ------> 现在手机都没有这个现象 mInputMethodManagerInternal.hideCurrentInputMethod( 6、TranslationManagerServiceImpl.java 处理多语言翻译任务和提供相关 ​ getEnabledInputMethodListAsUser(mUserId) : 获取输入法列表信息，最终在setting里获取的 ---------> 总之，以上不是太重要，所以，multi框架忽略了 所以，新增的service2，不要注册InputMethodManagerInternal.class了！！！！，让主services去实现吧 5.1.2. 引用分析之INPUT_METHOD_SERVICE context.getSystemService(Context.INPUT_METHOD_SERVICE) Activity ----> context 要修改这么多context？ ---------> 最终统一追溯到SystemServiceRegistry.getSystemService ？？？ 5.2. 参考：multi final boolean perDisplayFocusEnabled = mContext.getResources().getBoolean( com.android.internal.R.bool.config_perDisplayFocusEnabled); 5.3. 修改 public void onStart() { publishBinderService(Context.INPUT_METHOD_SERVICE, mService, false // \"input_method2\" } ​ ----> 也可以参考multi的 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/multi-client-ime.html":{"url":"coding/Andriod/multi-client-ime.html","title":"Multi Client Ime","keywords":"","body":"1. Multi Client Input Method Editors1.1. History of Multi Client Input Method Editors (Multi Client IMEs)1.2. How to test1.3. How to develop multi-client IMEs1.4. Versioning1.5. Implementation note1.5.1. Unsupported features1.5.2. SecurityTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Multi Client Input Method Editors History of Multi Client Input Method Editors (Multi Client IMEs) How to test How to develop multi-client IMEs Versioning Implementation note Unsupported features Security Root permission is required to enable MCIMMS on non-supported devices Multi-client IME must be pre-installed Integer handle vs IBinder token Licensed under the Apache License, Version 2.0 (the \"License\"); you may not use this file except in compliance with the License. You may obtain a copy of the License at http://www.apache.org/licenses/LICENSE-2.0 Unless required by applicable law or agreed to in writing, software distributed under the License is distributed on an \"AS IS\" BASIS, WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or implied. See the License for the specific language governing permissions and limitations under the License. 1. Multi Client Input Method Editors 1.1. History of Multi Client Input Method Editors (Multi Client IMEs) An advanced multi-display support is requested for certain Android form-factors so that user(s) can type text on each display at the same time without losing software keyboard focus in other displays (hereafter called \"multi-client scenario\"). This is not possible in Android IMEs built on top of InputMethodService class. The assumption that a single IME client can be focused at the same time was made before Android IME APIs were introduced in Android 1.5 and many public APIs in InputMethodService have already relied heavily on that assumption (hereafter called \"single-client scenario\"). Updating InputMethodService class to support multi-client scenario is, however, quite challenging because: doing so would introduce an unacceptable amount of complexity into InputMethodService, which is already hard to maintain, IME developers still need to update their implementation to be able to support parallel requests from multiple focused IME client, which may require non-trivial redesign in their side (e.g. input decoder, typing history database, ...), and actual use cases for multi IME clients are expected to be evolved rapidly hence the new protocol is not yet stable and not yet ready to be exposed as public APIs. Thus the first decision we made was that to support such special multi-display environments a new type of IME (hereafter called \"multi-client IME\") needs to be designed and implemented rather than reusing InputMethodService public class. On top of this decision, following decisions were also made: Multi-client IME V1 will be built on top of private APIs. This means: Multi-client IME must be pre-installed into the system. They cannot be distributed via application store since protocol compatibility is not guaranteed across devices and releases. The system should trust multi-client IME to some extent. System integrators are responsible for making sure that the pre-installed multi-client IME works as expected. Unlike InputMethodService, multiple multi-client IMEs cannot be enabled. The system pre-installs only one multi-client IME. Punt some special features of Android IMEs (e.g. fullscreen mode, InputMethodSubtype, ...) from V1 goal unless someone actually requests those features for multi-client IME scenario. Introduce MultiClientInputMethodManagerService (MCIMMS) for multi-client IME scenario and use it instead of InputMethodManagerService (IMMS) when a certain runtime flag is enabled at the device boot time. This means: basically no risk for single-client scenario, the feature can be easily deprecated, and it forces us to rewrite IME system server, which is expected to be a good chance to reconsider what Android IME protocol should look like. Most of form-factors such as Phones and TVs continue to use IMMS and support at most one focused IME client even under multi-display environment. 1.2. How to test For multi-client IME to properly work, an internal boolean resource com.android.internal.R.bool.config_perDisplayFocusEnabled needs to be true. Since this value cannot be overridden at the run time, you may need to rebuild the system image to enable per-display focus mode. As for multi-client IME mode itself, you can enable multi-client IME mode just by setting a valid component name that supports multi-client IME protocol to the system property persist.debug.multi_client_ime, as long as android.os.Build.IS_DEBUGGABLE returns true and you can have root access. Reboot is required for this to take effect. # Build and install a sample multi-client IME make -j MultiClientInputMethod adb install -r $OUT/system/priv-app/MultiClientInputMethod/MultiClientInputMethod.apk # Enable multi-client IME for the side-loaded sample multi-client IME adb root adb shell setprop persist.debug.multi_client_ime com.example.android.multiclientinputmethod/.MultiClientInputMethod adb reboot To disable multi-client IME on non-supported devices again, just clear persist.debug.multi_client_ime as follows. Reboot is still required for this to take effect. # Disable multi-client IME again adb root adb shell \"setprop persist.debug.multi_client_ime ''\" adb reboot 1.3. How to develop multi-client IMEs There is a sample multi-client IME in development/samples/MultiClientInputMethod/. 1.4. Versioning Neither forward nor backward compatibility is guaranteed in multi-client IME APIs. The system integrator is responsible for making sure that both the system and pre-installed multi-client IME are compatible with each other every time the system image is updated. 1.5. Implementation note `` 1.5.1. Unsupported features VR IME VrManager#setVrInputMethod() system API is not supported. InputMethodSubtype Following APIs are not supported InputMethodManager#getEnabledInputMethodSubtypeList() ----> adb shell ime list失效的原因（multi-client输入法下） InputMethodManager#getCurrentInputMethodSubtype() InputMethodManager#setCurrentInputMethodSubtype() InputMethodManager#getShortcutInputMethodsAndSubtypes() InputMethodManager#setAdditionalInputMethodSubtypes() InputMethodManager#getLastInputMethodSubtype() Settings.Secure#SELECTED_INPUT_METHOD_SUBTYPE IME switching Following APIs are not supported InputMethodManager#showInputMethodPicker() InputMethodManager#showInputMethodAndSubtypeEnabler() InputMethodManager#setInputMethod() InputMethodManager#setInputMethodAndSubtype() InputMethodManager#switchToLastInputMethod() InputMethodManager#switchToNextInputMethod() InputMethodManager#shouldOfferSwitchingToNextInputMethod() Settings.Secure#DEFAULT_INPUT_METHOD Settings.Secure#ENABLED_INPUT_METHODS Direct-boot aware multi-client IME Device manufacturer can work around this by integrating in-app keyboard into the initial unlock screen. Full-screen mode Following API always returns false. InputMethodManager#isFullscreenMode() Custom inset For instance, floating IME cannot be implemented right now. Custom touchable region (InputMethodService.Insets#touchableRegion) Image Insertion API InputConnection#commitContent() API is silently ignored. adb shell dumpsys does not include any log from MCIMMS yet. 1.5.2. Security Root permission is required to enable MCIMMS on non-supported devices In order to override persist.debug.multi_client_ime device property, an explicit root permission is needed. Multi-client IME must be pre-installed Multi-client IME must be pre-installed since it is considered as part of the system component. This is verified by checking ApplicationInfo.FLAG_SYSTEM bit. This security check can be bypassed when Build.IS_DEBUGGABLE is true so that IME developers can easily side-load their APKs during development phase. public final class MultiClientInputMethodManagerService { ... @Nullable private static InputMethodInfo queryInputMethod(Context context, @UserIdInt int userId, @Nullable ComponentName componentName) { ... if (! && (si.applicationInfo.flags & ApplicationInfo.FLAG_SYSTEM) == 0) { Slog.e(TAG, imeId + \" must be pre-installed when Build.IS_DEBUGGABLE is false\"); return null; } services/core/java/com/android/server/inputmethod/MultiClientInputMethodManagerService.java Integer handle vs IBinder token Sometimes MCIMMS needs to issue certain types of identifiers to the multi-client IME so that the IME can later specify to which entity or resource it intends to access. A good example is the IME client identifier. Multi-client IME definitely need to be able to specify which IME client to be interacted with for certain operations. The problem is that MCIMMS cannot simply pass IInputMethodClient to the multi-client IME as an ID because it would allow the IME to make IPC calls to the IME client. For this kind of situations, we usually use Binder object just as a non-spoofable token. For instance, IMMS creates another 'Binder' token then pass it to the IME, instead of directly passing 'IWindow' Binder token. public class InputMethodManagerService extends IInputMethodManager.Stub implements ServiceConnection, Handler.Callback { ... @GuardedBy(\"mMethodMap\") private final WeakHashMap mImeTargetWindowMap = new WeakHashMap<>(); ... @GuardedBy(\"mMethodMap\") @NonNull InputBindResult attachNewInputLocked(@StartInputReason int startInputReason, boolean initial) { ... final Binder startInputToken = new Binder(); final StartInputInfo info = new StartInputInfo(mCurToken, mCurId, startInputReason, !initial, mCurFocusedWindow, mCurAttribute, mCurFocusedWindowSoftInputMode, mCurSeq); mImeTargetWindowMap.put(startInputToken, mCurFocusedWindow); ... } ... @BinderThread private void reportStartInput(IBinder token, IBinder startInputToken) { if (!calledWithValidToken(token)) { return; } synchronized (mMethodMap) { final IBinder targetWindow = mImeTargetWindowMap.get(startInputToken); if (targetWindow != null && mLastImeTargetWindow != targetWindow) { mWindowManagerInternal.updateInputMethodTargetWindow(token, targetWindow); } mLastImeTargetWindow = targetWindow; } } services/core/java/com/android/server/inputmethod/InputMethodManagerService.java However, in MCIMMS, for certain cases we decided to use a simple integer token, which can be spoofable and can be messed up if integer overflow happens. This is because: It does not make much sense to worry about malicious multi-client IMEs, because it is guaranteed to be a pre-installed system component. Integer token is expected to be a more lightweight that Binder token. For that use case, integer overflow is unrealistic. Strict user separation is still enforced. Multi-client IMEs are still not allowed to interact with other users' resources by any means. Currently the following IDs are implemented as integer tokens: Client ID Window Handle Note that each IME client has its own Window Handle mapping table. Window Handle is valid only within the associated IME client. console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/permissions.html":{"url":"coding/Andriod/permissions.html","title":"Permissions","keywords":"","body":"1. 问在前面（目的论）2. 安卓权限概念3. 哪些app属于system app？4. 权限的声明&使用&获取5. 环境中查看状态5.1. 以package 为base，查看一个包涉及的权限5.1.1. declared permissions ：自定义权限5.1.2. requested permissions ：请求权限5.1.3. install permissions ：安装权限5.1.4. runtime permissions ： 运行时权限5.2. 以权限为base，查哪些声明了，哪些使用了6. 参考：7. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 问在前面（目的论） 安卓权限概念 哪些app属于system app？ 权限的声明&使用&获取 环境中查看状态 以package 为base，查看一个包涉及的权限 declared permissions ：自定义权限 requested permissions ：请求权限 install permissions ：安装权限 runtime permissions ： 运行时权限 以权限为base，查哪些声明了，哪些使用了 参考： 格式 1. 问在前面（目的论） 权限： 其实，权限状态是必然的。比如，做饭这件事情， 1、你要有出门的权限（疫情就不行），去买菜 2、房间要满足厨房的通风要求 3、生火的权限 ..................... 权限的功能是啥？ ----》1、如何理解应用权限 与 INTERNAL_SYSTEM_WINDOW 啥关系？ 2、权限的本质是什么？ A申明了权限，B使用权限？ ​ 权限有哪些状态？（xml中申明？xml请求？用户同意？自定义？运行时？） -----> 软件必须弄懂状态 从信息角度： 限制来源于谁？限制于谁？ 2. 安卓权限概念 参考: https://blog.csdn.net/sinat_20059415/article/details/80370223 见下 TODO 3. 哪些app属于system app？ https://blog.csdn.net/Liu1314you/article/details/77368585 大体认识： privileged app（特权app） > System app > 状态判定标准： ​ ApplicationInfo.FLAG_SYSTEM` ​ ApplicationInfo.PRIVATE_FLAG_PRIVILEGED 4. 权限的声明&使用&获取 声明权限是指在AndroidManifest.xml中使用了， -----》 TODO: 不懂 使用权限是指在AndroidManifest.xml中使用了 获得权限（或赋予权限）是指真正的可以通过系统的权限检查，调用到权限保护的方法 App A中声明了权限PermissionA，App B中使用了权限PermissionA--------> B可以调用A？ 5. 环境中查看状态 注意， 1、其实，与运行时无关，因为PMS这些权限的状态，与运行时无关 ----> 安装包决定的 2、与应用是否打开也无关 5.1. 以package 为base，查看一个包涉及的权限 adb shell dumpsys package 以com.tencent.mm为例： adb shell dumpsys package com.tencent.mm 文件结构如下： 1、给出自定义的Permission 推论：与 declared permissions中的权限 应该一样 TODO 点击展示 Permissions: Permission [com.tencent.mm.WAID_PROVIDER_WRITE] (7bc450): sourcePackage=com.tencent.mm // sourcePackage是权限声明的地方 uid=10108 gids=null type=0 prot=signature perm=Permission{632649 com.tencent.mm.WAID_PROVIDER_WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI] (dc0b46f): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ee0d57c com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.matrix.strategynotify] (aede05): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ef83e5a com.tencent.mm.matrix.strategynotify} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.MM_MESSAGE] (64e288b): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{623cd68 com.tencent.mm.permission.MM_MESSAGE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.plugin.permission.READ] (c445581): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{debe626 com.tencent.mm.plugin.permission.READ} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.wear.message] (4f4c267): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{21c5814 com.tencent.mm.wear.message} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.SPORT] (c5fc8bd): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=normal perm=Permission{3203eb2 com.tencent.mm.ext.permission.SPORT} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.WRITE] (7811e03): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{270e180 com.tencent.mm.ext.permission.WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.backtrace.warmed_up] (7c533b9): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{ecf93fe com.tencent.mm.backtrace.warmed_up} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.C2D_MESSAGE] (1ed975f): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{8c295ac com.tencent.mm.permission.C2D_MESSAGE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR] (37c5275): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{88cf20a com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS] (37e4a7b): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{d996098 com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.manual.dump] (34ca0f1): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{c1024d6 com.tencent.mm.manual.dump} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.vfs.broadcast] (19d1357): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{80fee44 com.tencent.mm.vfs.broadcast} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.plugin.permission.WRITE] (5f95b2d): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature perm=Permission{6c1b862 com.tencent.mm.plugin.permission.WRITE} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permission [com.tencent.mm.permission.MOVE_XLOG] (4758df3): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{43faab0 com.tencent.mm.permission.MOVE_XLOG} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} Permissions: Permission [com.tencent.mm.ext.permission.READ] (93d7d29): sourcePackage=com.tencent.mm uid=10108 gids=null type=0 prot=signature|privileged perm=Permission{206f8ae com.tencent.mm.ext.permission.READ} packageSetting=PackageSetting{557bb4e com.tencent.mm/10108} 2、给出涉及的Permission 点击展示 Packages: Package [com.tencent.mm] (557bb4e): //下面针对于 com.tencent.mm userId=10108 // userId到底是啥？ pkg=Package{e030746 com.tencent.mm} codePath=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw== resourcePath=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw== legacyNativeLibraryDir=/data/app/com.tencent.mm-FtxVmfhJnuP-P7oGWPgRrw==/lib primaryCpuAbi=arm64-v8a // 包路径、资源路径、lib路径 secondaryCpuAbi=null versionCode=2400 minSdk=23 targetSdk=29 //需要的安卓sdk版本 versionName=8.0.38 splits=[base] apkSigningVersion=1 applicationInfo=ApplicationInfo{f07dea4 com.tencent.mm} flags=[ HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] // TODO: flags是啥 privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE HAS_DOMAIN_URLS PARTIALLY_DIRECT_BOOT_AWARE ] dataDir=/data/user/0/com.tencent.mm supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesOptionalLibraries: org.apache.http.legacy com.google.android.maps com.sec.android.app.multiwindow com.miui.easygo com.hihonor.easygo com.here.android androidx.window.extensions androidx.window.sidecar androidx.camera.extensions.impl com.huawei.easygo soterkeystore usesLibraryFiles: /system/framework/org.apache.http.legacy.jar timeStamp=2023-06-28 21:50:04 firstInstallTime=2023-06-28 21:50:28 lastUpdateTime=2023-06-28 21:50:28 installerPackageName=com.android.packageinstaller signatures=PackageSignatures{a4cc409 version:1, signatures:[962f5b7], past signatures:[]} //签名 installPermissionsFixed=true // 安装权限 -----> 如果装上了，一定为true？ pkgFlags=[ HAS_CODE ALLOW_CLEAR_USER_DATA LARGE_HEAP ] declared permissions: // 【1】微信自定义的权限 com.tencent.mm.plugin.permission.WRITE: prot=signature, INSTALLED com.tencent.mm.plugin.permission.READ: prot=signature, INSTALLED com.tencent.mm.permission.MM_MESSAGE: prot=signature, INSTALLED com.tencent.mm.permission.MOVE_XLOG: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.READ: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.WRITE: prot=signature|privileged, INSTALLED com.tencent.mm.ext.permission.SPORT: prot=normal, INSTALLED com.tencent.mm.wear.message: prot=signature, INSTALLED com.tencent.mm.WAID_PROVIDER_WRITE: prot=signature, INSTALLED com.tencent.mm.permission.EXT_OPEN_APPBRAND_LAUNCHER_UI: prot=signature, INSTALLED com.tencent.mm.permission.EXT_OPEN_APPBRAND_MY_COLLECTIONS: prot=signature, INSTALLED com.tencent.mm.matrix.strategynotify: prot=signature, INSTALLED com.tencent.mm.vfs.broadcast: prot=signature, INSTALLED com.tencent.mm.manual.dump: prot=signature, INSTALLED com.tencent.mm.backtrace.warmed_up: prot=signature, INSTALLED com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR: prot=signature, INSTALLED com.tencent.mm.permission.C2D_MESSAGE: prot=signature, INSTALLED requested permissions: // 【2】已经请求的权限。。。1、一定包含install permissions (对于已经安装了的pkg) 2、Todo: 一定都是用户授权了吗？ android.bluetooth.permissions.SHORTCUT_ACTION android.permission.CHANGE_WIFI_MULTICAST_STATE com.tencent.mm.plugin.permission.READ com.tencent.mm.plugin.permission.WRITE com.tencent.mm.permission.MM_MESSAGE com.huawei.authentication.HW_ACCESS_AUTH_SERVICE com.google.android.providers.gsf.permission.READ_GSERVICES android.permission.CHANGE_NETWORK_STATE android.permission.ACCESS_NETWORK_STATE android.permission.ACCESS_COARSE_LOCATION android.permission.ACCESS_FINE_LOCATION android.permission.CAMERA// 微信自然需要CAMERA权限 android.permission.GET_TASKS android.permission.INTERNET android.permission.MODIFY_AUDIO_SETTINGS android.permission.RECEIVE_BOOT_COMPLETED android.permission.RECORD_AUDIO android.permission.READ_CONTACTS android.permission.VIBRATE android.permission.WAKE_LOCK android.permission.WRITE_EXTERNAL_STORAGE: restricted=true com.android.launcher.permission.INSTALL_SHORTCUT com.android.launcher.permission.UNINSTALL_SHORTCUT com.android.launcher.permission.READ_SETTINGS com.tencent.mm.location.permission.SEND_VIEW android.permission.BLUETOOTH android.permission.BLUETOOTH_ADMIN android.permission.BROADCAST_STICKY android.permission.SYSTEM_ALERT_WINDOW android.permission.CHANGE_WIFI_STATE android.permission.GET_PACKAGE_SIZE android.permission.DOWNLOAD_WITHOUT_NOTIFICATION android.permission.NFC com.miui.easygo.permission.READ_PERMISSION com.huawei.android.launcher.permission.CHANGE_BADGE android.permission.WRITE_APP_BADGE cn.cyberidentity.certification.AUTH com.tencent.mm.ext.permission.READ com.tencent.mm.ext.permission.WRITE android.permission.ACTIVITY_RECOGNITION com.tencent.mm.wear.message android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS miui.permission.READ_STEPS android.permission.FOREGROUND_SERVICE android.permission.READ_EXTERNAL_STORAGE: restricted=true android.permission.ACCESS_WIFI_STATE com.open.gallery.smart.Read com.open.gallery.smart.Write com.open.gallery.smart.Provider android.permission.REQUEST_INSTALL_PACKAGES android.permission.USE_FULL_SCREEN_INTENT android.permission.USE_FINGERPRINT android.permission.USE_BIOMETRIC com.tencent.mm.WAID_PROVIDER_WRITE com.bbk.launcher2.permission.READ_SETTINGS com.android.vending.BILLING com.android.vending.CHECK_LICENSE com.tencent.mm.matrix.strategynotify android.permission.ACCESS_NOTIFICATION_POLICY com.tencent.mm.vfs.broadcast com.tencent.mm.manual.dump com.tencent.mm.backtrace.warmed_up com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR com.huawei.easygo.permission.READ_PERMISSION com.oplus.permission.safe.FANTASYWINDOW com.google.android.finsky.permission.BIND_GET_INSTALL_REFERRER_SERVICE com.google.android.c2dm.permission.RECEIVE com.tencent.mm.permission.C2D_MESSAGE com.soter.permission.ACCESS_SOTER_KEYSTORE android.permission.USE_FACERECOGNITION install permissions: // 【3】安卓时，所必要的权限，安装上，必然用户授权 ranted=true android.permission.DOWNLOAD_WITHOUT_NOTIFICATION: granted=true android.permission.MODIFY_AUDIO_SETTINGS: granted=true android.permission.ACCESS_NOTIFICATION_POLICY: granted=true com.tencent.mm.WAID_PROVIDER_WRITE: granted=true com.tencent.mm.matrix.strategynotify: granted=true android.permission.NFC: granted=true android.permission.CHANGE_NETWORK_STATE: granted=true android.permission.FOREGROUND_SERVICE: granted=true android.permission.RECEIVE_BOOT_COMPLETED: granted=true com.tencent.mm.permission.MM_MESSAGE: granted=true com.android.launcher.permission.UNINSTALL_SHORTCUT: granted=true android.permission.REQUEST_IGNORE_BATTERY_OPTIMIZATIONS: granted=true android.permission.BLUETOOTH: granted=true android.permission.CHANGE_WIFI_MULTICAST_STATE: granted=true android.permission.GET_TASKS: granted=true android.permission.INTERNET: granted=true android.permission.BLUETOOTH_ADMIN: granted=true android.permission.GET_PACKAGE_SIZE: granted=true com.tencent.mm.plugin.permission.READ: granted=true com.tencent.mm.wear.message: granted=true com.tencent.mm.ext.permission.WRITE: granted=true android.permission.USE_FULL_SCREEN_INTENT: granted=true android.permission.BROADCAST_STICKY: granted=true android.permission.CHANGE_WIFI_STATE: granted=true com.tencent.mm.backtrace.warmed_up: granted=true android.permission.ACCESS_NETWORK_STATE: granted=true com.tencent.mm.permission.C2D_MESSAGE: granted=true android.permission.USE_FINGERPRINT: granted=true com.tencent.mm.matrix.permission.PROCESS_SUPERVISOR: granted=true com.tencent.mm.manual.dump: granted=true com.tencent.mm.vfs.broadcast: granted=true com.tencent.mm.plugin.permission.WRITE: granted=true android.permission.VIBRATE: granted=true android.permission.ACCESS_WIFI_STATE: granted=true android.permission.USE_BIOMETRIC: granted=true com.android.launcher.permission.INSTALL_SHORTCUT: granted=true android.permission.WAKE_LOCK: granted=true com.tencent.mm.ext.permission.READ: granted=true User 0: ceDataInode=1106633 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3002, 3003, 3001] runtime permissions: // 【4】运行时的权限：运行时，才申请？？？？所以很多用户还没有授权granted=false android.permission.ACCESS_FINE_LOCATION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.READ_EXTERNAL_STORAGE: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED|RESTRICTION_INSTALLER_EXEMPT] android.permission.ACCESS_COARSE_LOCATION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.CAMERA: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.WRITE_EXTERNAL_STORAGE: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED|RESTRICTION_INSTALLER_EXEMPT] android.permission.ACTIVITY_RECOGNITION: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.RECORD_AUDIO: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] android.permission.READ_CONTACTS: granted=false, flags=[ USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] disabledComponents: com.tencent.mm.plugin.nfc_open.ui.NfcWebViewUI enabledComponents: androidx.work.impl.background.systemjob.SystemJobService 结论: 见上 5.1.1. declared permissions ：自定义权限 作用： 与其他应用分享自己的资源和功能 比如：启动 myapp 的activity ----> 功能分享出去 代码： 1、分享侧自定义DEADLY_ACTIVITY权限： //AndroidManifest.xml ... 2、调用侧 TODO 在AndroidManifest.xml中使用了 ？？？ TODO: 和 在dump中怎么体现的？ TODO: protectionLevel、permissionGroup https://blog.csdn.net/hanhan1016/article/details/105864367 5.1.2. requested permissions ：请求权限 5.1.3. install permissions ：安装权限 5.1.4. runtime permissions ： 运行时权限 5.2. 以权限为base，查哪些声明了，哪些使用了 adb shell dumpsys package permission 结果： Permissions: Permission [android.permission.CALL_PHONE] (cb5d7a9): sourcePackage=android // 权限的申明者？？？？ uid=1000 gids=null type=0 prot=dangerous //保护级别 perm=Permission{6d8812e android.permission.CALL_PHONE} packageSetting=PackageSetting{bb25476 android/1000} Packages: //下面是涉及到这个权限的所有pkg Package [com.android.providers.telephony] (788ac20): // 权限的使用者 userId=1001 sharedUser=SharedUserSetting{91f34cf android.uid.phone/1001} pkg=Package{b7abe5c com.android.providers.telephony} codePath=/system/priv-app/TelephonyProvider versionCode=29 minSdk=29 targetSdk=29 versionName=10 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{6b4565 com.android.providers.telephony} flags=[ SYSTEM HAS_CODE ALLOW_BACKUP KILL_AFTER_RESTORE RESTORE_ANY_VERSION ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE BACKUP_IN_FOREGROUND DEFAULT_TO_DEVICE_PROTECTED_STORAGE DIRECT_BOOT_AWARE PRIVILEGED ] dataDir=/data/user_de/0/com.android.providers.telephony supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-13 02:05:45 firstInstallTime=2020-11-13 02:05:45 lastUpdateTime=2020-11-13 02:05:45 signatures=PackageSignatures{def823a version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_BACKUP KILL_AFTER_RESTORE RESTORE_ANY_VERSION ] requested permissions: install permissions: User 0: ceDataInode=950283 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false Package [com.android.dynsystem] (a6339d9): userId=1000 sharedUser=SharedUserSetting{b844eeb android.uid.system/1000} pkg=Package{c236448 com.android.dynsystem} codePath=/system/priv-app/DynamicSystemInstallationService versionCode=29 minSdk=29 targetSdk=29 versionName=10 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{b4fd2e1 com.android.dynsystem} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION ALLOW_AUDIO_PLAYBACK_CAPTURE PRIVILEGED ] dataDir=/data/user/0/com.android.dynsystem supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] timeStamp=2020-11-13 02:14:46 firstInstallTime=2020-11-13 02:14:46 lastUpdateTime=2020-11-13 02:14:46 signatures=PackageSignatures{e438806 version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] requested permissions: install permissions: User 0: ceDataInode=950286 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false Package [com.android.messaging] (656fd19): userId=10065 pkg=Package{e7d91de com.android.messaging} codePath=/system/app/messaging versionCode=10001040 minSdk=29 targetSdk=28 versionName=1.0.001 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{d9cefbf com.android.messaging} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE ] dataDir=/data/user/0/com.android.messaging supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesLibraries: android.hidl.manager-V1.0-java android.hidl.base-V1.0-java usesLibraryFiles: /system/framework/android.hidl.manager-V1.0-java.jar /system/framework/android.hidl.base-V1.0-java.jar timeStamp=2020-11-13 02:14:42 firstInstallTime=2020-11-13 02:14:42 lastUpdateTime=2020-11-13 02:14:42 signatures=PackageSignatures{998768c version:3, signatures:[b4addb29], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ] requested permissions: android.permission.CALL_PHONE install permissions: User 0: ceDataInode=950337 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3003] runtime permissions: android.permission.CALL_PHONE: granted=true, flags=[ // granted=true 证明该pkg已经获得了权限 GRANTED_BY_DEFAULT|USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] Package [com.android.dialer] (15fd569): userId=10085 pkg=Package{10a0bee com.android.dialer} codePath=/system/product/priv-app/Dialer versionCode=2900000 minSdk=29 targetSdk=28 versionName=23.0 splits=[base] apkSigningVersion=3 applicationInfo=ApplicationInfo{8fdc88f com.android.dialer} flags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] privateFlags=[ PRIVATE_FLAG_ACTIVITIES_RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION PRIVATE_FLAG_REQUEST_LEGACY_EXTERNAL_STORAGE PARTIALLY_DIRECT_BOOT_AWARE PRIVILEGED PRODUCT ] dataDir=/data/user/0/com.android.dialer supportsScreens=[small, medium, large, xlarge, resizeable, anyDensity] usesLibraries: android.hidl.manager-V1.0-java android.hidl.base-V1.0-java org.apache.http.legacy usesLibraryFiles: /system/framework/android.hidl.manager-V1.0-java.jar /system/framework/android.hidl.base-V1.0-java.jar /system/framework/org.apache.http.legacy.jar timeStamp=2020-11-13 02:16:32 firstInstallTime=2020-11-13 02:16:32 lastUpdateTime=2020-11-13 02:16:32 signatures=PackageSignatures{4c4271c version:3, signatures:[9542d9b9], past signatures:[]} installPermissionsFixed=true pkgFlags=[ SYSTEM HAS_CODE ALLOW_CLEAR_USER_DATA ALLOW_BACKUP ] requested permissions: android.permission.CALL_PHONE install permissions: User 0: ceDataInode=950512 installed=true hidden=false suspended=false stopped=false notLaunched=false enabled=0 instant=false virtual=false gids=[3002, 3003, 3001] runtime permissions: android.permission.CALL_PHONE: granted=true, flags=[ GRANTED_BY_DEFAULT|USER_SENSITIVE_WHEN_GRANTED|USER_SENSITIVE_WHEN_DENIED] dialer！！！ 比如：android.permission.CALL_PHONE 权限，有了这个权限，可以调用打电话的APP(自然，它声明了) TODO: 这个查看结果，使用户设置之后的嘛？ 6. 参考： https://blog.csdn.net/Liu1314you/article/details/77368585 Android 权限的一些细节 https://developer.android.com/reference/android/Manifest.permission.html ------>完整版的权限表 https://www.jianshu.com/p/6c755ca6a3a3 https://blog.csdn.net/hanhan1016/article/details/105864367 Android权限 - 查看应用权限信息 https://www.cnblogs.com/andy-songwei/p/10638446.html Android安全之（一）权限篇 https://blog.csdn.net/li6151770/article/details/52782141 Android调用打电话(Call Phone) 7. 格式 点击展示 隐藏 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/refactor.html":{"url":"coding/Andriod/refactor.html","title":"Refactor","keywords":"","body":"1. 重构1. 重构 教程： https://www.bilibili.com/video/BV1mr4y1V7aD/?spm_id_from=333.788&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 文档：https://hardcore.feishu.cn/docx/doxcn4HcvfoSVUvkLALvzfD4B5c console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/startAPP.html":{"url":"coding/Andriod/startAPP.html","title":"Start APP","keywords":"","body":"1. 目录2. APP启动流程（纵向主线）2.1. 0层模型2.2. ----具体代码流程分析，所有围绕最终目标叙述-----2.3. 创建ActivityRecord/解析启动参数阶段2.4. 处理ActivityStack 阶段 -------总脉络2.5. 补充问题【1】：旧的Activity先要pause2.6. 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在2.6.1. AMS 通知 Zygote进程2.7. ZygoteServer 接受消息后，fork流程（关键流程1）2.7.1. 总之：2.7.2. 次要补充：linux fork() 函数2.7.3. ActivityThread的 main函数起来2.8. APP进程起来后，attach过程（关键流程2）2.8.1. 补充：APP侧 handleBindApplication2.9. ActivityB 真正启动流程 realStart2.9.1. 补充：生命周期同步到APP侧2.9.2. 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)2.10. 启动ActivityA的Activity stop阶段2.11. TODO:2.12. 面试问题：2.12.1. 为什么APP不能直接启动进程？2.12.2. 为什么使用socket而不使用binder？（网易二面）TreeviewCopyright © aleen42 all right reserved, powered by aleen42 目录 APP启动流程（纵向主线） 0层模型 ----具体代码流程分析，所有围绕最终目标叙述----- 创建ActivityRecord/解析启动参数阶段 处理ActivityStack 阶段 -------总脉络 补充问题【1】：旧的Activity先要pause 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在 AMS 通知 Zygote进程 ZygoteServer 接受消息后，fork流程（关键流程1） 总之： 次要补充：linux fork() 函数 ActivityThread的 main函数起来 APP进程起来后，attach过程（关键流程2） 补充：APP侧 handleBindApplication ActivityB 真正启动流程 realStart 补充：生命周期同步到APP侧 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构) 启动ActivityA的Activity stop阶段 TODO: 面试问题： 为什么APP不能直接启动进程？ 为什么使用socket而不使用binder？（网易二面） 1. 目录 [TOC] 2. APP启动流程（纵向主线） 桌面 ---> APP 2.1. 0层模型 （图： https://blog.csdn.net/hzwailll/article/details/85339714） 图：startApp.eddx APP启动流程，总之： 1、皇子继位模型 2、整个模型的目的：fork 新进程。搭建两条桥梁（6和8） -生活化模型：皇子继位模型 记忆： 皇帝想要皇子继承皇位 -----> 通知太监总管 -----> 让皇妃 ----> 生皇子 人物： 皇帝，控制生死：Launcher进程，其他APP进程的生死 控制者 太监总管，传递皇帝旨意、管理宫里所有人:皇妃，生子: fork出新的app进程 皇子，成长成为一个人: APP创建页面等等 龙袍：activity 继位：龙袍处于民众面前（activity前台位置） 民众：手机使用者 联系方式ApplicationThreadProxy，本质是Binder 显然，基于生活模型，不得不的一些东西: 1、皇帝、总管、皇妃在建国时(系统启动时) 才有的 -----> 自然 2、皇帝和皇子都可以传唤 太监总管: 所以都持有 总管的引用 ActivityManagerProxy -----> 自然 ​ 反过来，总管也能联系 皇帝 和皇子：通过 联系方式Binder -----> 自然 3、皇子生下来之后，继承皇位事宜：启动自己的驴拉磨Looper、长了自己的脸Acitivity -----> 自然 4、总管 管理所有皇家联系方式Binder，从而总管 可以找到 任何皇室成员 -----> 自然 5、皇帝和皇子，本质是一个东西：APP进程。所以，和AMS 的两条桥梁是一样的 ---> 自然 6、为啥皇妃与外界的联系都是socket？ 7、化简桥梁1和2：自然，皇帝和皇子，与AMS联系是一样的：1与6无差异，2与8无差异 整个流程： 皇帝 想要 皇子APP1继承皇位， 皇帝通知 太监总管来安排（AMS）。自然，startActivity 太监总管通知老皇帝准备退位（launcher的黄袍Acitivity到paused状态） -----> 自然 （2） 太监总管 找对应的皇子 ，如果找到，自然是新皇子继承皇位（皇子activity到前台），直接scheduleLaunchActivity，没有socket和fork。所有流程结束 -----> 自然 ​ 如果没找到，太监总管安排皇妃Zygote来生皇子 -----> 自然 （3）皇妃生皇子，皇子诞生（Zygote fork出新进程APP1进程） （4）皇子生下来后，第一件事情是：开始生长：生长了自己的骨架(驴拉磨Looper)，但是此时龙袍肯定还没做， 没那么着急 （5）皇子生下来后，第二件事情是：向总管注册联系方式ApplicationThread，从而总管可以联系他 （6）总管知道皇子已经诞生。所以，总管通过 联系方式Binder 通知皇子 计划安排（ shedule）新皇子继位 shedulelaunchActivity （7）对于皇子这边，就处理继承皇位的一些事宜handleLaunchActivity：制作自己的龙袍Acitivity.onCreate(在这个流程里，可以自定义各种各样龙袍，豪装还是简装都可以) （8）龙袍Acitivity，到了前台，被民众看见，就继承皇位完毕。整个流程结束 -----> 自然 （9）新皇帝完成了登基的所有事情，就通知总管，让老皇帝不要再哔哔了Stop -----> 自然 疑问点： 为啥 总管 通知皇妃 通过socket ？？？？产子也是 Activity启动： 同进程启动(ActivityA 启动 ActivityB) 进程间启动(launcher启动 ActivityB)：涉及到新进程的启动fork 2.2. ----具体代码流程分析，所有围绕最终目标叙述----- -最终目标是 锚，挂满了所有逻辑 最终目标：真正的启动ActivityB 2.3. 创建ActivityRecord/解析启动参数阶段 围绕最终目标(真正的启动ActivityB), 所以为其创建 目标 ActivityRecord，并找到对应的 ActivityStack（自然，交给其去处理） 注：Mainactivty.startActivity(Intent) 是APP使用的入口（熟悉的入口） 原来ATMS就是AMS一部分, 在意识里不要分开（不要区分两者，ATMS管理Activity，这里自然是ATMS） ATMS是管理Activity的，其中 ActivityStartController 管理启动功能start（而且是很多Activity的） ---》 自然 对应关系： ATMS:管理 所有Activity的所有功能 ---> ActivityStartController 管理所有Activity启动功能start ---> ActivityStarter对应一个Activity的start 该阶段核心类： ActivityStarter ---> 自然，因为其负责启动流程 关键函数： 目标 ActivityRecord创建： ActivityStarter.startActivity() 为待启动的Activity创建 ActivityRecord() 源 ActivityRecord的寻找：sourceRecord = mRootActivityContainer.isInAnyStack(IBinder token); 通过token找到 TODO: 目标 ActivityRecord 对应的 ActivityStack ，即targetStack？？？？ TODO: 按道理此时会有很多 栈管理。比如resumeFocusedStacksTopActivities过程。代码级分析 栈管理 TODO: 图中，启动黑白屏流程 ----》 APP启动流程优化课程 TODO: mIntent的流转流程 2.4. 处理ActivityStack 阶段 -------总脉络 围绕最终目标(真正的启动ActivityB), 所以为其创建 目标 ActivityRecord，----》 自然交给 AMS 著名的栈管理 由ActivityStack 管理和启动 ActivityB 该阶段核心类： ActivityStack ---》 管理 activity栈的 关键函数： 记忆，总之：两个问题 1、实际上 resume函数进来两次，为啥呢？ 因为第一次进来，发现问题 【1】： 老的Activity还在可交互，先pause一把 第二次进来，其实也发现问题 【2】：新的process还不存在 但第三次的时候，并没有从resume进，而是直接到了 14 realStartartActivity 2、上述图画的不是调用关系，只是时间上的 3、实际上涉及到很多线程（图中只体现了一个） 证明： 目标：真正的启动ActivityB //第一次resume： 关注触发点 和 终止点 Breakpoint reached at com.android.server.wm.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2625) // 终止点: 启动新的过程中，发现问题 【1】：发现旧的还在，旧的先要pause呀 ---》 所以，跑去pause at com.android.server.wm.ActivityStack.resumeTopActivityUncheckedLocked(ActivityStack.java:2575) at com.android.server.wm.RootActivityContainer.resumeFocusedStacksTopActivities(RootActivityContainer.java:1158) at com.android.server.wm.ActivityStarter.startActivityUnchecked(ActivityStarter.java:1728) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:1394) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:933) at com.android.server.wm.ActivityStarter.startActivity(ActivityStarter.java:583) at com.android.server.wm.ActivityStarter.startActivityMayWait(ActivityStarter.java:1288) at com.android.server.wm.ActivityStarter.execute(ActivityStarter.java:514) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1058) at com.android.server.wm.ActivityTaskManagerService.startActivityAsUser(ActivityTaskManagerService.java:1032) at com.android.server.wm.ActivityTaskManagerService.startActivity(ActivityTaskManagerService.java:1009) // 触发点： laucher或其他应用StartActvity at android.app.IActivityTaskManager$Stub.onTransact(IActivityTaskManager.java:1486) at android.os.Binder.execTransactInternal(Binder.java:1021) at android.os.Binder.execTransact(Binder.java:994) sub Thread name is Binder:8184_2, 17, 2021-10-09 13:27:27:016 //第二次 resume： Breakpoint reached at com.android.server.wm.ActivityStack.resumeTopActivityInnerLocked(ActivityStack.java:2625) at com.android.server.wm.ActivityStack.resumeTopActivityUncheckedLocked(ActivityStack.java:2575)// 【2】终止点: 又发现问题了，新的进程都没有呢----》跑去创建process at com.android.server.wm.RootActivityContainer.resumeFocusedStacksTopActivities(RootActivityContainer.java:1158) at com.android.server.wm.ActivityStack.completePauseLocked(ActivityStack.java:1839) at com.android.server.wm.ActivityStack.activityPausedLocked(ActivityStack.java:1766) // 触发点： 前一个activityPaused at com.android.server.wm.ActivityStack$ActivityStackHandler.handleMessage(ActivityStack.java:451) at android.os.Handler.dispatchMessage(Handler.java:107) at android.os.Looper.loop(Looper.java:214) at android.os.HandlerThread.run(HandlerThread.java:67) at com.android.server.ServiceThread.run(ServiceThread.java:44) sub Thread name is android.display, 22, 2021-10-09 13:27:29:041 // display线程 //新的process创建后，attachApplication Breakpoint reached at com.android.server.wm.ActivityStackSupervisor.realStartActivityLocked(ActivityStackSupervisor.java:708)// 【3】最终真正StartActivity的地方！！！！！！！！ at com.android.server.wm.RootActivityContainer.attachApplication(RootActivityContainer.java:783) at com.android.server.wm.ActivityTaskManagerService$LocalService.attachApplication(ActivityTaskManagerService.java:6869) at com.android.server.am.ActivityManagerService.attachApplicationLocked(ActivityManagerService.java:5103) at com.android.server.am.ActivityManagerService.attachApplication(ActivityManagerService.java:5180)// 触发点：新的process创建后，attachApplication at android.app.IActivityManager$Stub.onTransact(IActivityManager.java:2003) at com.android.server.am.ActivityManagerService.onTransact(ActivityManagerService.java:2741) at android.os.Binder.execTransactInternal(Binder.java:1021) at android.os.Binder.execTransact(Binder.java:994) sub Thread name is Binder:8184_13, 228, 2021-10-09 13:27:36:361 2.5. 补充问题【1】：旧的Activity先要pause TODO 简略 触发点：startActivty之前，先pause老的 结果：puased之后，再继续走resume新的 2.6. 补充问题【2】：AMS 判断 所要启动的Activity对应的进程 是否存在 自然：启动ActivityB，发现的问题 逻辑： 如果存在，直接启动。即0层架构图中的 7和8 如果不存在，则 通知 zygote进程去fork一个新的APP进程 调用栈： Binder线程： startSpecificActivityLocked:961, ActivityStackSupervisor (com.android.server.wm) // 栈管理判断 resumeTopActivityInnerLocked:3037, ActivityStack (com.android.server.wm) resumeTopActivityUncheckedLocked:2575, ActivityStack (com.android.server.wm) resumeFocusedStacksTopActivities:1158, RootActivityContainer (com.android.server.wm) // 核心？？？ completePauseLocked:1839, ActivityStack (com.android.server.wm) activityPausedLocked:1766, ActivityStack (com.android.server.wm) activityPaused:1699, ActivityTaskManagerService (com.android.server.wm) //【1】 onTransact:1981, IActivityTaskManager$Stub (android.app) execTransactInternal:1021, Binder (android.os) execTransact:994, Binder (android.os) 可以看出：1、必须要等老皇帝paused，才会 resumeTopActivity ，自然 2、 resumeTopActivity发现没有，才fork新进程的，自然 对应代码： void startSpecificActivityLocked(ActivityRecord r, boolean andResume, boolean checkConfig) { // Is this activity's application already running? .......... if (wpc != null && wpc.hasThread()) { // cg: if APP process is created, start APP Activity directly try { realStartActivityLocked(r, wpc, andResume, checkConfig); return; } .......... } try { .......... // Post message to start process to avoid possible deadlock of calling into AMS with the // ATMS lock held. final Message msg = PooledLambda.obtainMessage( // cg: if APP process is not created,create it. ActivityManagerInternal::startProcess, mService.mAmInternal, r.processName, r.info.applicationInfo, knownToBeDead, \"activity\", r.intent.getComponent()); mService.mH.sendMessage(msg); .......... } 注意： AMS侧： 功能划分： 1、ATMS拿到paused消息，通知 栈管理ActivityStackSupervisor判断 有没进程：相当于ATMS----> ActivityStackSupervisor 2、栈管理把 判断结果，返回给ATMS和 AMS，AMS让 ProcessList去处理 : ActivityStackSupervisor ----> ATMS ----> AMS ----> ProcessList TODO: 从数据结构/代码架构角度，如何保证 功能上，AMS统领全局？？？？？？？？？ 2.6.1. AMS 通知 Zygote进程 触发点： 已经判断没有进程 记忆： 基于0层框架 ，~AMS ----> zygote进程阶段 目的：通知zygote fork一个App进程，即startProcess，自然 途径：通过socket 通信（流） 自然: 之前会 封装一系列参数 以构建socket消息， startViaZygote 为什么ATMS,最终要调用要回到ams, 最终要处理，但atms没有processList 2.7. ZygoteServer 接受消息后，fork流程（关键流程1） 2.7.1. 总之： ZygoteServer是一个socket服务器，在runSelectLoop轮询消息(死循环)，自然是必然的 （TODO: 轮询的epoll机制） 1、轮询到消息后，fork出 APP process (自然，fork需要参数，这个参数来自于socket的对端，解析出来的) 2、在 APP process中，先关闭Server Socket， 自然，因为用不到 ​ 初始化 RuntimeInit ​ 启动binder驱动（利用AndroidRuntime）？ 启动线程池 ​ 反射调用ActivityThread的 main函数，从而主线程起来 RuntimeInit.commonInit(); //cg: init Runtime. Two APPs have different runtime. ZygoteInit.nativeZygoteInit(); // cg: init Binder/Binder ThreadPool return RuntimeInit.applicationInit(targetSdkVersion, argv, classLoader); // cg: invotes ActivtyThread's main method by reflecting 代码： //ZygoteConnection.java //cg: nativeForkAndSpecialize a process for APP. Return 0 and 1 pid = Zygote.forkAndSpecialize(......); try { if (pid == 0) { // cg: in child process. APP process // in child zygoteServer.closeServerSocket(); // cg: Only zygote process needs socket server ...... return handleChildProc(parsedArgs, descriptors, childPipeFd, //cg: 反射获取 parsedArgs.mStartChildZygote); } else { // cg: zygote process // In the parent. A pid 启动binder驱动、 启动线程池： TODO // ProcessState.cpp mDriverFD(open_driver(driver)); // app_main.cpp proc->startThreadPool(); 对于fork出来的APP进程： 2.7.2. 次要补充：linux fork() 函数 nativeForkAndSpecialize具体如何fork的 -----》zygote视频 结论： 1、返回次数：一般说法为：fork函数 一定会返回两次。 但其实就是一次，子进程的返回，返回在子进程；父进程的返回，返回在父进程，自然 原因：在调用fork的时候，完全复制出另一个process（包括其属性都一样） 自然，原来进程 和 fork出的进程，都走在执行fork函数，所以会有两处返回点 -----》 TODO: 深入理解linux fork过程 ----》TODO: 返回pid=0子进程。那么,何时pid变的不为0? 2、关于返回值：fork返回值0，返回的是孩子进程 ；返回值 > 0, 说明是Zygote进程返回；返回值-1，fork失败 3、，在fork节点前的变量，在fork之后，被copy到两个进程里，独立运行，互不影响。 https://blog.csdn.net/m0_51242270/article/details/128086849?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-128086849-blog-126355841.pc_relevant_3mothn_strategy_and_data_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EYuanLiJiHua%7EPosition-3-128086849-blog-126355841.pc_relevant_3mothn_strategy_and_data_recovery&utm_relevant_index=6 int main() { std::cout pid为进程号 注意：新fork出的进程，与zygote进程完全一样（除了一些） 2.7.3. ActivityThread的 main函数起来 （锚点）基于0层模型，主要做的事情： 1、创建了主线程的 驴拉磨Looper，并让死循环跑起来 2、向AMS 注册 ActivityThread的Binder 即IApplicationThread: attachApplication 2.8. APP进程起来后，attach过程（关键流程2） 一句话： 从APP角度, APP向AMS attach ActivityThread的Binder 即IApplicationThread 从AMS角度, AMS侧 bind Application AMS.attachApplicationLocked() 具体做了哪些事情呢？ 基于逻辑，推断： 1、AMS将新生儿的姓名、appInfo等同步给APP（此时新生儿白纸一张，和zygote一样）调用了APP.bindApplication ： AMS侧：thread.bindApplication(processName, appInfo, providers.........) ----> 基于刚搭建的桥梁AMS-->APP APP侧： 见 补充APP侧handleBindApplication章节 2、必然注册ApplicationThread给了AMS，存储在AMS的PorcessRecord，最终存在mLruProcesses 中----》自然，桥梁ApplicationThread的流转过程 3、必然执行Activity启动流程， 见下realStart ----》自然，最终目的 // AMS.Java private final boolean attachApplicationLocked(IApplicationThread thread, int pid, int callingUid, long startSeq) { // Find the application record that is being attached... either via // the pid if we are running in multiple processes, or just pull the // next app record if we are emulating process with anonymous threads. ProcessRecord app; long startTime = SystemClock.uptimeMillis(); long bindApplicationTimeMillis; if (pid != MY_PID && pid >= 0) { synchronized (mPidsSelfLocked) { app = mPidsSelfLocked.get(pid); // cg: inited in handleProcessStartedLocked method. } 。。。。。。。 } } ............ try { AppDeathRecipient adr = new AppDeathRecipient( app, pid, thread); thread.asBinder().linkToDeath(adr, 0); app.deathRecipient = adr; // cg: App Death Listner 死亡监听. http://t.zoukankan.com/xiayexingkong-p-6762569.html } app.curAdj = app.setAdj = app.verifiedAdj = ProcessList.INVALID_ADJ; app.setCurrentSchedulingGroup(app.setSchedGroup = ProcessList.SCHED_GROUP_DEFAULT); app.forcingToImportant = null; updateProcessForegroundLocked(app, false, 0, false); app.hasShownUi = false; app.setDebugging(false); app.cached = false; app.killedByAm = false; app.killed = false; thread.bindApplication(processName, appInfo, providers.........) // cg: 关键流程！！！！将大量APP信息 同步给APP（此时APP还和zygote进程一模一样呢，），比如进程名，appInfo try { ........ app.makeActive(thread, mProcessStats); // cg: IApplicationThread of APP is bound to ProcessRecord. 这也就是后面AMS能调用 APP进程的原因 mProcessList.updateLruProcessLocked(app, false, null); //cg: Finally processRecord is added to mLruProcesses 最终存在mLruProcesses里 ........ } ........ } 2.8.1. 补充：APP侧 handleBindApplication 参考：https://blog.csdn.net/chupu2979/article/details/100616862 https://blog.csdn.net/innost/article/details/47254381 一句话总结handleBindApplication： handleBindApplication主要工作是初始化APP（APP由zygote进程fork而来，在hanldeBindApplication之前，这个APP进程和zygote没什么区别。只有调用完handleBindApplication之后，这个APP进程才是APP, 比如该进程有了对应的名字，Aplication对象被创建等）。 具体： private void handleBindApplication(AppBindDatadata) { mBoundApplication = data; mConfiguration = new Configuration(data.config); mCompatConfiguration = new Configuration(data.config); //初始化性能统计对象 mProfiler = new Profiler(); mProfiler.profileFile = data.initProfileFile; mProfiler.profileFd = data.initProfileFd; mProfiler.autoStopProfiler = data.initAutoStopProfiler; //设置进程名。从此，之前那个默默无名的进程终于有了自己的名字 Process.setArgV0(data.processName); android.ddm.DdmHandleAppName.setAppName(data.processName); if(data.persistent) { //对于persistent的进程，在低内存设备上，不允许其使用硬件加速显示 Display display = WindowManagerImpl.getDefault().getDefaultDisplay(); //当内存大于512MB，或者屏幕尺寸大于1024*600，可以使用硬件加速 if(!ActivityManager.isHighEndGfx(display)) HardwareRenderer.disable(false); } //启动性能统计 if(mProfiler.profileFd != null) mProfiler.startProfiling(); //如果目标SDK版本小于12，则设置AsyncTask使用pool executor，否则使用 //serializedexecutor。这些executor涉及Java Concurrent类，对此不熟悉的读者 //请自行学习和研究。 if(data.appInfo.targetSdkVersion 9) StrictMode.enableDeathOnNetwork(); //如果没有设置屏幕密度，则为Bitmap设置默认的屏幕密度 if((data.appInfo.flags &ApplicationInfo.FLAG_SUPPORTS_SCREEN_DENSITIES) == 0) Bitmap.setDefaultDensity(DisplayMetrics.DENSITY_DEFAULT); if(data.debugMode != IApplicationThread.DEBUG_OFF){ ......//调试模式相关处理 } IBinder b= ServiceManager.getService(Context.CONNECTIVITY_SERVICE); IConnectivityManager service = IConnectivityManager.Stub.asInterface(b); try { //设置Http代理信息 ProxyPropertiesproxyProperties = service.getProxy(); Proxy.setHttpProxySystemProperty(proxyProperties); } catch(RemoteException e) {} if(data.instrumentationName != null){ //在正常情况下，此条件不满足 } else { //创建Instrumentation对象，在正常情况都再这个条件下执行 mInstrumentation = new Instrumentation(); } //如果Package中声明了FLAG_LARGE_HEAP，则可跳过虚拟机的内存限制，放心使用内存 if((data.appInfo.flags&ApplicationInfo.FLAG_LARGE_HEAP) != 0) dalvik.system.VMRuntime.getRuntime().clearGrowthLimit(); //创建一个Application，data.info为LoadedApk类型，在其内部会通过Java反射机制 //创建一个在该APK AndroidManifest.xml中声明的Application对象 Applicationapp = data.info.makeApplication( data.restrictedBackupMode, null); //mInitialApplication保存该进程中第一个创建的Application mInitialApplication = app; //安装本Package中携带的ContentProvider if(!data.restrictedBackupMode){ List providers = data.providers; if(providers != null) { //installContentProviders我们已经分析过了 installContentProviders(app, providers); mH.sendEmptyMessageDelayed(H.ENABLE_JIT, 10*1000); } } //调用Application的onCreate函数，做一些初始工作 mInstrumentation.callApplicationOnCreate(app); } 其中最重要的有： · 创建一个Application对象，该对象是本进程中运行的第一个Application。 · 如果该Application有ContentProvider，则应安装它们。 2.9. ActivityB 真正启动流程 realStart 途径：基于刚搭建的桥梁AMS-->APP 触发点（我来自哪里）： 见总脉络： ActivityManagerService.attachApplication 核心类（我是谁）： 栈管理 是 控制着启动，自然是 ActivityStackSupervisor 具体（做什么） ActivityStackSupervisor 创建生命周期封装类Transaction，交给 生命周期管理类，去同步给APP 2.9.1. 补充：生命周期同步到APP侧 不得不： 1、生命周期由AMS控制，通过事件ClientTranction 同步到APP 2、自然通过ActivityTread 跨进程 同步 3、binder线程过来，所以，会存在handler 转到主线程执行 -----》 自然，图中 Handler 舍弃 自然： 1、第一次，自然直接同步了resume过来。（自然APP端，先要create、start） 见： 2.9.2. 补充：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构) 核心函数： TransactionExecutor.execute(transaction); TransactionExecutor 执行器 触发流程： 自然是，realStart流程 触发了 ams的生命周期同步 ActivityThread 相关函数： handleLaunchActivity ---> performLaunchActivity ---> 【1】 创建Activity，并 attach() 创建window-----> onCreate （这里填充具体view） 【2】 handleStartActivity ---> performStartActivity -----> onStart handleResumeActivity ---> performResumeActivity -----> onResume 不得不： 1、【1】 ActivityThread.performLaunchActivity 目标是 创建activity、window、view树 ----> 自然，【1】不得不 2、在 Activity.attach() 中新建window（自然，并绑定windowManagerImpl） 3、onCreate中，APP开发者setContentView() 过程：为 开发者view 添加 最顶级view------DecorView，真正的viewTree TODO: 加强模型： 小的知识点： onCreate和onResume是AMS 同步来的 onStart是 APP侧执行器 自己算的（中间的生命周期状态都要执行cylceToPath） TODO: final void attach(Context context, ActivityThread aThread, Instrumentation instr, IBinder token, int ident, Application application, Intent intent, ActivityInfo info, CharSequence title, Activity parent, String id, NonConfigurationInstances lastNonConfigurationInstances, Configuration config, String referrer, IVoiceInteractor voiceInteractor, Window window, ActivityConfigCallback activityConfigCallback, IBinder assistToken) { attachBaseContext(context); mFragments.attachHost(null /*parent*/); mWindow = new PhoneWindow(this, window, activityConfigCallback);//cg: new window mWindow.setWindowControllerCallback(this); mWindow.setCallback(this);//cg: Activity之所以可以得到事件等消息的来源：Callback: dispatchKeyEvent、onWindowFocusChanged、onWindowAttributesChanged 关于handleResumeActivity流程----》 TODO: 新起章节 //ActivityThread.java public void handleResumeActivity(){ final ActivityClientRecord r = performResumeActivity(token, finalStateRequest, reason);//cg: onResume wm.addView(decor, l); //cg: keyProcess.显示： 调用 WindowManagerImpl 将decorview 添加到window系统中 Looper.myQueue().addIdleHandler(new Idler()); //cg: key process. Idler事件，关闭ActivityA 【Idler事件】 } 所以，先调用的 onResume之后，再显示的 -------》 但对于开发者，这两个先后顺序不重要，因为：都是在一个消息处理流程里，中间不可能断，都会一起执行完 2.10. 启动ActivityA的Activity stop阶段 最后一步，老皇帝行将就木stop 触发点：新皇帝完成了登基的所有事情，就通知总管，让老皇帝不要再哔哔了Stop： ActivityB 完成了所有生命周期的 同步（onCreate、onStart、onResume）。 在handleResumeActivity 最后一刻，通知ATMS，关闭ActivityA （生命周期的同步~）。见【Idler事件】 TODO: Idler事件 什么时候执行呢？当 Looper里没有可执行的消息了 ------》 这就解释了，停止ActivityA 是有空闲时，才做的 2.11. TODO: ApplicationThread是binder线程池一个线程 AMS也是嘛？ 2.12. 面试问题： 1、setContentView 2.12.1. 为什么APP不能直接启动进程？ 1、安全性角度：如果那样就见鬼了，APP自己是应用进程，开辟进程是非常危险的操作，必须由专人做专门的事。 2、性能角度（时间上、空间上）：都由Zygote进fork，可以 共享（write时复制），比APP自己加载资源，要快的多、内存开销小（如果是共享，基本上没开销） 2.12.2. 为什么使用socket而不使用binder？（网易二面） android中AMS通知Zygote去fork进程流程，为什么使用socket而不使用binder？ 参考： https://blog.csdn.net/cpcpcp123/article/details/127990882 https://blog.csdn.net/rzleilei/article/details/125770598 原因一： 1. 先后时序问题： 基于 启动系统的0层图， 如果用Zygote进程使用binder被通信 ------> 自然，在 Zygote进程 在加载过程中，需要注册服务给ServiceManager（但此时有可能ServiceManager没有初始化好） 简言之： 问题在于 不能保证ServiceManger先初始化好（因为两个进程是并行的） 补充： 图中1、2、3、4只是开始创建的时序。不是创建好的时序！！！！ 拓展问题： 等ServiceManager完全初始化好再去注册不就好了吗？ ----》 这个等，两种处理： （1）、完全初始化好，通知 -----> 这个通知也垮了进程，设计冗余 （2）、延时10ms ----> 垃圾做法 2、Linux多线程的fork存在问题 背景： Linux中，fork进程其实并不是完美的fork，linux设计之初只考虑到了主线程的fork，也就是说如果主进程中存在子线程，那么fork进程中，其子线程的锁状态，挂起状态等等都是不可恢复的，只有主进程的才可以恢复。 TODO: 所以Zygote进程，只有主线程？？？？ binder线程状态 在fork过程中存在问题： binder作为典型的CS模式，其在Server是通过线程来实现的，Server等待请求状态时，必然是处于一种挂起的状态。所以如果使用binder机制，zygote进程fork子进程后，子进程的binder的Server永远处于一种挂起不可恢复的状态，这样的设计无疑是非常差的。 3、内存问题： 进程的fork，各种内存对象自然也会被拷贝（是拷贝一个和原进程一摸一样的进程）。 --------> 如果用socket，占内存，-------> 所以 关闭socket（fork两次返回时，判断是子线程时） --------> 如果用binder，占内存 -------> 无法释放，binder成对存在？成对释放？所以需要释放AMS端的client binder Binder的特殊性在于其是成对存在的，其分为Client端对象和Server端对象。假设我们使用binder，那么因为APP端的binder是拷贝自Zygote进程的，所以如果要释放掉APP的Server端binder引用对象，就必须释放掉AMS中的Client端binder对象，那这样就会导致AMS失去binder从而无法正常向Zygote发送消息。 总之： 以上问题都是不致命的，所以，可以强行用binder console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/Systrace.html":{"url":"coding/Andriod/Systrace.html","title":"Systrace","keywords":"","body":"1. Android系统性能调优工具介绍2. TraceView---可以看调用栈2.1. TraceView应用场景2.2. TraceView工具的使用2.2.1. 工具原理3. Systrace3.1. Systrace场景3.2. Systrace工具的使用3.2.1. 代码中触发3.2.2. 命令行3.2.3. 键盘快捷键3.2.4. 使用命令行捕获Systreace报告文件3.2.5. 阅读报告3.2.6. 看报告操作3.2.7. 技巧：3.3. Systrace的原理3.3.1. 开源代码3.4. 遇到的坑：4. Oprofile5. Layout Inspector6. winscope(快照)---闪屏问题6.1. 参考：6.2. 官方文档7. 一些环境使用原则：8. 参考9. 补充，脚本TreeviewCopyright © aleen42 all right reserved, powered by aleen42 Android系统性能调优工具介绍 TraceView---可以看调用栈 TraceView应用场景 TraceView工具的使用 工具原理 Systrace Systrace场景 Systrace工具的使用 代码中触发 命令行 [options] [categories] 哪些模块 键盘快捷键 使用命令行捕获Systreace报告文件 阅读报告 状态不同的线程： 线程唤醒者分析 如何找唤醒过程对应的代码级呢？ 看报告操作 技巧： Systrace的原理 开源代码 遇到的坑： Oprofile Layout Inspector winscope(快照)---闪屏问题 参考： 官方文档 一些环境使用原则： 参考 补充，脚本 1. Android系统性能调优工具介绍 TraceView、Systrace、Oprofile 2. TraceView---可以看调用栈 2.1. TraceView应用场景 2.2. TraceView工具的使用 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation 形成一个图表，从中可以分析出每个方法的执行时间 2.2.1. 工具原理 3. Systrace 3.1. Systrace场景 3.2. Systrace工具的使用 3.2.1. 代码中触发 Trace.beginsection (\"onConfigurationChanged\"); // systemTrace, 性能 ................... Trace.endSection(); Trace.asyncTraceBegin ................... Trace.asyncTraceEnd 3.2.2. 命令行 python systrace.py [options] [categories] [options] [categories] 哪些模块 例子： python systrace.py -o mynewtrace.html sched freq idle am wm gfx view \\ binder_driver hal dalvik camera input res my例子： python systrace.py -o mynewtrace.html \\ -a com.example.aospsourcecode2 com.android.launcher3 \\ sched freq idle am wm sm input view 3.2.3. 键盘快捷键 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation 3.2.4. 使用命令行捕获Systreace报告文件 3.2.5. 阅读报告 方法一：使用 chrome://tracing/ 方法二：直接点html，这样有进程名，更优 状态不同的线程： 参考： https://www.androidperformance.com/2019/07/23/Android-Systrace-Pre/#/%E6%AD%A3%E6%96%87 绿色 --> 运行中 Running 对于在CPU上执行的进程，需要查看其运行时间、是否跑在该跑的核上、频率是否够等。 蓝色 --> 可运行 Runnable 对于在等待序列中的进程，需要查看是否有过多任务在等待、等待时间是否过长等。 白色 --> 休眠中 Sleeping 这里一般是在等事件驱动。 橘色 --> 不可中断的睡眠态_IO_Block Uninterruptible Sleep | WakeKill - Block I/O 线程在I / O上被阻塞或等待磁盘操作完成。 紫色 --> 不可中断的睡眠态 Uninterruptible Sleep 线程在另一个内核操作（通常是内存管理）上被阻塞。 -上述自然，生活化模型：颜色- 红绿灯颜色 注,也可以点击线程位置,看 线程唤醒者分析 注意: 看似函数一直在走,但是线程已经 sleep了. 说明函数运行 sleep了. 细长条代表线程运行。白色表示sleep了 线程唤醒者: 图中: 前蓝后绿部分,很短暂 如何找哪个线程唤醒该线程的？操作： 标尺固定时间段, 找到cpu对应这个宽度的task：必然是四个当中一个 通过看tid 17889确定 ---> 是launcher的render线程做的 即结论：render线程唤醒了ui线程 如何找唤醒过程对应的代码级呢？ 3.2.6. 看报告操作 3.2.7. 技巧： 通过在时间间隔周围绘制一个矩形来选择所需的时间间隔。 使用标尺工具标记或突出显示问题区域。 依次点击 View Options > Highlight VSync，以显示每项显示屏刷新操作-------> 标出一帧 筛选Processes 5、加了界限后，立马切换其他模式 ----> 这样界线可以长久保存 3.3. Systrace的原理 参考： https://blog.csdn.net/feelabclihu/article/details/106247862 好文 简易的流程图： 具体实现： Systrace抓取的trace数据，总体上可以分为两类： 一类是Java和Native在用户层发生的函数调用，一类是内核态的事件信息。 3.3.1. 开源代码 systrace的生母，谷歌开源项目https://chromium.googlesource.com/catapult。 3.4. 遇到的坑： 1、platform-tools下找不到systrace文件夹 https://www.jianshu.com/p/626eaebaa6a8 4. Oprofile 5. Layout Inspector 最优观察viewTree的工具 -优点： （1）图形化 ，更深刻 （2）图形与 文字相结合，并且可以点击互动 -----> 操作方便，对应关系非常明确 （3）实际上，显示的数据 比xml显示的更加完整。比如这里，显示了 “微博热搜”的小程序按钮。。。。xml没有体现 （4）可以在左边搜索。。。。当页面 view过多时，可以精确区分（图形区域不容易区分） （5）同dump一样，可以知道 TextView 具体的类 6. winscope(快照)---闪屏问题 winscope本质： -每一帧，都给整个系统拍快照 ----> 这也是理解复杂系统的关键 ---------------> 基于帧，1、所以，才可以解决闪屏问题 ​ 2、TODO: 肯定可以解决其他很多问题 方法一： winscope.html + winscope_proxy.py ----> 直接获取（封装的adb命令） 方法二：直接使用adb命令，见下，官方文档 TODO: 问题的关键在于，如何看？ 1、每个Task有个Z值，是层级 6.1. 参考： https://source.android.com/docs/core/graphics/tracing-win-transitions?hl=zh-cn 官方文档 https://www.jianshu.com/p/c28a81dc3a65 6.2. 官方文档 https://developer.android.com/studio/debug/layout-inspector 7. 一些环境使用原则： 使用linux下as调试或trace，就不能用win下As ADB之间影响 8. 参考 https://www.androidperformance.com/2019/05/28/Android-Systrace-About/#/%E7%B3%BB%E5%88%97%E6%96%87%E7%AB%A0%E7%9B%AE%E5%BD%95 https://www.jianshu.com/p/a14bfdc4109a?utm_campaign=maleskine&utm_content=note&utm_medium=seo_notes&utm_source=recommendation https://blog.csdn.net/innost/article/details/9008691 https://blog.csdn.net/u011578734/article/details/109497064 9. 补充，脚本 adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 20s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory 网站: https://ui.perfetto.dev/#!/ 做系统稳定性问题分析，当遇到系统卡死时，我们经常要使用“kill -3 pid”来打印System_Server进程各个线程的Java调用栈，根据线程状态及调用栈来更进一步定位问题点，当然某个应该界面卡顿时间长时也可以通过这个命令来抓取Java调用栈进行分析。 注意native进程是不能用kill -3来打trace的，而是使用debuggerd. https://droid10.com/Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/WMS.html":{"url":"coding/Andriod/WMS.html","title":"WMS","keywords":"","body":"1. 目录2. window体系2.1. Window（次要）2.2. 常见window（次要）2.2.1. window的分类：2.2.2. 窗口的次序2.2.3. 窗口的标志2.3. WindowManger2.3.1. 接口ViewManager2.4. ViewRootImpl2.5. 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl2.6. view Tree--------window的填充+显示3. WMS3.1. 0层图3.2. WMS的功能（职责）-----what：3.2.1. 基于功能需要的对外接口（重要）3.3. 功能1的纵向：添加窗口(纵向主线) : WMS侧----how3.3.1. APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程:3.3.2. 目标功能1的补充：3.4. 功能3的纵向：申请surface流程----how3.5. 关于session桥梁???3.6. 次要：窗口的系统动画（基于窗口管理的辅助功能）4. 面试题：5. 参考：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 目录 window体系 Window（次要） 常见window（次要） window的分类： 窗口的次序 窗口的标志 WindowManger 接口ViewManager 添加窗口addView 流程: APP侧 更新窗口 updateViewLayout ViewRootImpl 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl view Tree--------window的填充+显示 WMS 0层图 WMS的功能（职责）-----what： 基于功能需要的对外接口（重要） 功能1的纵向：添加窗口(纵向主线) : WMS侧----how APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程: 目标功能1的补充： 目标1：如何确定窗口的大小和位置呢？ 功能3的纵向：申请surface流程----how 关于session桥梁??? 次要：窗口的系统动画（基于窗口管理的辅助功能） 面试题： 参考： 1. 目录 [TOC] 2. window体系 2.1. Window（次要） 一句话的大致理解：（1、很重要 2、自己的话 与 官方的话 相互结合） Window: 是一个碗，view才是碗里的东西，具体的视图实体 （官方：在Android视图体系中Window就是一个窗口 的概念。Android中所有的视图都是依赖于Window显示 的） WindowManager: 对Window的管理， 自然，add、 remove、更新等。 WMS: 窗口的最终管理者, 它负责窗口的启动、 添加和删除, 另外窗口的大小和层级也是由WMS 进行管理 ------》 见WMS具体章节 window什么情况下更新？ --------> 横竖屏切换，dialog的window的大小改变 2.2. 常见window（次要） 2.2.1. window的分类： Application Window: Activity、Dialog就是一个典型的应用程序窗口。-----> 从用户角度，想表达：常用的窗口 Sub Window: 子窗口, 顾名思义, 它不能独立存在,需要附着在其他窗口才可以, PopupWindow就属于子窗口。 -----> 从用户角度，想表达：依附 System Window: Toast、输入法窗口、系统音量条窗口、 系统错误窗口都属于系统窗口。 -----> 从用户角度，想表达：在所有应用窗口之上 自然，子窗口不能独立存在 注意：Dialog是应用程序窗口，可以独立存在的。比如： ​ Application window 应用程序窗口: 数字1~99 Sub Window : 2.2.2. 窗口的次序 1、窗口分组（按照类型）： APPlication window、sub window、System Window 顺序 ----》 非常自然 系统窗口、子窗口、应用窗口---------> 比如： Activity（应用窗口）弹起popDialog（子窗口），popDialog内有个输入框，点击输入框 ，弹起输入法面板（系统窗口） 2、同组之间，通过Type值来标志前后关系 Type值越大，越在前 -----> 自然 注意：所以，并不是根据dialog弹出的先后顺序定的前后关系 TODO: Type值是如何确定的呢？ 自然，Dialog的 Type要比 Activity的大 --------> 同组 2.2.3. 窗口的标志 // 当 Window 可见时允许锁屏 FLAG_ALLOW_LOCK_WHILE_SCREEN_ON // Window 不能获得输入焦点,即不接受任何按键或按钮事件,例如该 Window上有EditView,点击 EditView 是不会弹出软键 盘的 // Window 范围外的事件依旧为原窗口处理; 例如点击该窗口外的view,依然会有响应。另外只要设置了此Flag,都将会启用 FLAG_NOT_TOUCH_MODAL FLAG_NOT_FOCUSABLE = 0x00000008; // 设置了该 Flag,将 Window 之外的按键事件发送给后面的 Window处理, 而自己只会处理 Window 区域内的触摸事件 // Window 之外的view 也是可以响应 touch 事件。 FLAG_NOT_TOUCH_MODAL = 0x00000020; // 设置了该Flag,表示该 Window将不会接受任何 touch 事件,例如点击该 Window 不会有响应,只会传给下面有聚焦的窗口。 FLAG_NOT_TOUCHABLE; -------》 例子：ToastDialog // 只要 Window 可见时屏幕就会一直亮着 FLAG_KEEP_SCREEN_ON // 允许 Window 超过屏幕之外 FLAG_LAYOUT_NO_LIMITS // 当用户的脸贴近屏幕时(比如打电话) 不会去响应此事件 FLAG_IGNORE CHEEK PRESSES; // 窗口可以在锁屏的 Window 之上显示,使用 Activity#setShowWhenLocked(boolean) 方法代替 FLAG_SHOW_WHEN_LOCKED = 0x00080000; 2.3. WindowManger 窗口的操作类、实际上是接口类（addView、removeView、updateViewLayout），具体实现类是WindowMangerImpl 处于应用侧（进程） 《xiangxue》 为啥是桥接模式呢？ 桥：Window-WindowManager 好处：上层抽象进行关联，下层实现可以独立发展（下层可以灵活变动） 2.3.1. 接口ViewManager addView、removeView、updateViewLayout -------》自然，ViewGroup 需要这三个 为啥window需要呢？ 添加窗口addView 流程: APP侧 见 wms中 添加窗口流程 更新窗口 updateViewLayout 场景： 横竖屏切换 最终还是会走到，view刷新绘制流程----> 不得不 2.4. ViewRootImpl 1、管理view树： 2、触发view的绘制流程（最终目标：绘制，具体铺垫：测量、布局和绘制） 触发点：自然，viewRootImpl的performTraversales() 方法（最开始触发是 vsync信号, 这个方法是刷新、绘制的入口） ----> 自然，窗口的更新updateViewLayout 也会走到 performTraversales() 3、与wms交互 ----》 记忆图：《超级0层图: AMS-APP-WMS》 2.5. 对应关系 windowManagerGlobal、windowManagerImpl、viewRootImpl windowManagerImpl ----------acitvity级别（管理window，自然） windowManagerGlobal---------单例 （进程级别） viewRootImpl-----------window级别 推论： 1、windowManagerImpl 与 viewRootImpl数量基本一样 ​ 2、 多转一，再转多：通过decorView 建立映射关系 2.6. view Tree--------window的填充+显示 见 3. WMS 3.1. 0层图 见AMS: 《超级0层: AMS-APP-WMS》 https://ericchows.github.io/Android-Window-Mechanism/ 其中桥梁： IWindowManager和IAcitivityManger 是一个自然的桥梁，客户端对wms和AMS的引用~~ ----》系统服务 开机初始化 注册的缘故 IwindowSession桥梁是 桥梁 IWindowManager创建的。为什么要这一条？ 3.2. WMS的功能（职责）-----what： 功能1： 窗口管理 WMS 是窗口的管理者，它负责窗口的启动、添加和删除。另外窗口的大小和层级也是由 WMS 进行管理的。 窗口动画 ---> add 和 remove的附属功能 窗口间进行切换时，使用动画可以显得更炫一些，窗口动画由 WMS 的动画子系统来负责，动画子系统的管理者为 WindowAnimator。 功能2：输入系统中转站 通过对窗口的触摸从而产生触摸事件，InputManagerService(IMS) 会对触摸事件进行处理，它会寻找一个最合适的窗口来处理触摸反馈信息，WMS 是窗口的管理者，它作为输入系统的中转站再合适不过了。 功能3：Surface 管理（自然，包括申请） 窗口不具备绘制功能，因此每个窗口都需要有一块 Surface 来供自己绘制，为每个窗口分配 Surface 是由WMS 来完成的。 ------> 记忆锚点：WMS对window的： 1、widow的添加 即管理：增删改........ 2、window的输入 3、window的输出 3.2.1. 基于功能需要的对外接口（重要） 见 《超级0层图: AMS-APP-WMS》： APP 与 WMS之间，自然： 1、先有APP-> WMS: IWindowManager 2、IWindowManager 创建 IwindowSession桥梁 3、IwindowSession桥梁 创建 IWindow桥梁 源码： interface IWindowManager { IWindowSession openSession() //创建session桥梁 } 关于session的认识，见下面： 3.3. 功能1的纵向：添加窗口(纵向主线) : WMS侧----how 3.3.1. APP侧: 添加窗口WindowManagerImpl.addView(纵向主线) 流程: 图：《超级0层图: AMS-APP-WMS》 -始点：------when Activity的Create、Resume生命周期同步过来。见《startApp：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)》 Resume可见，performResumeActivity 是真正始点。见： 见《startApp：APP 侧执行 生命周期同步transaction 的执行execute(关键数据结构)》 -目标 ： WMS.addWindow侧添加窗口 基于目标，和： 【1】自然，先要建立桥梁： ViewRootImpl到WMS的桥梁、WMS到 ViewRootImpl的。为啥这样设计？见 AMS 【2】自然通过桥梁Session，addWindow 。自然会携带数据： window外数据：把window的参数（位置、大小）WindowManager.LayoutParams：app侧---》WMS侧 windown内数据：window的内容区域数据： mAttachInfo.mContentInsets：app侧---》WMS侧 基于目标【1】【2】，自然，之前 先把自己APP侧搞好： 【3】自然，要先把APP本地的Activity、window（WindowManagerImpl）、view树（DecorView）建好 ----> performLaunchActivity 流程。见《startApp》 【4】 自然，因为Resume才是可见的，所以， performResumeActivity 是 添加窗口addView的 始点 见《startApp》 基于目标【1】【2】，自然，APP侧弄好后，建立一些交互性的管理类，以及桥梁： 【5】 比如ViewRootImpl，必然在Reusme流程（与Wms交互流程）里新建的 基于目标【5】： 【6】自然，ViewRootImpl建立过程，会绑定DecorView，所以 Activity、window、viewTree三者绑定了 对应调用关系,，只看，不记忆： handleLaunchActivity---> performLaunchActivity --->【1】 创建Activity，并 attach() 创建window-----> onCreate -----> 【2】 setContentView ​ Activity.attach（创建Window） （创建DecorView，viewTree） handleResumeActivity ---> performResumeActivity -----> 总结： 只有Resume流程 是与WMS交互的 后续见《添加窗口(纵向主线) : WMS侧》 一些疑问，自然了： APP侧addView 变为 WMS.addWindow侧添加窗口 ---> 所以，addView是添加窗口 Activity.onStart ----> 所以onStart 根本不可见，不可交互 resume ----> 可见可交互的 todo： WindowManagerImpl 与 Global 是 一对多的关系。WindowManagerImpl 是Activity级别的？ 如何证明？ Global 负责交互了，必然是个进程单例，。自然 代码级证明： 3.3.2. 目标功能1的补充： 目标1：如何确定窗口的大小和位置呢？ 计算模型： APP侧初始值（输入） ----> 给到wms侧（输出）：遍历所有窗口，然后计算出最终 其中： 初始值（客户端程序员设置的） --------> viewRootImpl.relayoutWindow --------> wms计算 3.4. 功能3的纵向：申请surface流程----how 见： 《申请surface的流程(APP向surfaceFlinger)》 3.5. 关于session桥梁??? 基于什么目的？为甚要有？对总目的有什么用？ WMS实现侧： //Session.java //属性 mCanAddInternalSystemWindow -----> 是否能增加系统窗口 3.6. 次要：窗口的系统动画（基于窗口管理的辅助功能） 4. 面试题： 1、窗口的次序（见上） 2、子线程中 new 一个 Dialog，出现Token报错 Unable to add window token null is not valid is your activity running https://blog.csdn.net/meixi_android/article/details/106380069?spm=1001.2101.3001.6650.12&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-106380069-blog-78530491.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-12-106380069-blog-78530491.pc_relevant_recovery_v2&utm_relevant_index=13 5. 参考： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Andriod/无障碍_.html":{"url":"coding/Andriod/无障碍_.html","title":"无障碍_","keywords":"","body":"1. 无障碍流程1.1. 总体静态框架1.2. 流程：1.2.1. 无障碍相关流程和原理1.2.2. 自定义View无障碍化1.2.3. 无障碍优化CheckListTreeviewCopyright © aleen42 all right reserved, powered by aleen42 总体静态框架 流程： 无障碍相关流程和原理 发出AccessibilityEvent 总问题： 创建AccessibilityNodeInfo 自定义View无障碍化 Y侧所做的 无障碍优化CheckList 1. 无障碍流程 1.1. 总体静态框架 类图： 无障碍相关的类： A侧左滑流程 下滑操作无障碍流程TouchExplorerTouchExplorerAccessibilityManagerAccessibilityManagerAccessibilityManagerServiceAccessibilityManagerServiceAccessibilityInputFilterAccessibilityInputFilterEventStreamTransformationEventStreamTransformationAbstractAccessibilityServiceConnectionAbstractAccessibilityServiceConnectionIAccessibilityServiceClient接口IAccessibilityServiceClient接口TalkBackServiceTalkBackServiceAccessibilityInteractionControllerAccessibilityInteractionControllerAccessibilityInteractionConnection接口AccessibilityInteractionConnection接口ViewRootImplViewRootImplViewViewsystem_process进程system_process进程system_process进程AMS侧===》AS侧的接口as进程app进程onMotionEvent左滑过程：第一轮，ACTION_DOWN第二轮，ACTION_MOVE；第三轮，ACTION_MOVE。。。。。最后一轮，ACTION_UPhandleMotionEventStateTouchExploringsendAccessibilityEventsendAccessibilityEvent第一轮，TYPE_TOUCH_INTERACTION_START，后面全是该事件====》最终talkBack拿到了第二轮，TYPE_GESTURE_DETECTION_START，手势检测开始====》最终talkBack拿到了最后一轮，TYPE_GESTURE_DETECTION_END，手势检测结束====》最终talkBack拿到了TYPE_TOUCH_INTERACTION_END====》最终talkBack拿到了sendAccessibilityEvent(AccessibilityEvent, int userId)mainHandler.sendMessage(AccessibilityManagerService::sendAccessibilityEventToInputFilter,)TYPE_TOUCH_INTERACTION_STARTmainHandler在AMS中new出来，流转到AccessibilityServiceConnection和AbstractAccessibilityServiceConnectionmMainHandler.handleMessage(TYPE_TOUCH_INTERACTION_START)sendAccessibilityEventToInputFilter(AccessibilityEvent)notifyAccessibilityEvent(AccessibilityEvent)onAccessibilityEvent(AccessibilityEvent)super.onAccessibilityEvent(event)onAccessibilityEvent(event)这里是空的，啥也没做mainHandler通知执行notifyAccessibilityEventInternal(AccessibilityEvent)onAccessibilityEvent(event, serviceWantsEvent)onAccessibilityEvent(AccessibilityEvent event)第一轮，TYPE_TOUCH_INTERACTION_START，最终talkBack拿到了第二轮，TYPE_GESTURE_DETECTION_START，最终talkBack拿到了，第三轮。。。最后一轮，TYPE_GESTURE_DETECTION_END，最终talkBack拿到了TYPE_TOUCH_INTERACTION_END 最终talkBack拿到了app进程;ViewRootImpl内部类AMS===>APP侧的接口onGestureCompleted(int gestureId)TYPE_TOUCH_INTERACTION_END时候，收到手势动作GESTURE_SWIPE_RIGHT右滑onGesture(int gestureId)onGesture(gestureId)onGesture(gestureId)performAction(AccessibilityNodeInfoCompat node, int action,,EventId )哪个node，是有talkback决定的action为64，即ACTION_ACCESSIBILITY_FOCUS获焦！！！EventId：GESTURE_SWIPE_RIGHT，右滑performAccessibilityActionperformAccessibilityActionperformAccessibilityActionClientThread(long accessibilityNodeId, int action,整个performAction是从AMS侧调过来的！！！！AMS如何决定的？？Action具体是什么？？handleMessage(MSG_PERFORM_ACCESSIBILITY_ACTIONperformAccessibilityActionUiThread(message)View target = findViewByAccessibilityId(accessibilityViewId).performAccessibilityAction(action, arguments)View.performAccessibilityActionInternal(action, arguments) case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:View：case AccessibilityNodeInfo.ACTION_ACCESSIBILITY_FOCUS:View：requestAccessibilityFocus sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);View：sendAccessibilityEvent(AccessibilityEvent.TYPE_VIEW_ACCESSIBILITY_FOCUSED);发送无障碍事件？？？？？发送到哪里了？？？AS侧？setAccessibilityFocus(this, null)drawAccessibilityFocusedDrawableIfNeeded(Canvas canvas)画绿框 1.2. 流程： 1.2.1. 无障碍相关流程和原理 https://myslide.cn/slides/2795# 发出AccessibilityEvent 总问题： 1、sendEvent的始点是view ！！！》哪个view发的？？？ AccessibilityEvent包含哪些信息？？ Hover事件的分发流程？？？？ 发出AccessibilityEvent 用户点击 是否无障碍 模式？ 分发Hover事件给 View 构造 AccessibilityEvent 把NodeInfo对应的id 放到无障碍事件里 请求ViewRootImpl发 出无障碍事件 AccessibilityManager 将无障碍事件传送给 TalkBack 创建AccessibilityNodeInfo TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 1.2.2. 自定义View无障碍化 Y侧所做的 就是利用上述的两个delegate，塞给A的view，相当于自定义虚拟view！！！ 1.2.3. 无障碍优化CheckList 1. 从手Q开发谈Android无障碍化实现原理 及优化 alberthe 何金源 2016年9月 2. ABOUT ME 何金源 毕业于华南理工大学 手机QQ 基础Android开发组 目前负责 Android手Q无障碍化 多人聊天 基础资料卡 3. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 4. 无障碍化（Accessibility） • 无障碍化，是指针对听障、视障、肢障的用户所增加辅劣 项目，可以方便社会上此类有需要的人士有机会成功使用 我们的应用。 • 操作方式： 选择（Hover）：单击 开启（Click）：双击 滚劢：双指往上、下、左、右 选择上戒下一个项目：单指往上、下、左、右 快速回到主画面：单指上滑+左滑 返回键：单指下滑+左滑 最近画面键：单指左滑+上滑 通知栏：单指右滑+下滑 5. 无障碍焦点 • 可覆盖在任意View上 • 在屏幕上用绿色方框标明 • TalkBack根据用户交互来分配 • 表示当前活跃的元素 6. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 7. Android系统的无障碍 QQ System TalkBack Google 讯飞 用户 8. 无障碍相关类 QQ System TalkBack AccessibilityManager View AccessibilityService AccessibilityDelegate AccessibilityNodeInfo AccessibilityNodeProvider 9. 发出AccessibilityEvent 用户点击 是否无障碍 模式？ 分发Hover事件给 View 构造 AccessibilityEvent 把NodeInfo对应的id 放到无障碍事件里 请求ViewRootImpl发 出无障碍事件 AccessibilityManager 将无障碍事件传送给 TalkBack 10. 创建AccessibilityNodeInfo TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 11. View获取Focus TalkBack拿到 NodeInfo 根据无障碍事件中的 type来处理 执行NodeInfo中的 performAction方法 找到ViewRootImpl执 行Action 找到下一个需要获取 无障碍焦点的ViewB ViewB请求获取无障 碍焦点 找到上一个拥有无障 碍焦点的ViewA 释放ViewA的无障碍 焦点 结束 12. 绘制无障碍焦点 ViewRootImpl调用 draw方法绘制 是否无障碍 模式？ 是 找到当前focused的 View 算出View在屏幕的大 小 绘制无障碍焦点 13. 无障碍系统原理总结 • UI界面元素发生变化时（比如View被点击，View的焦点切换等）， 发出AccessibilityEvent • AccessibilityService接收这些AccessibilityEvent后，根据 AccessibiltyEvent里的accessibilityId来获取AccessibilityNodeInfo • AccessibilityNodeInfo由View来创建，戒者由 AccessibilityNodeProvider来创建 • AccessibilityService根据AccessibilityNodeInfo的信息提供无障碍 服务 • AccessibilityService通过AccessibilityNodeInfo来告知UI元素作出 处理 14. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 15. 一般情况下的无障碍化 按钮添加 contentdescription ListView的Item 会变化的元素 16. 困难场景 17. 解决方案思考 自定义NodeInfo? TalkBack收到无障碍 事件 取出事件中的id 根据id到 ViewRootImpl中找对 应的view View调用创建 NodeInfo的方法 是否自定义 AccessibilityNo deProvider 否是 根据View初始化 NodeInfo 自定义NodeInfo的创 建及初始化 把NodeInfo返回 Talkback 18. 自定义虚拟节点 • 自定义AccessibilityNodeProvider 19. 自定义虚拟节点 • 创建根AccessibilityNodeInfo 20. 自定义虚拟节点 • 创建子AccessibilityNodeInfo 添加Action 设置子节点的边框 设置状态等 21. 自定义虚拟节点 • 实现performAction方法 创建好根节点和子节点后，AccessibilityNodeProvider会被系统调 用performAction，来执行指定的无障碍操作（Action），根据 virtualViewId判断由根节点还是子节点来执行。 22. 自定义虚拟节点 • 分发HoverEvent到子节点，发出Hover无障碍事件 23. 更好的办法？ AccessibilityNodeProvider 24. 认识ExploreByTouchHelper • 简化虚拟节点层次结构的实现 只要实现五个抽象方法 • 隐藏AccessibilityNodeProvider的实现 • 完善控制Hover事件、无障碍事件 • 兼容性好 25. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 26. 委托ExploreByTouchHelper 27. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 28. 无障碍节点id • 界面上的元素使用无障碍节点id标记 • 无障碍节点id需要满足： - id是一个接一个的 - id是稳定的 - id非负整数 29. 标记界面元素的无障碍节点id 30. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 31. 填充无障碍节点的属性 32. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 33. 提供用户交互支持 34. 实现ExploreByTouchHelper • 委托处理无障碍 • 标记虚拟节点ID • 丰富无障碍信息 • 提供用户交互支持 35. 目录 无障碍相关流程和原理 自定义View无障碍化 无障碍优化CheckList 36. 无障碍优化CheckList • setContentDescription • Focusable • Custom View • 可变元素 37. 无障碍化需持之以恒 1. 细节决定成败 感悟 2. 无障碍要迭代 《Android无障碍宝典》 http://geek.csdn.net/news/detail/93269 38. 谢谢 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/":{"url":"coding/CodingLanguage/","title":"Coding Language","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/c_cpp_java.html":{"url":"coding/CodingLanguage/c_cpp_java.html","title":"C Cpp Java","keywords":"","body":"1. 目录2. C语言2.1. 字符串：2.2. 字符串的数组（c指针数组）2.3. memset、memcmp、strcmp比较2.4. sizeof2.4.1. 与cpp对比2.4.2. 参考：3. 如何学习一门语言4. cpp4.1. 引用的表达------include关键字（与java比较）4.2. 对象（与java比较）4.2.1. cpp—new malloc（与c的 malloc/free的比较）4.2.2. C++创建对象的两种方式 （与java的对比）4.2.3. 对象以及对象指针（对比java）4.2.4. 面试题4.3. 字符串(与c、与java对比)4.3.1. char类型字符串-----c4.3.2. string字符串-----Cpp4.4. int4.5. 容器4.5.1. vector4.5.2. 动态容器的遍历---以vector为例4.5.3. map4.5.4. set集合4.6. cpp标准输入输出cin：4.6.1. 关于 cout4.7. CPP内存机制4.7.1. 内存管理（手动管理）TODO4.8. cpp一些问题：4.8.1. 关于cpp的内存分配：4.8.2. cpp 数组声明后，必须初始化4.8.3. int 与 size_type4.9. 工具：Address Sanitizer4.9.1. 教程：4.9.2. What Can It Detect?4.9.3. 工作原理（how）4.9.4. 命令：4.9.5. 如何看结果4.10. 内存泄漏4.10.1. 对于leetcode的报错：4.11. cpp独有的东西4.11.1. 内联inline4.11.2. 日志：4.11.3. STL4.12. java、cpp 对比与记忆4.12.1. cpp 常量与JAVA常量表达：4.13. 常见面试题4.13.1. c++的const和static区别4.14. 代码重构之 lamba表达式5. Java：5.1. Super、this、实例化5.2. 钩子、监听器、汉奸的理解5.3. 关于安卓able对象6. JNI6.1. 0层6.2. JNIEnv结构6.3. JavaVM6.4. jobject thiz6.5. JNI基础6.5.1. 数据类型对应表6.5.2. JNI的命名规则6.5.3. Field and Method IDs6.6. JNI 操作 java 对象6.6.1. 操作 jarray6.6.2. 操作 jstring6.6.3. 操作 jobject6.6.4. 操作 Field6.6.5. 操作 method6.6.6. 创建java对象6.7. 参考文章：7. 正则TreeviewCopyright © aleen42 all right reserved, powered by aleen42 C语言 字符串： 字符串的数组（c指针数组） memset、memcmp、strcmp比较 sizeof 与cpp对比 参考： 如何学习一门语言 cpp 引用的表达------include关键字（与java比较） 对象（与java比较） cpp—new malloc（与c的 malloc/free的比较） C++创建对象的两种方式 （与java的对比） 对比java 对象以及对象指针（对比java） 对比java 基于对比，的推论： 面试题 字符串(与c、与java对比) char类型字符串-----c 取子字符串 比较字符串 ------c string字符串-----Cpp 取子字符串s.substr() int 容器 vector vector与int [] 的比较 vector的排序 动态容器的遍历---以vector为例 map set集合 cpp标准输入输出cin： 关于 cout CPP内存机制 内存管理（手动管理）TODO cpp一些问题： 关于cpp的内存分配： cpp 数组声明后，必须初始化 int 与 size_type 工具：Address Sanitizer 教程： What Can It Detect? 工作原理（how） 命令： 如何看结果 内存泄漏 对于leetcode的报错： cpp独有的东西 内联inline 日志： STL java、cpp 对比与记忆 cpp 常量与JAVA常量表达： 常见面试题 c++的const和static区别 代码重构之 lamba表达式 Java： Super、this、实例化 钩子、监听器、汉奸的理解 关于安卓able对象 JNI 0层 JNIEnv结构 JavaVM jobject thiz JNI基础 数据类型对应表 JNI的命名规则 Field and Method IDs JNI 操作 java 对象 操作 jarray 操作 jstring 操作 jobject 操作 Field 操作 method 创建java对象 参考文章： 正则 1. 目录 [TOC] 2. C语言 2.1. 字符串： cpp： string 或 char * s ------> 首选string c： char * s 或 char s[] （c中的字符数组） 区别：获取长度 stirng s ------>s.size() char s[] ---------> lenstr(s) c语言中：strcmp与strncmp与memcmp的区别： https://blog.csdn.net/weixin_45380951/article/details/100699751?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3.pc_relevant_default&utm_relevant_index=6 2.2. 字符串的数组（c指针数组） cpp：vector& wordDict_cpp c： char * wordDict_c, int wordDictSize ------>多重指针，指针的指针 char \\ wordDict_c[3] ------>指针数组 -------->使用方法完全一样： 取第0个字符串 wordDict_cpp[0], wordDict_c[0] 取第0个字符串的wordDict_cpp[0] [0], wordDict_c[0] [0] 关于char ** wordDict_c理解： （1）*相当于一个[], 比如 char * s = char s[] 所以，\\*\\* 即是 [] [] 具体： char *month[] = {\"January\",\"February\",\"March\",\"April\", \"May\",\"June\",\"July\",\"August\",\"September\",\"October\", \"November\",\"December\"}; ---->这里month是 char *的[]， ---->char ** point = &month; 还是 char ** point = month？？？？ 双重指针！！！！！ （2）c表达字符串数组时：指针数组 多重指针 2.3. memset、memcmp、strcmp比较 cpp没有字节级的处理，最少也是基本数据类型的处理---->比如，char、string memset、memcmp、strcmp ---->都是字节级的处理 即直接操作内存空间（字节级） 是c的用法（当然cpp也可以用） 所以，经常用到 sizeof() --->获取字节数 例子： void *memset(void *s, int c, unsigned long n); // 将s前n个字节填充c bool dp[lenstr(s) ]; // 是字符数组 memset(dp, 0, sizeof(bool)*lenstr(s)); //全部填充0 例2： memcmp(&s[i-int(tem.size())], &tem[0], int(tem.size())*sizeof(char)) 0 2.4. sizeof 总之： sizeof是c语言的东西 返回字节数 返回 类型的大小 具体用法： 1、用于数据类型-----本质 cout 2、用于变量 -----> 变量对应的数据类型的大小: int x = 4; cout 结果： sizeof(string) 32 sizeof(str) 32 sizeof(int) 4 sizeof(x) 4 sizeof(B) 4 sizeof(b) 4 3、指针变量也是变量，自然也是类型的大小 -----> 自然，跟系统有关： 32位计算机，返回4；64位计算机，返回8 char*pc=\"abc\"; int*pi; string*ps; char**ppc=&pc; void(*pf)();//函数指针 sizeof(pc);//结果为8 sizeof(pi);//结果为8 sizeof(ps);//结果为8 sizeof(ppc);//结果为8 sizeof(pf);//结果为8 4、用于数组 -----> 也是数组类型的大小，即 数组元素的大小 * 数组元素的个数 为什么？因为 数组类型 = 元素大小 + 数组长度 ​ int arr[3] = {0}; cout 5、结构体的sizeof ---> 涉及到字节对齐 2.4.1. 与cpp对比 对于cpp，推论，自然： 用于cpp的类的对象时，--------> 是 类型（即类）的大小，见上 2.4.2. 参考： https://baike.baidu.com/item/sizeof/6349467 3. 如何学习一门语言 以某一门语言为基础，搭建 学语言需要的技能树： 1、根据技能树，填充 2、填充的同时，与已经学会的语言进行比较（一样的话，就不需要记忆了） 4. cpp 4.1. 引用的表达------include关键字（与java比较） 引用其他文件的.h文件 ---->.h用来声明 被其他文件引用的类、函数 1、只在.h文件里声明，，不能在.h文件中定义值 ---->原因：include本质：.h会被复制到引用的文件中，如果定义，涉及到重复定义 2、同一个.h 可能被很多文件include ------>会造成多次编译问题，解决办法： .h文件中，增加#ifndef方式 //Parcel.h #ifndef ANDROID_PARCEL_H #define ANDROID_PARCEL_H // --------------------------------------------------------------------------- #endif // ANDROID_PARCEL_H https://blog.csdn.net/zzzkiti/article/details/40976867?spm=1001.2101.3001.6650.5&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.pc_relevant_paycolumn_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-5.pc_relevant_paycolumn_v2&utm_relevant_index=9 对比 ： java引用的表达是import 4.2. 对象（与java比较） 4.2.1. cpp—new malloc（与c的 malloc/free的比较） https://blog.csdn.net/hahachenchen789/article/details/83056796 语言范围： new/delete是C++关键字，需要编译器支持。-----> new 是对象，自然是cpp的东西 malloc/free是库函数，需要头文件支持。 ----> C的东西 入参比较： 使用new操作符申请内存分配时无须指定内存块的大小，编译器会根据类型信息自行计算。 ------> 对于面向对象的语言，这一点，很自然 malloc则需要显式地指出所需内存的大小 -----> 自然的，c是没有办法自己算出大小的 返回比较： new操作符内存分配成功时，返回的是对象类型的指针，类型严格与对象匹配，无须进行类型转换，故new是符合类型安全性的操作符 ------> 面向对象语言，自然的 malloc内存分配成功则是返回void *，需要通过强制类型转换将void指针转换成我们需要的类型。 ------> *这一点需要注意 malloc free 是stdlib库的函数 使用必须进行压栈出栈操作 ------> TODO: 不懂 new delete 是 c++的操作符 无需进行栈栈操作 且会再new是自动调用构造函数 delete调用析构函数 -------->所以，对于类来说，尽量用new（涉及到子类的析构） 例子： \\\\Parcel.cpp status_t Parcel::write(const FlattenableHelperInterface& val) { ........... int* fds = nullptr; if (fd_count) { fds = new (std::nothrow) int[fd_count]; //(1) if (fds nullptr) { ALOGE(\"write: failed to allocate requested %zu fds\", fd_count); return BAD_VALUE; } } err = val.flatten(buf, len, fds, fd_count); for (size_t i=0 ; iwriteDupFileDescriptor( fds[i] ); } if (fd_count) { delete [] fds; //(2) } return err; } 注意： 即使在函数内部new，也要在函数结束时，记得释放 uint8_t* data = (uint8_t*)malloc(desired); if (mData) { memcpy(data, mData, mDataSize void *memcpy(void *destin, void *source, unsigned n); 数据：mData ---> data 4.2.2. C++创建对象的两种方式 （与java的对比） 内存的分配方式有三种： （1）从静态存储区域分配。内存在程序编译的时候就已经分配好，这块内存在程序的整个运行期间都存在（不用管内存的销毁）。例如全局变量，static 变量。 （2） 在栈上创建（回收不用程序员管，自动回收------>因为叫栈，程序自动回收）。在执行函数时，函数内局部变量的存储单元都可以在栈上创建，函数执行结束后在将这些局部变量的内存空间回收。在栈上分配内存空间效率很高，但是分配的内存容量有限。------>一般来说，编译期就分配好内存大小了（具体分配还是在运行期？？？） （3） 从堆上分配的。程序在运行的时候用 malloc 或 new 申请任意多少的内存，程序员自己负责在何时用 free 或 delete 释放内存。 -------->只能在运行期申请内存 --------->所以，只有1、堆上的对象需要考虑释放 2、堆上的对象是运行期分配的内存 C++创建对象有两种方式：一句话区别：new的是在栈上创建 1、在栈上创建对象（Objects on the Stack）: int main(int argc, char** argv) { SpreadsheetCell myCell(5); // ------> 在栈上创建 if (myCell.getValue() 5) { SpreadsheetCell anotherCell(6); } // anotherCell is destroyed as this block ends. cout 2、在堆上创建对象（Objects on the Heap）: ClassName *obj1 = new ClassName(); ClassName *obj2 = new ClassName(parameter); delete obj1; delete obj2; 补充：cpp默认不会在静态存储区，创建对象的 但是，可以超纲使用（重载new/delete 操作符）：https://blog.51cto.com/u_15290941/3048752 对比java java只会在堆上创建对象 4.2.3. 对象以及对象指针（对比java） 对象的创建： A类的constructor： A(int b) 显式：A a = A(2) 隐式： A a(2) 与上面等价 对象指针： A* p = new A(2)； ---------->注意所有的new，都要有delete去销毁 （因为new是在堆上分配内存的，不是栈上） ​ 对比java 对象 A a = new A(2) -----> java new出来的是对象 本质一样： java与cpp new之后的东西，本质上是一样的（只是叫法不一样，只是语言层面符号不一样）： 1、都是堆产生一个对象 2、既然是堆里的东西，都需要主动释放 java的对象，本质是引用 或者说： cpp指针 等价于 java对象 基于对比，的推论： 1、java的对象，其实就是cpp对象的指针 2、判空时：cpp对指针判空；java对.....判空 -----> 自然，两者等价 3、java对象需要判空，cpp指针需要判空（cpp对象不需要） 4、赋值：cpp的指针赋值 等价于 java对象（实际引用）赋值 ------>都不会新建对象 5、赋值2： 但cpp对象赋值，是copy constructor。会新建对象: -------》 自然，传递的不是指针 ​ A a1 = a0 同理，cpp函数传参，传递对象，也会先copy constructor 对于java，传递的是对象的引用！！！ 6、推论：无论cpp还是java，对象永不为空（java对象本质是对象的引用）------> 自然的，对象都出来了，都占用了堆内存，怎会为空呢？ java的对象不初始化就为空-------> 实际上是引用 cpp对象，永不为空 --->（1）、cpp的对象声明，是包含了初始化的（java的声明，只是声明，声明和初始化两者分开） 是default constructor！！！！！ cpp，已经初始化，可以直接用 （2）、cpp需要判空的是指针，指针可能为空（本质原因：cpp指针 《------>类似于 java对象） （3）、cpp指针判空用nullptr （C语言用NULL） 7、从代码形式角度看声明，字符串：自然，java是引用，还没初始化 cpp声明： java声明： java必须单独初始化 8、从代码形式角度看声明，基本数据类型：自然， 两个都不是引用，即都有默认值 cpp： java： 4.2.4. 面试题 ① 、T *t =new T; ② 、T *t =new T(); ③、T t; 自然结论： a、内存上：new的都是在堆里，比如① 和② ； 非new都是在堆里，比如3 b、根据内存，自然new的（堆里）需要手动管理内存；3不需要 c、① 和② 的不同点：Todo，没能真正理解！！！！ ​ （1）程序员显示定义了构造函数都一样 ​ （2）程序员没有显示定义构造函数 -----》 编译器会为该类合成一个默认的构造函数： ① 的类内部的成员变量这个时候执行默认初始化，其值是未定义的。 ② p内部的成员变量会执行值初始化，即以0的形式进行初始化（整数就为0，bool就为false，string 就为空） 参考： https://blog.csdn.net/iaccepted/article/details/38613089 4.3. 字符串(与c、与java对比) 4.3.1. char类型字符串-----c 取子字符串 操作： 比较字符串 ------c 方法一：memcmp：（可以不是string的比较！！！！！） 比较两个string 或 比较两个string的 前三位： memcmp(&s1, &s2, 3*sizeof(char)) --->C语言的方法 注意: s1 只要是字符串就行，string 或者 char*的字符串 入参是指针 方法二： strcmp(str1, str2) 4.3.2. string字符串-----Cpp C++标准程序库中的string类，与上面的char*的字符串比较： 优势： 不必 担心内存是否足够、字符串长度等等 使用方法： #include using namespace std; 取子字符串s.substr() 4.4. int C++如何取得int型的最大最小值 當題目涉及到求最大最小值時，最初的比較數字就應當設置爲INT_MAX或INT_MIN，更爲安全。 中有INT_MAX和INT_MIN的宏定義可直接使用。 或者自行定义宏 #define INT_MAX 0x7fffffff #define INT_MIN 0x80000000 INT_MAX = 2147483647 INT_MIN = -2147483648 4.5. 容器 4.5.1. vector 类似于java int[]： 类似1： 初始化：vector nums = {2,3,1,1,4}; cpp形式初始化 vector nums{3} -----> nums 含3 vector nums{1,3} -----> nums 含1,3 cpp形式初始化 vector nums(3) -----> nums含 0, 0 ，0 类似2：索引：nums[i] nums.at 注意：对于指针，不能用p[i] !!!!!, 只能p->at(i) 不同于 java int[] --->动态数组，增删 insert、erase push_back、pop_back #### vector与int [] 的比较 ``` bool wordBreak(string s, vector& wordDict) { } ``` vector是动态数组，可以运行期确定大小 --->即vector dp2(int(s.size())); 可以编译通过 int [] 编译期确定大小 --- > bool dp[int(s.size())] = {false}; ---->编译不通过 方法： (1)利用cpp的vector （优） (2)给int [] 足够的空间，比如这里已知s长度小于300： bool dp[300] = {false}; (3) 利用c的方式， 利用memset运行期分配空间大小： ​ bool dp[int(s.size()) + 1]; // 这里可以编译通过，原因在于，这里只是声明，编译器并没有分配空间 ​ memset(dp, 0, sizeof(bool)*(int(s.size()) + 1)); vector的排序 // sort algorithm example #include // std::cout #include // std::sort #include // std::vector bool myfunction (int i,int j) { return (i myvector (myints, myints+8); // 32 71 12 45 26 80 53 33 // using default comparison (operator ::iterator it=myvector.begin(); it!=myvector.end(); ++it) std::cout 4.5.2. 动态容器的遍历---以vector为例 vector遍历： 方法一： 索引i遍历，for (int i = 0; i 方法二：iterator遍历： ​ for (vector::iterator it = res.at(i).begin(); it ​ 或 while (it != res.at(i).end()) {it++;} ---->结论：涉及到动态数组的删除与增加，谨慎用for！！！！！（it强行++了！），多用while！！ //---->原因：for为什么不对？因为erase之后，it自动指向下一个，不应该再强制it++，需要判断 vector::iterator it = res.at(i).begin(); while (it != res.at(i).end()) { ​ if (int(*it) -22) { ​ res.at(i).erase(it); ​ } else { ​ it++; // 有条件的下一个！！！！！ ​ } } 4.5.3. map 初始化 遍历 iterator： 《-----------iter++; map::iterator iter; iter = _map.begin(); while(iter != _map.end()) { cout first second first second 增删改查： 增：mem.insert({start, true}); ---->注意：不同于java，这里增一个pair，即 {key，value} 删： 改： 查：find(key) 4.5.4. set集合 https://en.cppreference.com/w/cpp/container/set 遍历 iterator，同map 4.6. cpp标准输入输出cin： https://blog.csdn.net/bravedence/article/details/77282039 作用：cin可以连续从键盘读取想要的数据，以空格、tab或换行作为分隔符 例子： #include using namespace std int n, m; cin >> n >> m; 输入： 4 5 输出与输入： cin>>a>>b>>c; cout4.6.1. 关于 cout cout 本质：cout实际上是一个iostream类的对象，流对象。。。--->每一次调动ostream& operator这个函数重载了 --->所以《《 之间可以填任意数据类型的数据 ------>推论： 1、输出操作符“>>”，作用：将数据输出到std::cout输出流的缓冲区上。 2、std::endl作用：显示请求刷新 ---->缺少后，暂时不会刷新 3、可以打印很多数据，而且 4、printf 输出需要格式化字符串，比如printf(\"%d\", n); --->c的做法，比较麻烦（根因：c没有类的概念） 4.7. CPP内存机制 参考：https://blog.csdn.net/m0_68981107/article/details/127548736 cpp内存模型： TODO: 对比java的 1.栈用来存放：非静态局部变量/函数参数/返回值等，栈向下增长。 2.堆用于程序运行时动态内存分配，堆是可以上增长的。 3.数据段–存储全局数据和静态数据。 4.代码段–可执行的代码/只读常量。 注意点： 1、 向上增长、向下增长 2、全局变量和 静态变量（静态全局变量、静态局部变量）的比较（面试题）： ​ ① 相同点：都在数据段（静态存储区） ​ ② 记忆： 全局变量： 全局，即 ​ 作用域：所有文件（自然，其他文件需要用extern来再次声明一下，才能引用到） ​ 生命周期：跟执行的时机有关 静态全局变量 = 静态 + 全局变量 ​ 静态static即： （1）作用域 : 限制文件内 （2）生命周期同程序 静态局部变量：= 静态 + 局部变量 ​ 静态static即：................................ ​ 局部，即：限定在函数体内 ​ 总之，作用域：函数体内 生命周期：同程序 int globalVar = 1; // 全局变量 ----》 全局所有文件 static int staticGlobalVar =1; //静态 全局变量 ②static限定了作用域（在该文件内） void Test() ( static int staticVar = 1; //静态 局部变量 int localVar = 1; int num1[10] = {1,2,3,4}; 4.7.1. 内存管理（手动管理）TODO 方式一： view框架里面，java和native绑定，死亡机制 方式二：手动delete 方式三：智能指针 4.8. cpp一些问题： 4.8.1. 关于cpp的内存分配： 静态分配内存：《---->在编译期间就分配了内存大小《----->栈上分配（静态变量是在静态方法区、注意：栈上存在动态分配） 常见的有：局部变量中的int[]、array对象 动态分配内存：《----->在运行期间分配内存大小《------->在堆上分配 《------>必须手动管理内存 例子：new或者mallo的对象、vector类（内部自动使用new和delete来管理内存） ------->对cpp，上述写法错误 （解决方法，用vector、或者 找到数组大小上限） vector可以的原因是，动态增长的，编译期间有个初值？？？？ 对于java是可以的，因为int dp = new int[] ----->这是在堆上生成的（运行期间） https://zhidao.baidu.com/question/304646543.html https://www.cnblogs.com/nulisaonian/p/6100535.html 4.8.2. cpp 数组声明后，必须初始化 声明，不初始化，本质上来说，是可以的，是有数值的 但数值是随机的（上一次内存的遗留！！！） 4.8.3. int 与 size_type string.size()、lenght()返回size_type size_type 本质是无符号整数，int是有符号整数。。。规定：与int 运算（加、减、否则，会出现很多意想不到的结果，例子： a是无符号整数--->导致1-a也是无符号整数，即是正的，但很明显1-a = -3是个负数，转化成正数，就非常大 4.9. 工具：Address Sanitizer 4.9.1. 教程： https://www.youtube.com/watch?v=hhpzDFvXopk Address Sanitizer in C++ (A Tutorial) https://github.com/google/sanitizers https://www.cnblogs.com/justin-y-lin/p/11314059.html gcc存储已经集成了!!!! https://hanpfei.github.io/2019/05/19/AddressSanitizer_on_linux/ Linux 下的 AddressSanitizer 4.9.2. What Can It Detect? 4.9.3. 工作原理（how） 4.9.4. 命令： window下AddressSanitizer没能搞定，主要linux下，编译以及运行命令： g++ -fsanitize=address -O0 -fno-omit-frame-pointer -g -o main main.cpp && ./main 注意:g++(c++语言)不是gcc (c语言), 不能用错!!!! 遇到报错: Asan runtime does not come first in initial library list; you should either link runtime to your application or manually preload it with LD_PRELOAD 解决方法: mv /etc/ld.so.preload /etc/ld.so.preload.bak rm -rf /etc/ld.so.preload Ilvm-symbolizer 符号化工具属于 Ilvm包,Ubuntu 下具体的安装方法可以参考 LLVM Debian/Ubuntu nightly packages. 4.9.5. 如何看结果 分析日志:23912是进程号 读取四个字节的数字出错了 4.10. 内存泄漏 C++造成内存泄漏的原因汇总： https://blog.csdn.net/qq_18824491/article/details/78902636?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0.no_search_link&spm=1001.2101.3001.4242.1&utm_relevant_index=3 对于C++的内存泄漏，总结一句话：就是new出来的内存没有通过delete合理的释放掉！！！！！！！！！ ------->在函数体内，1、不用new，创建对象，系统自动回收内存 2、new对象（返回指针），系统不会回收，需要手动 比喻：1、申请内存就像不停打开网页 2、没有及时关闭网页 3、new 网页，谁new应该谁关 4、如果不关网页，系统掉电重启，内存会全部清掉 4.10.1. 对于leetcode的报错： 42ERROR: AddressSanitizer: heap-use-after-free on address 0x602000000058 at pc 0x00000037ac7d bp 0x7ffe70f719a0 sp 0x7ffe70f71998 ----->最后定位下来，是p1与p2循环next了 ------>leetcode报错类型是有问题的？？？？？（linux下AddressSanitizer没有报错！！） leetcode这种问题如何定位？？？？？ (1)二分 print--------->每一行都能打印 (2)linux内存泄漏工具 -------->OK的 (3)二分return（log不起作用时修改代码功能定位） ---------->既然抛了error，那么一定是某一行有问题，所以，逐行改变return位置 ------>逼出哪一行出了问题 37处return会有error！！！！！ 4.11. cpp独有的东西 4.11.1. 内联inline 内联，可以关闭，尤其定位问题，调用栈时，需要关闭！！！！！ 4.11.2. 日志： Step0. 在CMakeLists.txt中添加 find_library( # Sets the name of the path variable. log-lib # Specifies the name of the NDK library that # you want CMake to locate. log ) target_link_libraries( # Specifies the target library. native-lib ... # Links the target library to the log library # included in the NDK. ${log-lib} ) Step1. 在cpp文件中添加 // 引入log头文件 #include // log标签 #define TAG \"这里填写日志的TAG\" // 定义info信息 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__) // 定义debug信息 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) // 定义error信息 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__) Step2. 输出日志 LOGD(\"user info-----------------------name:%s, age:%d, sex:%s.\", \"xxx\", 18, \"男\");` LOGE(\"chengang1, class name:%s\", env->GetStringUTFChars(name, 0)); 4.11.3. STL STL的代码从广义上讲分为三类：algorithm（算法）、container（容器）和iterator（迭代器） 在C++标准中，STL被组织为下面的13个头文件： 、、、、、、、、、、、和 4.12. java、cpp 对比与记忆 4.12.1. cpp 常量与JAVA常量表达： cpp： const JAVA：final 4.13. 常见面试题 4.13.1. c++的const和static区别 https://blog.csdn.net/qq_31484941/article/details/80742096 字节： 1、输入法的难点 ​ 通信 4.14. 代码重构之 lamba表达式 参考：https://www.jianshu.com/p/4af34e151d63 理解： lambda表达式即匿名函数 作用: 可以用作对重复代码的重构 //原始函数 void Window::SetInset (UIRect &rect) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... curManager->Setinset(rect);//非公共部分【3】,差异点:函数Setinset(参数rect也是函数?);相同点curManager } void Window::SetMode (int mode) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... curManager->SetMode (mode); } //代码重构 --------以上重复,自然,提取公因式为公共函数:提取1------- 提取1: void Window::ApplyOnCurManager() { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... } 基于提取1,但是后面会用到提取1中的参数(即公共部分与差异部分有耦合性,造成了提取失败): 将非公共部分【3】的差异部分(函数Setinset、参数rect),进行封装差异????-----》修改2 修改2: void Window::ApplyOnCurManager (ProcessType setParams) { .....重复[1]...... WindowSceneManager *curManager = ...........; .....重复[2]...... //利用setParams差异性封装(对于公共部分函数ApplyOnCurManager) ---->从公共角度,只有封装差异,才能一样 setParams(curManager); } 基于修改2,需要 using ProcessType = std::function; //TODO:抽象是如何来的?? 目的:提取公共部分 (1)本质是封装函数,成为公共部分,自然是函数类型 std::function (2)参数为什么是WindowSceneManager *curManager???而不是rect? 因为参数也要是公共部分,即公共部分提取成参数(),非公共部分使用[],在原来函数里捕获!!! --------------------------------------------------- void Window::Setinset(UIRect &rect) { //基于修改2 ApplyOnCurManager(ProcessType setParams); //抽象 即: curManager->Setinset(rect);//差异性...... 从最终代码来看,差异性一定还是在原函数里 } void Window::Setinset(UIRect &rect) { //基于修改2 ApplyOnCurManager(ProcessType setParams); //抽象 setParams即: [&rect//1、表示lambda执行时,可以访问外部的变量!](WindowSceneManager *curManager//2、匿名函数的参数?) {curManager->Setlnset(rect);//差异性} //具体 1、并指定访问这些变量时是通过值拷贝还是引用访问. 2、std::function } TODO: 从最初--->最终代码:差异性,一定还在原函数里;公共部分,被公共函数抽出来 lamba的作用在于,将原函数里的差异性封装成匿名函数...............传参(匿名函数)给公共部分函数,自然代码没有差异 最基本的思想:对差异性进行封装,对公共部分进行提取 (角度,从原函数角度,从功能角度,从lambda角度,从最初--->最终角度,从功能角度) 从lambda角度: 从capture角度 从Setinset角度: lambda就是对Setinset的封装:封装成抽象的、相同的lambda; Setinset被延迟执行了,在下一个函数里执行的(在原函数里定义) 从定义---执行角度:在原函数里定义,在下一个函数里执行 从封装差异角度:差异最终是体现在原函数处 lambda的内核Setinset ([&rect])中,即定义处 从提取公共角度来看: lambda就是提取公共的一个极度的扩展 // 1. lambda封装差异性(下一个函数,公共部分+lambda) --->优点,场景,很多情况下,公共部分与差异耦合严重,无法用公共函数抽取 // 2.这里定义function形式(传参+执行在下一个函数里) 上述也即: 公共部分与差异部分有耦合性----抽取公共函数的方法 java lamba 与cpp lamba差异在哪里?那么java是否可以这样取优化代码? 5. Java： 5.1. Super、this、实例化 一、 子类实例化过程调了Super publicA( ) extends B { Super(a,b,c) ..... } 此时： super 时， 会调B相应的构造方法 且执行方法里面内容 但只有一个实例this！！！！ this 表示这个唯一实例，而不是本类的。。。。。 子类在构造中调super的必要性在于 ：给父类的属性初始化 关于this： ​ （1）this和super都指向同一个实例，内存地址一致！！！！！ ​ （2）this永远代表实例 ，除了以下两种情况 ：（this.方法（）《>方法（）） ​ this.name = name; 以及在构造方法中重载this（a,b,c） >这两种this是本类的意思 二、 子类实例化过程没有调Super publicA( ) extends B { ..... } 等价于：默认调了父类无参构造方法, 而且是第一句就调了Super!!!! publicA( ) extends B { Super() } 每个类会默认有无参构造方法！！！！ 总之，记忆： https://blog.csdn.net/z56zzzz/article/details/78086434 ​ 0层：本质: 其物理本质！！！！一句话描述，记忆： ​ 1、无论this在父类还是子类中 ： （1）this.成员变量：当前类的变量， 注释：成员变量 《---->this.成员变量，编译器会自动加this！！！！！！！！(属性是静态的，同时存在，读取时就近原则（一个的话，自然就一个） idea跳转也是如此) （2）this.方法：当前运行类（即子类）的方法！ 更 抽象： 究其本质：子类存了两份成员，this.成员 和super.成员！！！！！（但一个是静态，一个是运行态） //FatherClass.java public class FatherClass { private String name; //父类成员变量，1、子类实例拥有，虽然同名，但是会存储两份 2、子类实例拥有，但无法调用 2、子类实例通过super.方法（）访问、修改,例如super.getName() 3、本类通过，this.name或name！！！！！！！！！！=>就近原则 private int age; protected String houseDress = \"dfjsifjioasjf\"; //子类实例继承该变量，1、虽然同名，但是会存储两份 2、子类实例可以直接调用，通过super.houseDress public String getName() { return name; } private String smile() { //子类实例访问不到的 ........ } public void setName(String name) { this.name = name; //记忆：this.成员变量 仅仅代表本类的 System.out.println(this.toString());//记忆： ！！！！！！！！！this.方法=>当前运行类的方法 } public String toString() { //子父同名，子类实例继承该方法 1、虽然同名，会有两份 2、子类实例可以调用，super.方法（） ........ } } //SonClass.java public class SonClass extends FatherClass{ private String name = \"aaaa\"; private int age; protected String houseDress = \"dasfafgs\"; public SonClass(){ } public void setFair(String fair) { this.fair = fair; } public String toString() { } } 5.2. 钩子、监听器、汉奸的理解 listener监听器。。。。。自然是塞给了谁，监听谁。。。。。谁new的，自然谁是主人 callback即listener，以后所有的callback就叫监听器 越做z，越要熟悉安卓。。。。。然后对比记忆 安卓是主干，是根本！！！ callback（listener），更应该叫钩子： 持有钩子的模块一直运行，某一时间利用钩子钩起钩子创造者 Q：Z有很多hook到A的流程，为什么这么多流程都可以hook到A里面=？？？？？？ A：因为有汉奸，伪装成A（继承于A），又把A的的调用流程转到了Z里 ----> 话说回来：这也是使用抽象（InterFace）的好处！扩展性强！ 5.3. 关于安卓able对象 Runnable ----》 可以执行的对象，把函数run() 封装成一个对象，本身与线程无关 Drawable ----》 可以画的对象 6. JNI 6.1. 0层 见： https://www.jianshu.com/p/87ce6f565d37 6.2. JNIEnv结构 JNIEnv: JNI的第一个参数，JNIEnv 的本质是一个与线程相关的结构体，里面存放了大量的 JNI 函数指针：是functions的集合 JNIEnv与线程一一对应 --->所以，JNIEnv的作用：通过这个 JNIEnv* 指针，就可以对 Java 端的代码进行操作： 调用 Java 函数 操作 Java 对象 struct _JNIEnv { /** * 定义了很多的函数指针 **/ const struct JNINativeInterface* functions; #if defined(__cplusplus) /// 通过类的名称(类的全名，这时候包名不是用.号，而是用/来区分的)来获取jclass jclass FindClass(const char* name) { return functions->FindClass(this, name); } //通过 jmethodID FromReflectedMethod(jobject method) { return functions->FromReflectedMethod(this, method); } jfieldID FromReflectedField(jobject field) { return functions->FromReflectedField(this, field); } jobject ToReflectedMethod(jclass cls, jmethodID methodID, jboolean isStatic) { return functions->ToReflectedMethod(this, cls, methodID, isStatic); } jclass GetSuperclass(jclass clazz) { return functions->GetSuperclass(this, clazz); } ... } 6.3. JavaVM JavaVM : JavaVM 是 Java虚拟机在 JNI 层的代表, JNI 全局只有一个 JNIEnv : JavaVM 在线程中的代表, 每个线程都有一个, JNI 中可能有很多个 JNIEnv，同时 JNIEnv 具有线程相关性，也就是 B 线程无法使用 A 线程的 JNIEnv JVM 的结构图如下：注意：JNIEnv与线程一一对应 6.4. jobject thiz java对象中的This，比如MainActivity的对象 6.5. JNI基础 6.5.1. 数据类型对应表 ------>作用在于：接口处参数用法，java--->cpp，例如int[] array --->jintArray //java public native int setToNativeArray(int[] array); //jin.cpp Java_com_example_NativeDemo_MainActivity_setToNativeArray(JNIEnv *env, jobject thiz, jintArray jintArrs) { // TODO: implement setToNativeArray() } 基础数据类型 Java Type Native Type Description boolean jboolean unsigned 8 bits byte jbyte signed 8 bits char jchar unsigned 16 bits short jshort signed 16 bits int jint signed 32 bits long jlong signed 64 bits float jfloat 32 bits double jdouble 64 bits void void N/A 引用类型 6.5.2. JNI的命名规则 extern \"C\" JNIEXPORT jint JNICALL Java_com_example_NativeDemo_MainActivity_setToNativeArray(JNIEnv *env, jobject thiz, jintArray jintArrs) { // TODO: implement setToNativeArray() return 0; } jint是返回值类型 Java_com_example_NativeDemo 是包名 MainActivity 是类名 setToNativeArray是方法名 6.5.3. Field and Method IDs 6.6. JNI 操作 java 对象 6.6.1. 操作 jarray 将一个 Java int[] 对象传入 C++ 6.6.2. 操作 jstring 6.6.3. 操作 jobject 6.6.4. 操作 Field 6.6.5. 操作 method 6.6.6. 创建java对象 6.7. 参考文章： https://juejin.cn/post/6844904192780271630#heading-14 https://www.jianshu.com/p/87ce6f565d37 7. 正则 匹配test开头的一行： test\\/.* test前加空格 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/CodingLanguage/R.html":{"url":"coding/CodingLanguage/R.html","title":"R","keywords":"","body":"1. R1.1. log1.2. 遇到包安装问题，如何解决？2. 各种包2.1. ChAMP包TreeviewCopyright © aleen42 all right reserved, powered by aleen42 R log 遇到包安装问题，如何解决？ 各种包 ChAMP包 1. R 运行 1、Rscript.exe main.R 2、GUI 1.1. log 1.2. 遇到包安装问题，如何解决？ 2. 各种包 2.1. ChAMP包 source(\"https://bioconductor.org/biocLite.R\") options(BioC_mirror=\"http://mirrors.ustc.edu.cn/bioc/\") biocLite(\"ChAMP\") options选择中科大镜像 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/computorBase/":{"url":"coding/computorBase/","title":"Computor Base","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/computorBase/linux.html":{"url":"coding/computorBase/linux.html","title":"Linux","keywords":"","body":"1. 目录2. 操作系统工作方式（从一次调用来看）------纵向0层：3. 模块之间的关系（联系）：4. 模块之间的独立性（割裂）5. linux kernel 功能划分图-----静态6. 中断6.1. Linux的中断机制6.2. 中断工作流程6.3. linux中中断你的工作流程6.3.1. 代码结构6.3.2. 中断的代码实现TreeviewCopyright © aleen42 all right reserved, powered by aleen42 操作系统工作方式（从一次调用来看）------纵向0层： 模块之间的关系（联系）： 模块之间的独立性（割裂） linux kernel 功能划分图-----静态 中断 Linux的中断机制 中断工作流程 linux中中断你的工作流程 代码结构 中断的代码实现 1. 目录 [TOC] 2. 操作系统工作方式（从一次调用来看）------纵向0层： 一次调用，从上到下: 底层：硬件 操作系统的工作方式: 1.把操作系统从用户态 切换到 内核态 (用户应用程序 到 内核的流程) 2.实现操作系统的系统调用(操作系统服务层) 3.应用操作系统提供的底层函数,进行功能实现 ​ 3.1 操作系统的驱动结构 4.推出后从内核态切换到用户态 3. 模块之间的关系（联系）： 高速缓存 其实就是一块内存。。。计算机写文件时，先存储在高速缓存里，最后一把写入硬件磁盘 4. 模块之间的独立性（割裂） 独立性： 注意区分：管理层与实现层 提供接口的，不实现；实现的，不提供接口 为什么要这样做呢？ 易于维护和升级？？？？ https://www.bilibili.com/video/BV1tQ4y1d7mo?t=3147.4 高版本和低版本内核之间的区别： 1、内核驱动的管理模式并没有巨大的改变。一段时间3个阶段的跳段： 零散型 分层型 设备树 ​ 多的只是内核驱动的种类 2、进程的管理方式并没有巨大的改变 进程的调度算法发生了改变 ------> 总之，就是没有大的改变 技巧： 不变的看老版本 -------- 主 ​ 变化的，看新版本 -------- 次 5. linux kernel 功能划分图-----静态 Linux内核是linux操作系统的核心部分，它实现了操作系统的五大功能模块： 进程管理 内存管理 文件系统 设备控制 网络 CD ------光盘 6. 中断 目的：为啥要有中断？ ​ 1、硬件的中断响应 ----》 内核驱动的中断 ​ 2、系统调用的函数响应（sys_call） ----》 系统调用 ​ 3、自定义中断 ----》 软件的软中断模式 ​ 4、信号中断(kill-signalnum) ----》 进程间通信（有助于了解信号的使用、创建等） ​ 5、系统的异常和错误 ----》 系统的异常获取；了解系统异常的作用 后面的章节，围绕着这五个目的 6.1. Linux的中断机制 分类，自然： 硬件中断：比如：电脑主机的8259A类似的硬件中断控制芯片发出的中断、ARM中断控制器发出的中断 软件中断：异常：第一类：CPU 自行保留的中断 -------》 TODO: 不懂 ​ 系统调用异常 6.2. 中断工作流程 任意系统中断都有： ----------------保存------------------------- 做CPU工作模式的转化 进行寄存器的拷贝与压栈 -----> TODO: 这个目的是啥？ 设置中断异常向量表 保存正常运行的函数返回值 ------------------执行-------------------------- 跳转到对应的中断服务函数上运行 ------------------恢复------------------------- 进行模式的复原以及寄存器的复原 跳转回正常工作的函数地址继续运行 （对应video： https://www.bilibili.com/video/BV1tQ4y1d7mo?t=1252.7&p=2） -------------> 总之， 字面上来看： 中断就是 中断CPU，做其他事情（运行中断服务函数） 6.3. linux中中断你的工作流程 ---------------保存(中断前)------------------------- 1、将所有的寄存器值入栈 -----》 上面的保存 寄存器比如： 8086中的 SS EFLAGS ESP CS EIP（错误码） ARM中的（r0-r15） 2、将异常码入栈（中断号） 3、将当前的函数返回值进行入栈(为了在中断执行后能够找到在哪中断的, 能够复原) ------------------执行(中断)-------------------------- 4、调用对应的中断服务函数 ------------------恢复(中断后)------------------------- 5、出栈函数返回值 6、返回所有入栈的寄存器值 6.3.1. 代码结构 重要代码结构： 保存过程（123），恢复过程（56） 调用？ 中断的执行过程（4） 硬件中断的处理过程 asm.s traps.c 软件及系统调用的处理过程 system_call.s fork.c signal.c exit.c sys.c 结论： 软中断和硬中断，完全两条路 系统调用 同 软中断 6.3.2. 中断的代码实现 以 asm.s ---》 traps.c为例： console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/computorBase/OperateSysTem.html":{"url":"coding/computorBase/OperateSysTem.html","title":"Operate Sys Tem","keywords":"","body":"1. 目录2. 视频课程3. 什么是操作系统（what）3.1. 从功能角度：3.2. 从硬件资源角度3.3. 操作系统的历史3.4. 操作系统结构4. 操作系统基础操作4.1. 启动4.2. 中断、异常和系统调用5. TODO:6. 面试题6.1. 进程隔离相关6.1.1. why 为什么需要进程间隔离？6.1.2. what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节TreeviewCopyright © aleen42 all right reserved, powered by aleen42 视频课程 什么是操作系统（what） 从功能角度： 从硬件资源角度 操作系统的历史 操作系统结构 操作系统基础操作 启动 中断、异常和系统调用 TODO: 面试题 进程隔离相关 why 为什么需要进程间隔离？ what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节 1. 目录 [TOC] 网易面试官: 操作系统是你必须迈过去的一道坎。不然工作十年后，你会被应届生卷死 2. 视频课程 https://www.bilibili.com/video/BV1wv4y1S7xm?p=2&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 清华 计算机操作系统 笔记，参考： https://blog.csdn.net/iwanderu/article/details/103934127 3. 什么是操作系统（what） 3.1. 从功能角度： 自然： -----------> 硬件资源角度 3.2. 从硬件资源角度 目的： 封装硬件资源，给APP进程使用 具体： 操作系统将 三大硬件资源，分别抽象成软件概念： cpu ----- 进程 磁盘------文件 内存-------地址空间 操作系统的软件层次： Shell + kernel Shell 是对用户的: 比如GUI（Linux、Windows、Android 界面 ）、命令行等 kernel：真正提供功能的 ​ （1） kernel底层：中断、I/O、设备驱动 kernel： OS Kernel的特征: 1、并发 ​ 计算机系统中同时存在多个运行的程序 -----> 需要OS管理和调度 补充：并发与并行的区别，很自然： 并行指的是一个时刻 ----> 自然，对于cpu，不存在并行 （多核除外) 并发指的是一小段时间，时间片轮转上 2、共享 “同时”访问 互斥共享 3、虚拟 利用多道程序设计技术,让每个用户都 觉得有一个计算机专门为他服务 4、异步 程序的执行不是一贯到底,而是走走停 停,向前推进的速度不可预知 但只要运行环境相同,OS需要保证程序 运行的结果也要相同 3.3. 操作系统的历史 如果要理解深刻，必须知道历史。。。因为历史给出了为什么是这样 3.4. 操作系统结构 4. 操作系统基础操作 4.1. 启动 知识点： ●计算机体系结构概述 ●计算机内存和硬盘布局 ● 开机顺序 启动流程： 4.2. 中断、异常和系统调用 ● 背景 ●中断、异常和系统调用相比较 ●中断和异常处理机制 ●系统调用的概念 ●系统调用的实现 ● 程序调用与系统调用的不同之处 ● 开销 DISK:存放OS BIOS:基本I/O处理系统 Basic Input Output System 5. TODO: 《计算机组成原理》 全量课程： https://www.bilibili.com/video/BV1Wv411x7zP?p=2&vd_source=3eebd10b94a8a76eaf4b78bee8f23884 6. 面试题 6.1. 进程隔离相关 参考： https://blog.csdn.net/s2311307/article/details/108862748 Android的进程间通信（一） 之 进程隔离简述 6.1.1. why 为什么需要进程间隔离？ 来自：https://blog.csdn.net/s2311307/article/details/108862748 安全性：为了避免A进程写入B进程的情况发生 很自然 6.1.2. what-----进程之间的隔离主要体现在哪里？ how如何实现的？ TODO ---字节 -----> TODO: 链接到知识点里 主要是内存的隔离 实现： 采用了虚拟地址空间，两个进程各自的虚拟地址不同，从逻辑上来实现彼此间的隔离。-----> TODO: 具体的过程！！！图 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/":{"url":"coding/Tool/","title":"Tool","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/aospBuilding.html":{"url":"coding/Tool/aospBuilding.html","title":"Aosp Building","keywords":"","body":"1. AOSP编译1.1. Ubuntu16.04需要的依赖设置:1.2. 下载aosp1.2.1. 如果需要某个特定的 Android 版本:1.3. AOSP编译刷入Pixel1.3.1. 编译aosp:1.3.2. 刷入镜像 :1.3.3. 进入开发者模式1.3.4. 编译模拟器1.4. 编译jar1.4.1. 编译framework.jar等jar1.4.2. Android系统目录下 各jar包作用1.5. classes.jar编译1.6. So的编译1.6.1. 如何看cpp编到哪个so1.6.2. 为子系统重新单独编译动态库的方法1.7. WIFI联网1.7.1. wifi连接的前提1.7.2. 原生安卓 WiFi 网络受限、优化网速1.8. kernel如何编译？1.9. AOSP模拟器的编译1.9.1. 在aosp编译目录下启动1.9.2. 替换AS自带模拟器的img1.9.3. 实现能够导入jar1.9.4. 常用emulator命令：1.10. native实现clion跳转1.11. 问题：1.11.1. framework.jar导入手机后不生效问题1.11.2. mm cmd fails in /framework/base1.11.3. 编译报错TreeviewCopyright © aleen42 all right reserved, powered by aleen42 AOSP编译 Ubuntu16.04需要的依赖设置: 下载aosp 如果需要某个特定的 Android 版本: AOSP编译刷入Pixel 编译aosp: 刷入镜像 : 进入开发者模式 编译模拟器 编译jar 编译framework.jar等jar Android系统目录下 各jar包作用 classes.jar编译 So的编译 如何看cpp编到哪个so 为子系统重新单独编译动态库的方法 WIFI联网 wifi连接的前提 原生安卓 WiFi 网络受限、优化网速 kernel如何编译？ AOSP模拟器的编译 在aosp编译目录下启动 替换AS自带模拟器的img 实现能够导入jar 常用emulator命令： native实现clion跳转 问题： framework.jar导入手机后不生效问题 mm cmd fails in /framework/base 编译报错 [TOC] 1. AOSP编译 1.1. Ubuntu16.04需要的依赖设置: apt-get install openjdk-8-jdk apt-get install git ccache automake lzop bison gperf build-essential zip curl zlib1g-dev g++-multilib python-networkx libxml2-utils bzip2 libbz2-dev libbz2-1.0 libghc-bzlib-dev squashfs-tools pngcrush schedtool dpkg-dev liblz4-tool make optipng maven libc6-dev linux-libc-dev gcc-multilib g++-5-multilib libssl-dev $ sudo apt-get update $ sudo apt-get install git-core gnupg flex bison gperf build-essential $ sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib libc6-dev-i386 $ sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev lib32z-dev ccache $ sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4 sudo apt-get install libx11-dev:i386 libreadline6-dev:i386 libgl1-mesa-dev g++-multilib sudo apt-get install -y git flex bison gperf build-essential libncurses5-dev:i386 sudo apt-get install tofrodos python-markdown libxml2-utils xsltproc zlib1g-dev:i386 sudo apt-get install dpkg-dev libsdl1.2-dev libesd0-dev sudo apt-get install git-core gnupg flex bison gperf build-essential sudo apt-get install zip curl zlib1g-dev gcc-multilib g++-multilib sudo apt-get install libc6-dev-i386 sudo apt-get install lib32ncurses5-dev x11proto-core-dev libx11-dev sudo apt-get install libgl1-mesa-dev libxml2-utils xsltproc unzip m4 sudo apt-get install lib32z-dev ccach 安装make aptitude install gcc automake autoconf libtool make aptitude install gcc gcc-c++ 1.2. 下载aosp 优选清华镜像 + 开启代理 （为啥不开代理会失败呢？） repo init -u https://mirrors.tuna.tsinghua.edu.cn/git/AOSP/platform/manifest -b android-12.0.0_r28 repo sync -c -j32 //中科大 repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-8.0.0_r13 repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-10.0.0_r17 repo init -u git://mirrors.ustc.edu.cn/aosp/platform/manifest -b android-12.0.0_r28 //google原生 repo init -u https://android.googlesource.com/platform/manifest -b android-12.0.0_r28 repo sync -c -j8 repo sync -c --no-tag -j4 也可以这样切换其他分支-----> 待验证？？？ repo init -b android-6.0.1_r63 error：如果提示无法连接到 gerrit.googlesource.com？ vim /bin/repo 修改! REPO_URL='https://mirrors.tuna.tsinghua.edu.cn/git/git-repo' 1.2.1. 如果需要某个特定的 Android 版本: https://source.android.com/setup/start/build-numbers#source-code-tags-and-builds 目前，安卓10使用版本： 安卓12使用版本： 1.3. AOSP编译刷入Pixel -------> 完美！！！，按照该教程，可行！ 注意一点: 驱动vender（刷真机，涉及到vender，不同机子，不同vender） https://blog.csdn.net/cl769796350/article/details/102676674?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param 本人使用的是pixel一代-------> 代号为sailfish 1.3.1. 编译aosp: source build/envsetup.sh lunch ------> 看一下有哪些选项，很多64版本的 aosp_sailfish-userdebug //这里选userdebug版本，拥有root权限 lunch aosp_sailfish-userdebug make -j8 1.3.2. 刷入镜像 : 切换到目录 /aosp/out/target/product/自己手机的代号 设置临时变量 set ANDROIDPRODUCT_OUT = H:\\dockerSharedFiles\\aosp_android1000_r17\\out\\product\\sailfish #进入bootloader模式 adb reboot bootloader # 自动刷入 -w双清 : fastboot flashall -w 重启手机 fastboot reboot 拷贝到本地， cp /home/chen/workingSpace/aosp/out/ /home/chen/workingSpace/local/ -R 设置变量：ANDROID_PRODUCT_OUT 添加一个 进入window的目录： 注意：adb要用1.0.41的，安卓studio自带即可： C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\platform-tools 1.3.3. 进入开发者模式 点击版本号 1.3.4. 编译模拟器 见后 1.4. 编译jar 1.4.1. 编译framework.jar等jar 编译某一个模块： https://blog.csdn.net/weixin_39914868/article/details/112402060 source build/envsetup.sh lunch aosp_sailfish-userdebug //这里选userdebug版本，拥有root权限 make framework -j8 归结： source build/envsetup.sh;lunch aosp_sailfish-userdebug; make framework -j8;python /home/chen/workingSpace/local/aosp_android1000_r17/python_install/replaceFiles/cpSo.py 1.4.2. Android系统目录下 各jar包作用 am.jar：终端下执行am命令时所需的java库。源码目录：framework/base/cmds/am android.policy.jar：锁屏界面需要用到的jar包，该包引用了android.test.runner.jar，源码目录：framework/base/policy ---------》没找到？？ android.test.runner.jar：测试应用所需的jar包，该包引用了core.jar,core-junit.ajr以及framework.jar，源码目录：framework/base/test-runner bmgr.jar：adb shell命令下对Android Device所有package备份和恢复的操作时所需的java库。官方文档：http://developer.android.com/guide/developing/tools/bmgr.html。不过这个android服务默认是Disabled，而且要backup的应用必须实现BackupAgent，在AndroidManifest.xml的application标签中加入android：backupAgent属性。源码目录：framework/base/cmds/bmgr bouncycastle.jar： java三方的密匙库，网上资料说用来apk签名、https链接之类，官网 ：http://www.bouncycastle.org/java.html com.android.future.usb.accessory.jar：用于管理USB的上层java库，在系统编译时hardware层会调用到。源码目录：frameworks/base/libs/usb com.android.location.provider.jar： com.android.nfc_extras.jar：NFC外部库。android/nfc/NfcAdapter.java会调用到包中的NfcAdapterExtras.java。源码目录：frameworks/base/nfc-extras core-junit.jar ：junit核心库，在运行*Test.apk时被调用。 core-tests*.jar：framework下的一系列测试jar包，不做测试时可删除。 core.jar：核心库，启动桌面时首先加载这个。源码目录： ext.jar：android外部三方扩展包，源码主要是external/nist-sip（java下的sip三方库）、external/apache-http（apache的java三方库）、external/tagsoup（符合SAX标准的HTML解析器）。其实这个jar包可以添加外部扩展jar包，只需在framework/base/Android.mk中的ext-dirs添加src目录即可。 framework-res.apk：android系统资源库。 framework.jar：android的sdk中核心代码。 ime.jar：ime命令所需jar包，用于查看当前话机输入法列表、设置输入法。源码目录：framework/base/cmds/ime input.jar：input命令所需的jar包，用于模拟按键输入。源码目录：framework/baes/cmds/input javax.obex.jar：java蓝牙API，用于对象交换协议。源码目录：framework/base/obex monkey.jar：执行monkey命令所需jar包。源码目录：framework/base/cmds/monkey pm.jar：执行pm命令所需的jar包，pm详情见adb shell pm，源码目录：framework/base/cmds/pm services.jar：话机框架层服务端的编译后jar包，配合libandroid_servers.so在话机启动时通过SystemServer以循环闭合管理的方式将各个service添加到ServiceManager中。源码目录：framework/base/service sqlite-jdbc.jar： sqlite的Java DataBase Connextivity jar包。 svc.jar：svc命令所需jar包，可硬用来管理wifi,power和data。源码目录：framework/base/cmds/svc 如何知道编译文件对应的jar： 1、网上搜索：编译core\\java\\com\\android\\internal\\policy\\DecorView.java -----> 编译后在out\\target\\product\\msm8909\\system\\framework目录将会出现android.policy.jar文件，然后执行下面命令替换系统文件 2、yangyunfan教程 1.5. classes.jar编译 framework.jar原始没有打包加密的jar路径： \\out\\target\\common\\obj\\JAVA_LIBRARIES\\framework_intermediates\\classes.jar 基于此，可以做很多事情： 1、依赖跳转 2、依赖编译 3、依赖断点调试 1.6. So的编译 在android开发中，有时候需要编写一些C/C++代码，这时候就要用到JNI技术，我们需要将C/C++程序首先编译成so库，在java中通过native方法调用so库中的函数。 实现以上目的有三种方式： 1、单独编译so库文件，将它push到手机的system/lib目录下， 在java程序中通过loadLibrary加载so库。 2、使用NDK工具进行编译，需要配置NDK环境，然后通过Android Studio将其打包打APK中。 3、在Android源码环境中使用mm，so文件就能够打包到APK文件中，随着APK一起发布，而不是将so文件放到系统目录中。 1.6.1. 如何看cpp编到哪个so 方法一：so与路径的对应 https://blog.csdn.net/koumen3/article/details/50681575 折叠 libEGL.so------frameworks/native/opengl/libs/EGL/ libandroid.so——frameworks/base/native/android libandroid_runtime.so——frameworks/base/core/jni libandroidfw.so——frameworks/base/libs/androidfw libaudioutils.so——system/media/audio_utils libbinder.so——frameworks/native/libs/binder libbluedroid.so——system/bluetooth/bluedroid libc.so——bionic/libc libcamera_client.so——frameworks/av/camera libcorkscrew.so——system/core/libcorkscrew libcpustats.so——frameworks/native/libs/cpustats libcrypto.so——external/openssl libcutils.so——system/core/libcutils libdbus.so——external/dbus/dbus libdvm.so——dalvik/vm libemoji.so——frameworks/opt/emoji libETC1.so——frameworks/native/opengl/libs libgccdemangle——external/gcc-demangle libgui.so——frameworks/native/libs/gui libgabi++.so——abi/cpp libGLESv1_CM.so——frameworks/native/opengl/libs libharfbuzz.so——external/harfbuzz libhwui.so——frameworks/base/libs/hwui libhardware_legacy.so——hardware/libhardware_legacy libjpeg.so——external/jpeg libmedia.so——frameworks/av/media/libmedia libmedia_native.so——frameworks/av/media/libmedia_native libnetutils.so——system/core/libnetutils libstagefright_foundation.so——frameworks/av/media/libstagefright/foundation libsonivox.so——external/sonivox libspeexresampler——external/speex libstlport.so——external/stlport libssl.so——external/openssl libui.so——frameworks/native/libs/ui libutils.so——frameworks/native/libs/utils libusbhost.so——system/core/libusbhost 方法二：看andriod.bp（优秀） 方法三：破坏cpp文件，编译时会log出编译的目标 编译方法： //进入所需要的编译的目录，mm chen@58495cde205d:~/workingSpace/aosp_android1000_r17/frameworks/native/libs/binder$ mm // 编译生成的动态库在 out/target/product/xxxx/system/lib/ 目录下。使用以下命令更新设备上的库文件： adb push libaudioflinger.so /system/lib/ mm命令使用的前提: 启用 mm 等工具： 在同一个终端里面需要先在项目根目录下执行 source build/envsetup.sh 命令 1.6.2. 为子系统重新单独编译动态库的方法 https://blog.csdn.net/Qidi_Huang/article/details/53690139 1.7. WIFI联网 1.7.1. wifi连接的前提 -规定： 任何机器，刷完版本，第一件事情，就是同步时间(无论是否联网) --------> 因为这是联网的必要条件！！（即使能联网，也要同步，会有各种问题） 同步时间方法：： //setTime.py import os import datetime now = datetime.datetime.now() date_time = now.strftime(\"%m%d%H%M%Y.%S\") print(date_time) os.system(\"adb shell \\\"date %s\\\"\" % date_time) 1.7.2. 原生安卓 WiFi 网络受限、优化网速 忽略： https://www.xiaoyi.vc/captive-portal.html 非ROOT方法 没有 ROOT 的安卓机可以借助 ADB 命令来修改，首先下载ADB工具包，然后手机开启USB调试模式，接着运行 CMD 输入下面的命令就可以了。 **# 删除默认的地址 adb shell settings delete global captive_portal_https_url adb shell settings delete global captive_portal_http_url # 修改新的地址 adb shell settings put global captive_portal_http_url http://connect.rom.miui.com/generate_204 adb shell settings put global captive_portal_https_url https://connect.rom.miui.com/generate_204 改完同样把手机切换飞行模式，再切换回来就可以了。如果需要其它服务器地址，自行修改，如MIUI 的是 http://connect.rom.miui.com/generate_204 地址。 注意两点： 1、改完同样把手机切换飞行模式 2、MIUI 的是 http://connect.rom.miui.com/generate_204 1.8. kernel如何编译？ TODO： 1.9. AOSP模拟器的编译 1.9.1. 在aosp编译目录下启动 编译产品aosp_sailfish //先初始化环境 source build/envsetup.sh lunch aosp_sailfish-userdebug USER@MACHINE:~/Android$ export PATH=$PATH:~/Android/out/host/linux-x86/bin export PATH=$PATH:~/workingSpace/local/aosp_android1000_r17/aosp_android1000_r17/out/host/linux-x86/bin USER@MACHINE:~/Android$ export ANDROID_PRODUCT_OUT=~/Android/out/target/product/generic export ANDROID_PRODUCT_OUT=~/workingSpace/local/aosp_android1000_r17/aosp_android1000_r17/out/target/product/generic USER@MACHINE:~/Android$ emulator //aosp_android12_00_r28: source build/envsetup.sh lunch aosp_bramble-userdebug export PATH=$PATH:~/workingSpace/aosp_android12_00_r28/out/host/linux-x86/bin ANDROID_PRODUCT_OUT=~/workingSpace/aosp_android12_00_r28/out/target/product/bramble/ emulator -qemu -machine virt ------------> 一直失败，没有成功过： 1.9.2. 替换AS自带模拟器的img 参考文章： https://blog.csdn.net/feng397041178/article/details/123731513 主要文章 ​ https://blog.csdn.net/mvp_Dawn/article/details/126848798 ​ https://blog.csdn.net/liaosongmao1/article/details/124843073 win下或linux下都可以，以win为例： （1）编译emulator_x86_64：（不是编译bramble等产品！） 编译命令：编译参考： 遇到的问题：lunch中，没有sdk_x86_64 编译选项 解决：https://blog.csdn.net/Q1302182594/article/details/125514065 https://blog.csdn.net/yongwn/article/details/121009506 source build/envsetup.sh lunch sdk_x86_64 // -------》 结果：out/target/product/emulator_x86_64/ 注意点： 1、out/target/product/emulator_x86_64/ 路径下，有-qemu.img，尽量用带-qemu.img的： ramdisk-qemu.img,system-qemu.img,vendor-qemu.img ----> 2、最大限度替换：尽量把 win下里的文件都替换掉 C:\\Users\\用户名\\AppData\\Local\\Android\\Sdk\\system-images\\android-30\\google_apis_playstore\\x86_64 注意：两个目录下文件很像，是后者 Sdk\\system-images\\android-30\\google_apis下的 1.9.3. 实现能够导入jar adb remount失败： 参考：https://blog.csdn.net/mvp_Dawn/article/details/126848798 修改启动（增加了-writable-system），获取写权限： ::startEmulator.bat set emulator_exe=D:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\emulator\\emulator.exe %emulator_exe% -avd Pixel_5_API_31 -writable-system -memory 4096 ::-sysdir似乎没用 -sysdir D:\\Green_Sorft\\Android\\Sdk\\system-images\\android-30\\default\\x86_64-aosp 1.9.4. 常用emulator命令： ::查看有哪些模拟器镜像 %emulator_exe% -list-avds %emulator_exe% -help： 折叠 D:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\emulator>%emulator_exe% -help Android Emulator usage: emulator [options] [-qemu args] options: -list-avds list available AVDs -sysdir search for system disk images in -system read initial system image from -vendor read initial vendor image from -writable-system make system & vendor image writable after 'adb remount' -delay-adb delay adb communication till boot completes -datadir write user data into -kernel use specific emulated kernel -ramdisk ramdisk image (default /ramdisk.img -image obsolete, use -system instead -initdata same as '-init-data ' -data data image (default /userdata-qemu.img -encryption-key read initial encryption key image from -logcat-output output file of logcat(default none) -partition-size system/data partition size in MBs -cache cache partition image (default is temporary file) -cache-size cache partition size in MBs -no-cache disable the cache partition -nocache same as -no-cache -sdcard SD card image (default /sdcard.img -quit-after-boot qeuit emulator after guest boots completely, or after timeout in seconds -qemu-top-dir Use the emulator in the specified dir (relative or absolute path) -monitor-adb monitor the adb messages between guest and host, default not -snapstorage file that contains all state snapshots (default /snapshots.img) -no-snapstorage do not mount a snapshot storage file (this disables all snapshot functionality) -snapshot name of snapshot within storage file for auto-start and auto-save (default 'default-boot') -no-snapshot perform a full boot and do not auto-save, but qemu vmload and vmsave operate on snapstorage -no-snapshot-save do not auto-save to snapshot on exit: abandon changed state -no-snapshot-load do not auto-start from snapshot: perform a full boot -snapshot-list show a list of available snapshots -no-snapshot-update-time do not try to correct snapshot time on restore -wipe-data reset the user data image (copy it from initdata) -avd use a specific android virtual device -avd-arch use a specific target architecture -skindir search skins in (default /skins) -skin select a given skin -no-skin deprecated: create an AVD with no skin instead -noskin same as -no-skin -memory physical RAM size in MBs -ui-only run only the UI feature requested -id assign an id to this virtual device (separate from the avd name) -cores Set number of CPU cores to emulator -accel Configure emulation acceleration -no-accel Same as '-accel off' -ranchu Use new emulator backend instead of the classic one -engine Select engine. auto|classic|qemu2 -netspeed maximum network download/upload speeds -netdelay network latency emulation -netfast disable network shaping -code-profile enable code profiling -show-kernel display kernel messages -shell enable root shell on current terminal -no-jni deprecated, see dalvik_vm_checkjni -nojni deprecated, see dalvik_vm_checkjni -dalvik-vm-checkjni Enable dalvik.vm.checkjni -logcat enable logcat output with given tags -log-nofilter Disable the duplicate log filter -no-audio disable audio support -noaudio same as -no-audio -audio use specific audio backend -radio redirect radio modem interface to character device -port TCP port that will be used for the console -ports , TCP ports used for the console and adb bridge -modem-simulator-port TCP port that will be used for android modem simulator -onion use overlay PNG image over screen -onion-alpha specify onion-skin translucency -onion-rotation 0|1|2|3 specify onion-skin rotation -dpi-device specify device's resolution in dpi (default DEFAULT_DEVICE_DPI) -scale scale emulator window (deprecated) -wifi-client-port connect to other emulator for WiFi forwarding -wifi-server-port listen to other emulator for WiFi forwarding -http-proxy make TCP connections through a HTTP/HTTPS proxy -timezone use this timezone instead of the host's default -change-language use this language instead of the current one. Restarts the framework. -change-country use this country instead of the current one. Restarts the framework. -change-locale use this locale instead of the current one. Restarts the framework. -dns-server use this DNS server(s) in the emulated system -net-tap use this TAP interface for networking -net-tap-script-up script to run when the TAP interface goes up -net-tap-script-down script to run when the TAP interface goes down -cpu-delay throttle CPU emulation -no-boot-anim disable animation for faster boot -no-window disable graphical window display -qt-hide-window Start QT window but hide window display -no-sim device has no SIM card -lowram device is a low ram device -version display emulator version number -no-passive-gps disable passive gps updates -gnss-file-path Use the specified filepath to read gnss data -gnss-grpc-port Use the specified port number to start grpc service to receive gnss data -virtio-console using virtio console as console -read-only allow running multiple instances of emulators on the same AVD, but cannot save snapshot. -is-restart specifies that this emulator was a restart, and to wait out before proceeding -report-console report console port to remote socket -gps redirect NMEA GPS to character device -shell-serial specific character device for root shell -tcpdump capture network packets to file -bootchart enable bootcharting -charmap use specific key character map -studio-params used by Android Studio to provide parameters -prop = set system property on boot -shared-net-id join the shared network, using IP address 10.1.2. -gpu set hardware OpenGLES emulation mode -use-host-vulkan use host for vulkan emulation regardless of 'gpu' mode -camera-back set emulation mode for a camera facing back -camera-front set emulation mode for a camera facing front -webcam-list lists web cameras available for emulation -virtualscene-poster = Load a png or jpeg image as a poster in the virtual scene -screen set emulated screen mode -force-32bit always use 32-bit emulator -selinux Set SELinux to either disabled or permissive mode -unix-pipe Add to the list of allowed Unix pipes -fixed-scale Use fixed 1:1 scale for the initial emulator window. -wait-for-debugger Pause on launch and wait for a debugger process to attach before resuming -skip-adb-auth Skip adb authentication dialogue -metrics-to-console Enable usage metrics and print the messages to stdout -metrics-collection Enable usage metrics and send them to google play -metrics-to-file Enable usage metrics and write the messages into specified file -detect-image-hang Enable the detection of system image hangs. -feature Force-enable or disable (-name) the features -icc-profile Use icc profile from specified file -sim-access-rules-file Use SIM access rules from specified file -phone-number Sets the phone number of the emulated device -acpi-config specify acpi device proprerties (hierarchical key=value pair) -fuchsia Run Fuchsia image. Bypasses android-specific setup; args after are treated as standard QEMU args -window-size Set window size for when bypassing android-specific setup. -allow-host-audio Allows sending of audio from audio input devices. Otherwise, zeroes out audio. -restart-when-stalled Allows restarting guest when it is stalled. -perf-stat Run periodic perf stat reporter in the background and write output to specified file. -share-vid Share current video state in shared memory region. -grpc TCP ports used for the gRPC bridge. -grpc-tls-key File with the private key used to enable gRPC TLS. -grpc-tls-cer File with the public X509 certificate used to enable gRPC TLS. -grpc-tls-ca File with the Certificate Authorities used to validate client certificates. -grpc-use-token Use the emulator console token for gRPC authentication. -grpc-use-jwt Use a signed JWT token for gRPC authentication. -idle-grpc-timeout Terminate the emulator if there is no gRPC activity within seconds. -waterfall Mode in which to run waterfall. -rootcanal-hci-port Rootcanal virtual hci port. -rootcanal-test-port Rootcanal testing port. -rootcanal-link-port Rootcanal link layer port. -rootcanal-link-ble-port Rootcanal link ble layer port. -rootcanal-controller-properties Rootcanal controller_properties.json file. -rootcanal-default-commands-file Rootcanal commands file to run on launch. -rootcanal-no-mesh Disable auto discovery and connection bluetooth enabled emulators -forward-vhci Enable the VHCI grpc forwarding service. -multidisplay index width height dpi flag config multiple displays. -google-maps-key API key to use with the Google Maps GUI. -no-location-ui Disable the location UI in the extended window. -use-keycode-forwarding Use keycode forwarding instead of host charmap translation. -record-session ,[,] Screen record the emulator session. -legacy-fake-camera Use legacy camera HAL for the emulated fake camera. -camera-hq-edge Enable high qualify edge processing for emulated camera. -no-direct-adb Use external adb executable for internal communication. -check-snapshot-loadable Check if a snasphot is loadable. -no-hidpi-scaling Disable HiDPI scaling of guest display on macOS devices. -no-mouse-reposition Do not reposition the mouse to emulator window center if mouse pointer gets out of the window. -guest-angle Enable guest ANGLE as system driver. -usb-passthrough VID PID BUS PORTS Host USB device Passthrough -append-userspace-opt key=value Appends a property which is passed to the userspace. -save-path Override save path for screenshot and bug report. The value will not be persisted on host OS. -no-nested-warnings Disable the warning dialog when emulator is running in nested virtualization. -wifi-tap use this TAP interface for Virtio Wi-Fi -wifi-tap-script-up script to run when the TAP interface goes up -wifi-tap-script-down script to run when the TAP interface goes down -wifi-vmnet This option is alias to vmnet, it is used for backward compatibility. -vmnet Use this network and enable vmnet framework as the backend of tap netdev on MacOS. -qemu args... pass arguments to qemu -qemu -h display qemu help -verbose same as '-debug-init' -debug enable/disable debug messages -debug- enable specific debug messages -debug-no- disable specific debug messages -help print this help -help- print option-specific help -help-disk-images about disk images -help-debug-tags debug tags for -debug -help-char-devices character specification -help-environment environment variables -help-virtual-device virtual device management -help-sdk-images about disk images when using the SDK -help-build-images about disk images when building Android -help-all prints all help content 1.10. native实现clion跳转 见《HowToReadCode.md》 编译：CMakeLists.txt https://blog.csdn.net/iamdy/article/details/106658583 https://cloud.tencent.com/developer/article/1645922 源码中的build/soong/docs/clion.md cpp断点调试 https://blog.csdn.net/iamdy/article/details/111272854?spm=1001.2014.3001.5501 问题： 编译后没有64位，只有32位 ----》解决方法：主动lunch一次 --->设置编译目标带64版本的，比如2 1.11. 问题： 1.11.1. framework.jar导入手机后不生效问题 原因一：-------》可能不需要 原因：在编译期间会将 jar 包中的 dex 文件编译为 odex、vdex 等文件。而这些文件并不存放在 framework.jar 中，所以会导致单独 push framework.jar 后，修改的内容不生效。 https://blog.csdn.net/yjsz2010/article/details/103705510 - 原因二：-----》已经验证 push程序framework.jar失效问题： 先加载了/system/framework/arm目录和/system/framework/arm64目录中的boot.art和boot.oat -规定： 推framework.jar，必须先 删除arm和arm64、ota 即： adb shell rm -rf /system/framework/arm adb shell rm -rf /system/framework/arm64 adb shell rm -rf /system/framework/ota adb push framework.jar /system/framework 1.11.2. mm cmd fails in /framework/base On Android version 8.1.0 project specific build with mm cmd is failing in /framework/base [100% 1/1] out/soong/.bootstrap/bin/soong_build out/soong/build.ninja ninja: error: 'out/host/linux-x86/framework/host-libprotobuf-java-full.jar', needed by 'out/host/common/obj/JAVA_LIBRARIES/platformprotos_intermediates/classes-full-debug.jar', missing and no known rule to make it 12:55:19 ninja failed with: exit status 1 --------》 mm compiles all modules in a directory, you are missing a dependency of one of the modules. This is pretty common because regular builds do not compile tests or their dependencies. You can run 'hmm' to see commands that do take dependencies into account. In this case, you want 'mma': λ hmm | grep \" mm\" - mm: Builds all of the modules in the current directory, but not their dependencies. - mmm: Builds all of the modules in the supplied directories, but not their dependencies. ​ To limit the modules being built use the syntax: mmm dir/:target1,target2. - mma: Builds all of the modules in the current directory, and their dependencies. - mmma: Builds all of the modules in the supplied directories, and their dependencies. 1.11.3. 编译报错 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/AS.html":{"url":"coding/Tool/AS.html","title":"AS","keywords":"","body":"1. AS:1.1. AS 搭建断点java调试环境1.2. 查看类族图谱（clion一样）1.3. 查看属性生命周期1.4. 查看调用栈1.5. 快速了解函数所处哪个内部类里:1.6. 快速搜索函数1.7. 代码飘红1.8. ide本身就可以完全替代 界面小乌龟1.8.1. 可以查看历史某一次变动：1.8.2. 类似于小乌龟的GUI-- commit 的操作:1.8.3. 利用 ide 替代小乌龟: commit & push1.8.4. 体会1.9. 任意ide 如何默认 Terminal使用 bash?1.10. 内存泄漏的定位：1.11. AS的plugin1.11.1. AS高亮1.11.2. GitToolBox 工具----非常有用1.11.3. AS 搜索方法使用地方：1.12. AS 方法分割线1.13. 空白点的设置1.14. 关于 win 与 linux AS抢占的问题：1.14.1. 如何解决：1.14.2. 最优使用：1.15. 验证过的版本1.16. 问题1.16.1. 签名问题1.16.2. could not open selected VM debug port1.16.3. 代理配置问题：1.16.4. AS debug看不到进程1.17. 快捷键2. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 AS: AS 搭建断点java调试环境 查看类族图谱（clion一样） 查看属性生命周期 查看调用栈 快速了解函数所处哪个内部类里: 快速搜索函数 代码飘红 ide本身就可以完全替代 界面小乌龟 可以查看历史某一次变动： 类似于小乌龟的GUI-- commit 的操作: 利用 ide 替代小乌龟: commit & push 体会 任意ide 如何默认 Terminal使用 bash? 内存泄漏的定位： AS的plugin AS高亮 GitToolBox 工具----非常有用 AS 搜索方法使用地方： AS 方法分割线 空白点的设置 关于 win 与 linux AS抢占的问题： 如何解决： 最优使用： 验证过的版本 问题 签名问题 could not open selected VM debug port 代理配置问题： 本质： AS debug看不到进程 快捷键 格式 [TOC] 1. AS: 1.1. AS 搭建断点java调试环境 见 《HowToReadCode， 如何用源码搭建java断点调试环境》 1.2. 查看类族图谱（clion一样） 认识一个新类： 需要快速了解家族图谱，比如 view的0层家族图谱 0层向下族谱： 0层向上族谱： 可以copy文字版： 1.3. 查看属性生命周期 1.4. 查看调用栈 向上（或向下）调用栈: 可以copy文字版 1.5. 快速了解函数所处哪个内部类里: 小技巧： 快速了解函数所处哪个内部类里 快速了解一段代码在哪个函数里（大函数） 1.6. 快速搜索函数 structure中：点击任意位置都可以搜索（优） Ctrl +E 最近文件中：可以搜 ALT + F7： find usage 可以搜 1.7. 代码飘红 飘红 : aosp编译出的framework.jar作为lib依赖，给普通工程用。比如Z的工程 1.8. ide本身就可以完全替代 界面小乌龟 1.8.1. 可以查看历史某一次变动： AS 类似有界面小乌龟: 切换分支 ----》 commit 信息 ----》 commit 下所有变动文件（以及对应的commit网站）---》某变动下的diff 前提：打开的工程是一个git仓 ------》 似乎repo的根目录不行 1.8.2. 类似于小乌龟的GUI-- commit 的操作: 1.8.3. 利用 ide 替代小乌龟: commit & push https://birkhoffg.github.io/blog/posts/how-to-committing-code-using-intellij-idea/ 1.8.4. 体会 体会：（不仅限于git） 1、为什么要会用命令呢？-------主 因为它更本质，从而可以适用于所有场合（win、linux、linux无GUI的）---------》 一法通万法通，永不过时（GUI很可能变化） 为什么更本质? 因为GUI只是对 命令 的封装 2、为什么还需要一些界面呢？--------景，比如看一个文件的diff时 ---------》 优：主+次（某些场景，GUI） 1.9. 任意ide 如何默认 Terminal使用 bash? 任意ide（As 或 clion 等） Bash 好处： 1、 linux下命令 2、启动自动运行（自定义一些变量） 1.10. 内存泄漏的定位： https://www.jianshu.com/p/19fd60f40e92?from=groupmessage 1、粗略估计 adb shell dumpsys meminfo 包名 2、Android Profiler使用详解 1.11. AS的plugin 1.11.1. AS高亮 0、最优：使用高亮的插件MultiHighlight 1、ctrl + F 2、双击选中 --->会给你信息流 （计算机的本质） --->x信息最终给到了touchBounds ​ ---》在此之前x信息被getScrollx改写了 设置: 1.11.2. GitToolBox 工具----非常有用 1、查看某一行提交(以某一行为中心链接最新改动人、改动的commit) 2、查看当前行改动的commit下----所有相关改动 https://github.com/zielu/GitToolBox/wiki/Manual AS里找这个操作的快捷键 ALT + Shift + B --》查看commit所有信息 --------》所以, 阅读工具对应的英文文档、github英文文档，很有效 图 查看该commit 所有改变 1.11.3. AS 搜索方法使用地方： ------》 修改为： alt + f 1.12. AS 方法分割线 https://www.yii666.com/article/612482.html?action=onAll 1.13. 空白点的设置 1.14. 关于 win 与 linux AS抢占的问题： 1.14.1. 如何解决： 由于docker的AS是通过win间接连接手机 同时都开AS，在使用debug、monitor、layout inspector等时会有抢占问题： 如何解决抢占：win下AS相对强一些 1、若要使用win的AS： ​ 关闭给linux的端口转发即可 2、若要使用linux的AS： ​ 关闭win侧的AS 1.14.2. 最优使用： 因目前电脑配置低：linux AS比较卡顿、layout inspector获取的结果比较差、切换中文比较蛮烦 ------------> 所以，AS主要用在win下（等后续增强pc配置） 1.15. 验证过的版本 1.16. 问题 Default Activity Not Found解决方法 需要一个没有任何界面、只有一个后台Service的程序。但是在安装的工程中出现如下问题：Default Activity Not Found，如图： 解决方法： 这是因为只有一个Service，没有默认的Activity导致的。 点击上方 Edit Configurations；选择General目录下的Launch Options，选中Nothing 1.16.1. 签名问题 the apk for your currently selected variant(app-release-unsigned.apk)is not signed. 签名问题。一般debug不签名 解决办法如下： 1.点击BuildVariants，然后设置BuildVariant为debug。 1.16.2. could not open selected VM debug port 启动monitor时，could not open selected VM debug port(8700) 怎么解决 先关掉as，打开monitor之后，再开AS https://blog.csdn.net/m0_49255099/article/details/107654950?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromBaidu-2.not_use_machine_learn_pai monitor路径：C:\\Users\\Administrator\\AppData\\Local\\Android\\Sdk\\tools 点击monitor.bat 1.16.3. 代理配置问题： 《-------- dl.google.com:443 failed to respond http://www.baidu.com http://www.google.com 如果有的话： 本质： 方法一： 自然，方法二： 新版本:利用HTTP 注：自然也可以利用socks 1.16.4. AS debug看不到进程 方法： adb kill-server adb connect host.docker.internal:7788 1.17. 快捷键 代码展开折叠 Ctrl + + 展开代码（局部） Ctrl + - 折叠代码（局部） ---》很有用 Ctrl + Shift + + 展开所有代码 Ctrl + Shift + - 折叠所有代码 Ctrl + E 来替代 多行显示 -----》 极优 原因： 1、多行 占用 代码显示空间，很垃圾 2、多行 没有最近使用的一个stack排序，当文件显示超过四五个，没有优先级 -----》 造成很难找 3、人找文件是按照首字母去找， 多行，非常bug，眼睛要扫完整个文件名才能看下一个（Ctrl + E 从上到下，只需匹配首字母） ----》非常垃圾 在回退功能上：也尽量用 Ctrl + E 来替代 回退快捷键 原因：1、Ctrl + E 可以快速回到 最初的地方 2、逼迫自己记忆 是从 哪个房间过来的（无需记忆方法），利于结构的记忆 3、回退功能，对记忆有伤害： -规定： 禁止用多行，少用回退，多用Ctrl + E Ctrl + Shift +F ： find in files ---------> 文本查找（很优：1、不限于符号，全局查找 文本 2、有时候文件没有被source，没办法当做符号查） Shift + Shift ------> 全局 查找 符号 ALT + F (个人定制) -----> Find Usages:(很优： 当引用的地方非常多时，read、write已经极大缩小范围了) 2. 格式 折叠 网站上显示能折叠图片 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/clion.html":{"url":"coding/Tool/clion.html","title":"Clion","keywords":"","body":"1. clion1.1. clion第一次打开工程1.2. clion目录结构1.3. clion win与linux代码同步1.4. clion cpp跳转问题：1.5. AOSP Native代码导入CLion，跳转问题1.6. clion加速1.6.1. exclude没用的文件目录1.6.2. clion关闭自动索引index1.6.3. 终极手段：保存.cache?1.7. 权限问题：1.8. 激活码TreeviewCopyright © aleen42 all right reserved, powered by aleen42 clion clion第一次打开工程 clion目录结构 clion win与linux代码同步 clion cpp跳转问题： AOSP Native代码导入CLion，跳转问题 clion加速 exclude没用的文件目录 clion关闭自动索引index 终极手段：保存.cache? 权限问题： 激活码 [TOC] 1. clion 1.1. clion第一次打开工程 对于没有cmakeList.txt的工程，选择自动生成cmakeList.txt 1.2. clion目录结构 .idea index在这里 cmake-build-aospnativedebug cmake编译的一些信息 1.3. clion win与linux代码同步 https://cloud.tencent.com/developer/article/1406250 使用Clion优雅的完全远程自动同步和远程调试c++ 1.4. clion cpp跳转问题： cljon实现跳转几点结论： 1、clion通过.h链接，实现跳转 --->结论：保证能跳进所有的.h(看头文件，没有标红), 那么所有工程都OK 2、clion通过cmakelist编译链接，实现跳转的 对于gn编译的项目，clion自动生成cmakelist, 实现跳转－－> 可能会存在问题 根本原因：两套direction base导致的 第一套：gn编译，.c里的#include \"src/sksl/ir/SkSLProgram.h\" 以src上一层作为base 第二套：cmakeList。如果自动生成的CMakeLists.txt没有以上—层为base, 则无法找到SkSLProgram.h, 从而无法跳转 解决方法：cmakeList.txt中 添加include_directories(上一层路径） 以Skia源码为例： ---->说明include/core/SkBitmap.h的direction base没有include_directories进来 上一层即根目录 1.5. AOSP Native代码导入CLion，跳转问题 见： HowToReadCode 中《framework Native Clion 跳转环境（linux下）》 1.6. clion加速 1.6.1. exclude没用的文件目录 1.6.2. clion关闭自动索引index 1.6.3. 终极手段：保存.cache? du -sh * index最终存储在.cache中，可以看见，索引很大 ----> 如何不让它更新呢？ https://plugins.jetbrains.com/plugin/12334-gradianto/versions https://plugins.jetbrains.com/plugin/11938-one-dark-theme https://www.thinbug.com/q/36628483 验证： 重启ide： 1、index缓冲区大小是否变2、会不会重新index ---》备份缓冲区 1.7. 权限问题： Error running 'cpp_leetcode': Cannot run program \"G:\\working_pan\\PROJECTS\\cpp_leetcode\\cmake-build-debug\\cpp_leetcode.exe\" (in directory \"G:\\working_pan\\PROJECTS\\cpp_leetcode\\cmake-build-debug\"): CreateProcess error=5, 拒绝访问。 1、明明文件在 2、clion以管理员启动的 ------》关闭360！ 1.8. 激活码 Server address http://81.68.147.56:8163 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/command.html":{"url":"coding/Tool/command.html","title":"Command","keywords":"","body":"1. 命令1.1. cpp断点调试1.2. cmd(bat) 禁止使用1.2.1. 用户输入----set /p1.2.2. 定义变量set、字符串格式化1.2.3. 拼接字符串 %1.2.4. 使用bat批处理文件启动.exe程序1.2.5. pause 20s1.2.6. 休眠1.2.7. 文件夹操作1.2.8. 文件操作1.2.9. 获取系统时间，对字符串切片、拼接1.2.10. CMD执行命令行时卡住的问题（假卡）1.2.11. 已经编写好的脚本---复制源代码1.3. linux1.3.1. 文件夹操作1.3.2. 搜索1.3.3. sed 批量替换多个文件中的字符串1.3.4. 自动换源1.3.5. Ubutu 安装可视化界面 ，win10远程1.3.6. Linux 系统初始化 自动化执行脚本1.3.7. Linux 用户登录 自动化执行脚本1.3.8. 运行.sh1.3.9. 环境变量设置1.3.10. win下 全面以linux 命令替代 cmd命令1.4. shell 或 MobaXterm1.4.1. shell中交互输入自动化1.4.2. wins 下shell自动化执行脚本1.4.3. shell 调用bat1.4.4. Shell脚本之字符串操作1.5. flutter1.6. 正则1.6.1. github1.7. GDB命令1.7.1. 原理1.7.2. Tutorial1.7.3. 时机：1.7.4. 启动gdb1.7.5. 控制1.7.6. 变量操作1.7.7. 显示1.7.8. gdb调试异常1.8. jdb命令1.8.1. 用threads查询所有线程：1.8.2. 选择你感兴趣的线程1.8.3. 暂停线程1.8.4. 显示调用堆栈。1.8.5. 切换调用堆栈的frame:1.8.6. 设置断点1.9. 已经制作好的脚本 备份1.9.1. win下 myfun.sh1.9.2. linux下 .myfunction.sh1.9.3. 本地复制代码到远端1.9.4. 编译aosp相关命令的 封装2. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 命令 cpp断点调试 cmd(bat) 禁止使用 用户输入----set /p 定义变量set、字符串格式化 拼接字符串 % 使用bat批处理文件启动.exe程序 pause 20s 休眠 文件夹操作 文件操作 写东西到文件里 获取系统时间，对字符串切片、拼接 CMD执行命令行时卡住的问题（假卡） 已经编写好的脚本---复制源代码 linux 文件夹操作 搜索 搜索文本 搜索文件 sed 批量替换多个文件中的字符串 自动换源 Ubutu 安装可视化界面 ，win10远程 Linux 系统初始化 自动化执行脚本 正常linux启动 docker镜像下的linux Linux 用户登录 自动化执行脚本 自动执行 运行.sh 自定义函数，待使用 环境变量设置 win下 全面以linux 命令替代 cmd命令 shell 或 MobaXterm shell中交互输入自动化 wins 下shell自动化执行脚本 shell 调用bat Shell脚本之字符串操作 flutter 正则 github GDB命令 原理 Tutorial 时机： 启动gdb 控制 断点相关： 阻塞线程 变量操作 显示 gdb调试异常 jdb命令 用threads查询所有线程： 选择你感兴趣的线程 暂停线程 显示调用堆栈。 切换调用堆栈的frame: 设置断点 显示某个类的信息。 显示变量信息： 运行 查看源代码 查看当前加载的所有类 其他 已经制作好的脚本 备份 win下 myfun.sh linux下 .myfunction.sh 本地复制代码到远端 编译aosp相关命令的 封装 格式 [TOC] 1. 命令 1.1. cpp断点调试 ./adb -H 192.168.31.200 -P 9999 root user@aclgcl-ubnt:/data1/AJ9_3$ ./adb -H 192.168.31.200 -P 9999 forward tcp:5039 tcp:5039 user@aclgcl-ubnt:/data1/AJ9_3$ ./adb -H 192.168.31.200 -P 9999 shell ps -ef |grep systemui ./adb -H 192.168.31.200 -P 9999 shell gdbserver :5039 --attach 31249 或者 1|sailfish:/ # ps -ef |grep systemui root 1986 1700 0 01:42:08 pts/0 00:00:00 grep systemui u0_a88 31249 623 4 01:31:53 ? 00:00:24 com.android.systemui sailfish:/ # gdbserver :5039 --attach 31249 Attached; pid = 31249 Listening on port 5039 set solib-absolute-prefix /home/chen/workingSpace/aosp_android1000_r17/out/target/product/sailfish/symbols/ https://blog.csdn.net/wzy_0556/article/details/51911458 source build/envsetup.sh 和choosecombo命令： source build/envsetup.sh;choosecombo 否则汇报错：-bash: gdbclient: command not found gdbclient app_process32 :5039 ------>根目录下执行 gdbclient 782 ----->根目录下执行 ---》这个会执行gdbclient脚本 ------.. 因为adb的原因需要修改两处： （1）/home/chen/workingSpace/aosp_android1000_r17/development/scripts 下所有adb 修改为 adb -H 192.168.31.200 -P 9999 （PC的ip） （2）最后gdb会执行这一行，需要加上ip，才能连接上，或者删掉（手动：target remote 192.168.31.200:5039 ） (gdb) target remote 192.168.31.200:5039 ---》PC的ip https://blog.csdn.net/wangzaieee/article/details/83895089 init进程可以调试成功 ./adb -H 192.168.31.200 -P 9999 shell gdbserver64 :5039 ./init ----------》坑：这里一定要用64位的！！！ 重启了init进程，并且打印了pid 调试的流程： 35 mov x0, sp(gdb) b mainBreakpoint 1 at 0x5555578080: file system/core/init/main.cpp, line 56.(gdb) cContinuing.warning: Could not load shared library symbols for /system/bin/linker64.Do you need \"set solib-search-path\" or \"set sysroot\"?Breakpoint 1, main (argc=, argv=0x555557805c ) at system/core/init/main.cpp:5656 if (!strcmp(basename(argv[0]), \"ueventd\")) {(gdb) n60 if (argc > 1) {(gdb) n77 return FirstStageMain(argc, argv);(gdb) nProgram received signal SIGABRT, Aborted.abort () at bionic/libc/bionic/abort.cpp:4949 struct sigaction64 sa = { .sa_handler = SIG_DFL, .sa_flags = SA_RESTART };(gdb) nandroid::init::InstallRebootSignalHandlers()::$_14::__invoke(int) (signal=6) at system/core/init/reboot_utils.cpp:138138 action.sa_handler = [](int signal) {(gdb) n 命令： adb forward tcp:6100 tcp:7100 // PC上所有6100端口通信数据将被重定向到手机端7100端口server上 或者 adb forward tcp:6100 local:logd // PC上所有6100端口通信数据将被重定向到手机端UNIX类型socket上 ———————————————— 版权声明：本文为CSDN博主「东海陈光剑」的原创文章，遵循CC 4.0 BY-SA版权协议，转载请附上原文出处链接及本声明。 原文链接：https://blog.csdn.net/universsky2015/article/details/83593488 linux 环境变量设置（临时 + 永久） export adb='adb -H 192.168.31.200 -P 9999' 1.2. cmd(bat) 禁止使用 1.2.1. 用户输入----set /p echo hello world echo please enter y/n: set /p flag= ::echo %flag% if /i %flag% == y (echo “y”)^ else (echo “stop the procedure!”) 1.2.2. 定义变量set、字符串格式化 // copy.bat :: 需要输入的参数 set sourcePathRoot=I:\\dockerSharedFiles\\aosp_android1000_r17\\aosp_android1000_r17 set subPath=frameworks\\base\\core md %subPath% xcopy %sourcePathRoot%\\%subPath% %subPath% /s/y/h 1.2.3. 拼接字符串 % 见上 1.2.4. 使用bat批处理文件启动.exe程序 // myStart.bat echo \"this is myStart.bat\" start E:\\Snipaste-2.7.3-Beta-x64\\Snipaste.exe start E:\\AutoHotKey\\myAutoHotKey.ahk @ping -n 20 127.1>nul 2>nul 1.2.5. pause 20s ::pause 20s @ping -n 20 127.1>nul 2>nul 1.2.6. 休眠 rundll32 powrprof.dll,SetSuspendState 1.2.7. 文件夹操作 //删除文件夹 rd /s /q D:\\local\\braphic //创建文件夹 ------>极优，可以创建多层 md D:\\local\\braphic //拷贝（参数h表明包括隐藏文件） 注意：拷贝 bra下所有文件，不包括bra本身 xcopy Y:\\foundation\\bra D:\\local\\braphic\\bra /s/y/h pause 1.2.8. 文件操作 1、删除（优） del \"H:\\docker_install\\DockerDesktop\\DockerDesktop.vhdx\" 可以解决删除系统文件时报错： 复制： 写东西到文件里 例子1: del \"H:\\docker_install\\Dockerfile\\Dockerfile\" echo FROM %Image%>> H:\\docker_install\\Dockerfile\\Dockerfile echo ^RUN^ ^echo^ ^'hi, cg. this is a ubuntu16.04_aosp1000_r17 image, clion is ok'^ ^>^ /home/chengang/readme.txt>> H:\\docker_install\\Dockerfile\\Dockerfile 结果 注意：例子2: 结果： 1.2.9. 获取系统时间，对字符串切片、拼接 C:\\Users\\24234>date The current date is: 12/04/2022 Sun --->echo %date:~0,2% 从0位置开始，共四个 结果： 又一个Ex: C:\\Users\\24234>set date_time=\"%date:~6,4%%date:~0,2%%date:~3,2%%time:~0,2%%time:~3,2%\" C:\\Users\\24234>echo %date_time% \"202212041702\" C:\\Users\\24234> 1.2.10. CMD执行命令行时卡住的问题（假卡） https://blog.csdn.net/qq_34254642/article/details/104641591 Windows下命令行窗口默认开启了“快速编辑模式”，在执行命令的时候我们会不小心在窗口上点一下导致出现一个白色的光标，因为开启了“快速编辑模式”所以只要当鼠标点击Cmd窗口任何区域就会自动进入编辑模式，然后程序向控制台输入内容甚至执行程序都会被阻塞住，导致看到了命令执行停止的现象 1.2.11. 已经编写好的脚本---复制源代码 有时候，需要把源码从 // copy.bat :: 需要输入的参数 set sourcePathRoot=I:\\dockerSharedFiles\\aosp_android1000_r17\\aosp_android1000_r17 set subPath=frameworks\\base\\core md %subPath% xcopy %sourcePathRoot%\\%subPath% %subPath% /s/y/h 1.3. linux 1.3.1. 文件夹操作 删除文件夹 rm -rf ........ 递归创建文件夹-p mkdir -p files1/files2 拷贝： //拷贝文件夹A下所有文件 到 文件夹B下 cp -r /home/packageA/* /home/cp/packageB/ 或 cp -r /home/packageA/. /home/cp/packageB/ //拷贝文件夹A 到 文件夹B ----> packageB文件夹下就有packageA文件夹 cp -r /home/packageA /home/packageB --------> 简言之：下 即 / 查看文件夹大小（在当前文件夹下） du -sh 1.3.2. 搜索 关于搜索文件、搜索文本内容， 规定： -禁止在window下搜索文件、 -禁止在IDE中搜索文本（IDE 本身可能File不全、很多File里的文本搜不到） ---------> win也必须执行linux命令 规定： linux的搜索，优很高的精确性 -----> 可以用来判定有无 搜索文本 范围：view.java文件 grep “baidu” -nr view.java 文件范围：路径下所有文件 grep “baidu*” -nr ./ 显示范围： grep -C 5 ........ 显示上下5行 grep -B 5 ........ 显示前5行 grep -A 5 ........ 显示后5行 搜索文件 find ./ -name \"View*\" 1.3.3. sed 批量替换多个文件中的字符串 原文： https://www.runoob.com/w3cnote/linux-findtoreplace.html 语法格式 sed -i \"s/原字符串/新字符串/g\" `grep 原字符串 -rl 所在目录` 例子： 在当前目录下查找包含 baidu 的字符串，并将字符串 baidu 替换为 runoob sed -i \"s/baidu/runoob/g\" `grep \"baidu\" -rl ./` 批量替换网址 libs.baidu.com 为 cdn.static.runoob.com： sed -i \"s/https:\\/\\/libs.baidu.com/https:\\/\\/cdn.static.runoob.com\\/libs/g\" `grep -rl \"libs.baidu.com\" ./` 1.3.4. 自动换源 https://cloud.tencent.com/developer/article/1880981 1.3.5. Ubutu 安装可视化界面 ，win10远程 1、步骤 https://blog.csdn.net/qq_15211883/article/details/105314929 windows 远程 ubuntu 桌面,遇到花屏问题的解决方法 https://blog.csdn.net/badboy_1990/article/details/121412618 Ubuntu Server 20.04安装桌面(图形界面)以及远程桌面 2、远程连接 或直接用window的远程桌面登录:输入ip 用户名,密码 注意点：安装xfce4 TODO: 当docker宿主在window上，这样连不上 1.3.6. Linux 系统初始化 自动化执行脚本 注：以下都是 系统初始化 级别的，不是用户登录级别的（只有一个系统初始化，但是可以有很多个 用户登录） 参考： https://blog.csdn.net/weixin_43772810/article/details/126760777 Ubuntu 20.04 设置开机自启脚本 正常linux启动 使用 systemctl： https://blog.csdn.net/ny19000314/article/details/128833491?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-128833491-blog-127485170.235%5Ev36%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-128833491-blog-127485170.235%5Ev36%5Epc_relevant_default_base3&utm_relevant_index=6 docker镜像下的linux 参考： https://www.jianshu.com/p/ba9860bec1d4 https://blog.csdn.net/qq_42926722/article/details/127052028 Docker容器进入的4种方式 无法使用systemctl，只能通过docker exec： docker run --detach ............. docker exec test_my /bin/bash /home/cjk/start.sh .......... //start.sh封装你想要 开机执行的一切操作 一个注意点： --detach https://blog.csdn.net/F7ANTY/article/details/112384645 docker run --detach 正常情况下，run之后直接attach，进入容器了（run之后的脚本没法执行）: --detach使得不进入容器 没有detach时，会attach： 1.3.7. Linux 用户登录 自动化执行脚本 注：以下都是 用户登录 级别的，即: 新增一个用户登录，执行一次 自动执行 先科普下 Linux 系统的四（六）个类似却又不同的文件： /etc/profile：系统配置文件，用户登录时读取一次 /etc/bash.bashrc：系统配置文件 ，用户登录时读取一次，每次打开一个新终端会话时读取一次 ~/.profile（~/.bash_profile、~/.bash_login）：用户配置文件，用户登录时读取一次 ~/.bashrc：用户配置文件，用户登录时读取一次，每次打开一个新终端会话时读取一次 注意： 系统配置文件作用于全局，而用户配置文件仅针对当前登录的用户 先读取系统配置文件，再读取用户配置文件，用户配置文件的变量和表达式等都继承自系统配置文件 我是 Ubuntu OS，如果你是 Red Hat OS，请将 /etc/bash.bashrc 改成 /etc/bashrc Ubuntu 本身没有 ~/.bash_profile，需要你自己创建同名文件，它只对 bash 有效，而 ~/.profile 作用于任何绑定的 shell 终端 对于 ~/.bash_profile、~/.bash_login、~/.profile，如果终端绑定的是 bash，则按照我书写的顺序进行读取（如果存在，就不继续读取） - 出于个性化和最小干预原则考虑，通常我们只对 ~/ 目录下的终端配置文件进行读写操作，也就是 ~/.profile 每次登录只读取一次 ~/.bashrc 除了登录时读取，每次打开终端，执行 shell script 时都会读取一次 -----> 一句话总结：优先用~/.profile 和 ~/.bashrc 参考： https://blog.csdn.net/Jessie_Lian/article/details/107917658?spm=1001.2101.3001.6650.2&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-107917658-blog-115304472.pc_relevant_recovery_v2&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-2-107917658-blog-115304472.pc_relevant_recovery_v2&utm_relevant_index=5 Linux开机自动化执行脚本的四种方法（真实案例分享） 1.3.8. 运行.sh 标准： sh hello.sh TODO: 如何双击执行呢？ 自定义函数，待使用 source + .sh 例子： 见 TODO: 自定義的function，如何自动补全？ 1.3.9. 环境变量设置 1、设置export export ALL_PROXY='socks5://172.20.224.1:15901' 2、查看当前环境变量env （自然） 3、删除 unset unset ALL_PROXY 1.3.10. win下 全面以linux 命令替代 cmd命令 利用mobaXterm中bash，可以找到win所有路径 ----> 所以，都可以替代 关键问题： //Windows路径----> Linux的路径 转化： function my_win2linux_path { # usage: my_win2linux_path \"C:\\Users\\asus\\Anaconda3\" win_path=$1 # 脚本的第一个参数就是windows路径 #win_path=\"C:\\Users\\asus\\Anaconda3\" # 一个示例路径 tmp_path=${win_path/:/} # 将冒号删掉 tmp_path=${tmp_path//\\\\/\\/} # 将\\\\替换为/ disk_id=${tmp_path:0:1} # 取出第一个字母，也就是C盘的C，冒号后面第一个0指的是从下标为0的地方开始提取，第二个冒号后面的1表示提取一个字母 disk_id=$(echo $disk_id | tr [:upper:] [:lower:]) # 大写转小写 #echo $disk_id other_path=${tmp_path:1} # 路径中除了磁盘以外的部分 linux_path=\"/drives/\"${disk_id}${other_path} # 需要将/mnt/接在路径最前方 echo \"windows path is \"${win_path} echo \"linux path is \"${linux_path} } 1.4. shell 或 MobaXterm 1.4.1. shell中交互输入自动化 // .sh #! /bin/bash read -p \"enter number:\" no read -p \"enter name:\" name echo you have entered $no, $name 1.4.2. wins 下shell自动化执行脚本 执行顺序： 1.4.3. shell 调用bat 注意：bat文件放在sh可以找到的目录下 1.4.4. Shell脚本之字符串操作 https://blog.csdn.net/xinfeismile123/article/details/119355401 1.5. flutter 1、trace：https://www.bilibili.com/video/av48772383 2、 1.6. 正则 匹配行: https://blog.csdn.net/billll/article/details/88370333 包含指定单词的行: 包含 单词1或单词2或 单词3 的行: 不包含指定单词 的行： 包含一组单词，并且不包含另一组: 1.6.1. github Get started by creating a new file or uploading an existing file. We recommend every repository include a README, LICENSE, and .gitignore. …or create a new repository on the command line echo \"# AospbaseForSelfish\" >> README.md git init git add README.md git commit -m \"first commit\" git branch -M main git remote add origin git@github.com:KentTJ/AospbaseForSelfish.git git push -u origin main …or push an existing repository from the command line git remote add origin git@github.com:KentTJ/AospbaseForSelfish.git git branch -M main git push -u origin main …or import code from another repository You can initialize this repository with code from a Subversion, Mercurial, or TFS project. Import code 1.7. GDB命令 1.7.1. 原理 比较完整的参考： https://blog.csdn.net/Ananas_Orangey/article/details/126219940的 ​ linux（win）： 手机： 1.7.2. Tutorial https://www.sourceware.org/gdb/ https://sourceware.org/gdb/current/onlinedocs/gdb/ GDB manual 1.7.3. 时机： 何时用gdb？何时用log？何时用调用栈？ 1.7.4. 启动gdb gdb main.exe main.exe为debug版本 1.7.5. 控制 启动 r（run） start 开始执行程序，停在main函数第一行语句前面等待命令 跳入函数 s 或 step 跳出函数finish ------>没有简写 下一行 n 或next 退出 q quit 执行上一条命令：Enter键 跳转执行 https://blog.csdn.net/yasi_xi/article/details/12784507 断点相关： 函数打断点： b 函数名 例： b android::MediaPlayerService::Client::start 某一行打断点： b 源文件:行号 例如： b c_gdb.c:9 断点某一线程： b android::Looper::wake thread 12 条件断点： break 断点 if 条件 continue 断点编号(执行一次表示设定，再次执行表示取消) continue 断点编号 条件 查看断点：i b 或 info b 或 info breakpoint 或 info break 删除断点：d 断点号 或 delete 断点号 d 或 delete(删除所有断点) 禁用/开启断点：disable/enable breakpoint ignore： https://blog.csdn.net/weixin_33904522/article/details/112594152 赋值： print n =1 强制调用函数：call 表达式 或 print https://blog.csdn.net/yasi_xi/article/details/12784507 阻塞线程 阻塞其他线程，仅调试当前线程工作： set scheduler-locking [on|off|step] 运行指定线程并允许其他线程并行执行： thread apply N command 1.7.6. 变量操作 ​ 设置变量：set var n=47 1.7.7. 显示 p（print） 变量名 打印指定变量的值 l（list） 列出源代码，接着上次的位置往下列，每次列10行 l 200 (list 行号） 列出从第几行开始的源代码 android::MediaPlayerService::Client::start list 函数名 列出某个函数的源代码 查看局部变量： (gdb) info locals i = 0 sum = 0 查看调用帧（栈） (gdb) bt backstrace #0 digui (n=9) at c_gdb.c:14 #1 0x000055bc7ca566a4 in digui (n=10) at c_gdb.c:19 #2 0x000055bc7ca56663 in main () at c_gdb.c:8 在不同frame之间切换：frame 2 ----》来查看变量值 查看当前调试的进程：info inferiors 查看线程：info threads 查看线程堆栈 查看所有线程堆栈：thread apply all bt 查看指定线程堆栈：thread apply thread1 thread2... bt 大全： https://blog.csdn.net/weixin_33904522/article/details/112594152 显示共享库： (gdb) info sharedlibrary 1.7.8. gdb调试异常 ----》适用于，程序直接挂了 https://www.cnblogs.com/catmelo/p/7207062.html 使用gdb捕获异常的扔出点（相当于在扔出异常的地方添加断点）： catch throw 使用gdb捕获线程退出（相当于在线程退出的时候添加断点）： catch pthread_exit 这样，如果相应的事件发生，gdb就会中断程序的执行， 就可以使用gdb的bt命令来检查出现错误的调用栈了。 强制函数返回 return return disassemble 反汇编指令 调试函数 https://blog.csdn.net/weixin_33904522/article/details/112594152 1.8. jdb命令 1.8.1. 用threads查询所有线程： 命令： threads 1.8.2. 选择你感兴趣的线程 命令： thread 0xc1436dd9d0 1.8.3. 暂停线程 命令： suspend 0xc1436dd9d0 1.8.4. 显示调用堆栈。 命令： wherei 结果显示示例： [1] java.lang.Object.wait (本机方法) [2] java.lang.Object.wait (Object.java：288), pc = 3 [3] android.os.MessageQueue.next (MessageQueue.java：148), pc = 153 [4] android.os.Looper.loop (Looper.java：110), pc = 8 [5] android.os.HandlerThread.run (HandlerThread.java：60), pc = 28 1.8.5. 切换调用堆栈的frame: 命令： up [n 帧] – 向上移动线程的堆栈 down [n 帧] – 向下移动线程的堆栈 1.8.6. 设置断点 命令： stop at : 或 stop in .[(参数类型,.. 结果显示示例： stop at com.example.BarrierFree_demo.MainActivity:85 设置断点com.example.BarrierFree_demo.MainActivity:85 含内部类时： stop at com.android.phone.SimContacts$ImportAllThread:124 设置 断点 com.android.phone.SimContacts$ImportAllThread:124 显示某个类的信息。 有时要在嵌套类里设置断点，这个命令可能有帮助。 命令： class – 显示已命名的类的详细信息 结果显示示例： >class com.android.phone.SimContacts 类：com.android.phone.SimContacts 扩展： com.android.phone.ADNList 嵌套： com.android.phone.SimContacts$ImportAllThread 显示变量信息： 查看局部变量，输入locals。 # 打印变量 print `基本类型` dump `对象` 运行 命令： step – 进入方法 step up – 执行到当前方法返回到其调用程序 stepi – 执行当前指令 next – step over执行某一行 cont – 从断点处继续执行 9.清除断点 命令： clear .[(参数类型,...)] – 清除方法中的断点 clear : – 清除行中的断点 clear – 列出断点 查看源代码 命令： list [line number|method] – 输出源代码 11.jdbshell命令缩写 command alias: c — cont l — list n — next r — run s — step si — stepi f — step up bt — wherei 查看当前加载的所有类 classes 其他 成功attach后，help一下，可以看到断点如何下等命令，注意class id 包括类的包名的！ 1 luogw@luogw-MacBook-Pro temp$ jdb -attach 127.0.0.1:7703 设置未捕获的java.lang.Throwable 设置延迟的未捕获的java.lang.Throwable 正在初始化jdb... help 命令列表 connectors -- 列出此 VM 中可用的连接器和传输 run [class [args]] -- 开始执行应用程序的主类 threads [threadgroup] -- 列出线程 thread -- 设置默认线程 suspend [thread id(s)] -- 挂起线程 (默认值: all) resume [thread id(s)] -- 恢复线程 (默认值: all) where [ | all] -- 转储线程的堆栈 wherei [ | all]-- 转储线程的堆栈, 以及 pc 信息 up [n frames] -- 上移线程的堆栈 down [n frames] -- 下移线程的堆栈 kill -- 终止具有给定的异常错误对象的线程 interrupt -- 中断线程 print -- 输出表达式的值 dump -- 输出所有对象信息 eval -- 对表达式求值 (与 print 相同) set = -- 向字段/变量/数组元素分配新值 locals -- 输出当前堆栈帧中的所有本地变量 classes -- 列出当前已知的类 class -- 显示已命名类的详细资料 methods -- 列出类的方法 fields -- 列出类的字段 threadgroups -- 列出线程组 threadgroup -- 设置当前线程组 stop in .[(argument_type,...)] -- 在方法中设置断点 stop at : -- 在行中设置断点 clear .[(argument_type,...)] -- 清除方法中的断点 clear : -- 清除行中的断点 clear -- 列出断点 catch [uncaught|caught|all] | -- 出现指定的异常错误时中断 ignore [uncaught|caught|all] | -- 对于指定的异常错误, 取消 'catch' watch [access|all] . -- 监视对字段的访问/修改 unwatch [access|all] . -- 停止监视对字段的访问/修改 trace [go] methods [thread] -- 跟踪方法进入和退出。 -- 除非指定 'go', 否则挂起所有线程 trace [go] method exit | exits [thread] -- 跟踪当前方法的退出, 或者所有方法的退出 -- 除非指定 'go', 否则挂起所有线程 untrace [methods] -- 停止跟踪方法进入和/或退出 step -- 执行当前行 step up -- 一直执行, 直到当前方法返回到其调用方 stepi -- 执行当前指令 下一步 -- 步进一行 (步过调用) cont -- 从断点处继续执行 list [line number|method] -- 输出源代码 use (或 sourcepath) [source file path] -- 显示或更改源路径 exclude [, ... | \"none\"] -- 对于指定的类, 不报告步骤或方法事件 classpath -- 从目标 VM 输出类路径信息 monitor -- 每次程序停止时执行命令 monitor -- 列出监视器 unmonitor -- 删除监视器 read -- 读取并执行命令文件 lock -- 输出对象的锁信息 threadlocks [thread id] -- 输出线程的锁信息 pop -- 通过当前帧出栈, 且包含当前帧 reenter -- 与 pop 相同, 但重新进入当前帧 redefine -- 重新定义类的代码 disablegc -- 禁止对象的垃圾收集 enablegc -- 允许对象的垃圾收集 !! -- 重复执行最后一个命令 -- 将命令重复执行 n 次 help (或 ?) -- 列出命令 version -- 输出版本信息 exit (或 quit) -- 退出调试器 : 带有程序包限定符的完整类名 : 带有前导或尾随通配符 ('*') 的类名 : 'threads' 命令中报告的线程编号 : Java(TM) 编程语言表达式。 支持大多数常见语法。 可以将启动命令置于 \"jdb.ini\" 或 \".jdbrc\" 中 位于 user.home 或 user.dir 中 1.9. 已经制作好的脚本 备份 1.9.1. win下 myfun.sh 展开 #! /bin/bash echo \"cg, this is \\MobaXterm\\slash\\etc\\myfun.sh which is sourced by profile!!!\" function my_he { echo \"=========================adb==============================\" echo \"adb shell logcat -b events | findstr \"am_ wm_\" \" echo \"adb shell input keyevent KEYCODE_POWER \" echo \"startDocker.bat\" echo \"my_start; my_sleep_pc; my_restart_pc\" echo \"my_pause\" echo \"my_unpause\" echo \"docker_build_save_load.bat\" echo \"docker images -a\" echo \"docker rmi ee7cbd482336\" echo \"docker ps -l\" echo \"docker pause 2619ca372120\" echo \"docker commit 7a0d4b22ae06 chengang/ubuntu16.04_aosp1000_r17:vnc_ok\" echo \"docker load -i F:\\VirtualMachine\\Docker\\ubuntu.tar\" echo \"docker save chengang/ubuntu16.04_aosp1000_r17:vnc_ok -o H:\\docker_jarFiles\\ubuntu16.04_aosp1000_r17_vnc_20221026.jar\" echo \"docker build --squash -t chengang/ubuntu16.04_aosp1000_r17:as_ok2 .\" echo \"\" } function my_start { ./myStart.bat echo \"\" } function my_sleep_pc { rundll32.exe powrprof.dll,SetSuspendState 0,1,0 echo \"\" } function my_restart_pc { { docker pause my_container && \\ docker stop $(docker ps -a -q) && \\ #全关 echo \"docker 关闭成功\" } || { echo \"docker 关闭失败\" } sleep 4 shutdown -r now #立刻重启 echo \"\" } function my_pause { docker pause my_container } function my_unpause { docker unpause my_container } function my_adb_win { cp /drives/d/Users/Administrator/AppData/Local/Android/Sdk/adb.exe /drives/d/Users/Administrator/AppData/Local/Android/Sdk/platform-tools/adb.exe } function my_adb_linux { rm -rf /drives/d/Users/Administrator/AppData/Local/Android/Sdk/platform-tools/adb.exe } function my_win2linuxPath { # usage: my_win2linux_path \"C:\\Users\\asus\\Anaconda3\" win_path=$1 # 脚本的第一个参数就是windows路径 #win_path=\"C:\\Users\\asus\\Anaconda3\" # 一个示例路径 tmp_path=${win_path/:/} # 将冒号删掉 tmp_path=${tmp_path//\\\\/\\/} # 将\\\\替换为/ disk_id=${tmp_path:0:1} # 取出第一个字母，也就是C盘的C，冒号后面第一个0指的是从下标为0的地方开始提取，第二个冒号后面的1表示提取一个字母 disk_id=$(echo $disk_id | tr [:upper:] [:lower:]) # 大写转小写 #echo $disk_id other_path=${tmp_path:1} # 路径中除了磁盘以外的部分 linux_path=\"/drives/\"${disk_id}${other_path} # 需要将/mnt/接在路径最前方 echo \"windows path is \"${win_path} echo \"linux path is \"${linux_path} } function my_linux2winPath { #当前linux路径转win #比如：\"./my_Command\" curr_path=$(pwd) Input_path=$1 # echo $Input_path cd $Input_path explorer.exe . #核心：通过explorer.exe 转换linux路径到win cd $curr_path } function my_sourceMappath { # usage: my_win2linux_path \"C:\\Users\\asus\\Anaconda3\" win_path=$1 # 脚本的第一个参数就是windows路径 #win_path=\"C:\\Users\\asus\\Anaconda3\" # 一个示例路径 echo $win_path python myOpenWinPath.py $win_path #python myOpenWinPath.py \"I:\\working_pan\\Demo\\AOSPsourceCode2_win\\sourceroot\\packages\\apps\\Launcher3\\iconloaderlib\\src\\com\\android\\launcher3\\icons\\BaseIconFactory.java\" } 被引用的 myStart.bat： echo \"this is C:\\Users\\24234\\Documents\\MobaXterm\\slash\\etc\\myStart.bat\" start E:\\Snipaste-2.7.3-Beta-x64\\Snipaste.exe start D:\\ddns-go_5.2.0_windows_x86_64\\ddns-go.exe start E:\\AutoHotKey\\myAutoHotKey.ahk ::启动另一个窗口； linux 连手机需要，adb start \"tom\" cmd /c \"timeout /t 2 && adbkit usb-device-to-tcp -p 7788 FA6930305260 \" ::\"E:\\Program Files\\TurboVNC\\vncviewerw.bat\" ::@ping -n 20 127.1>nul 2>nul 被引用的 myOpenWinPath.py： //myOpenWinPath.py #!/usr/bin/python # -*- coding: UTF-8 -*- import os import sys IDE_path = sys.argv[1] #映射map，需要维护 IDERoots=[r'I:\\working_pan\\Demo\\AOSPsourceCode2_win\\sourceroot'] remoteRoots=[r'I:\\dockerSharedFiles\\aosp_android1000_r17\\aosp_android1000_r17'] #IDE_path=r\"I:\\working_pan\\Demo\\AOSPsourceCode2_win\\sourceroot\\packages\\apps\\Launcher3\\iconloaderlib\\src\\com\\android\\launcher3\\icons\\BaseIconFactory.java\" def windows_to_linux(windowsPath): windowsPathTemp = windowsPath.split(':')[1] # /Code/Shell/test.txt diskDrive = windowsPath.split(':')[0] # e diskDrive = '/' + diskDrive # /e linuxPath = diskDrive + windowsPathTemp # /e/Code/Shell/test.txt print(linuxPath) for i in range(0, len(IDERoots)): if (IDE_path.find(IDERoots[i])) == 0: relativePath = IDE_path.split(IDERoots[i])[1] print(IDE_path.split(IDERoots[i])) print(\"relativePath:\" + relativePath) remotePath = remoteRoots[i] + relativePath print(\"remotePath: \" + remotePath) # 利用explorer.exe执行 os.system(\"explorer.exe %s\" % remotePath) else: continue 传参路径：shell ---> 命令my_linux2winPath ---> python 1.9.2. linux下 .myfunction.sh # .myfunction.sh #!/bin/bash echo -e \"hello,cg! this is myfunction.sh\" echo -e \"please enter： my_reStartVnc\" #为了linux能链接到手机 adb connect host.docker.internal:7788 && adb connect host.docker.internal:7788 echo -e \"It has been executed: adb connect host.docker.internal:7788\" function my_reStartVnc { vncserver -kill :1 vncserver -kill :2 vncserver -kill :3 rm -rf /tmp/.X1-lock vncserver :1 -localhost no -geometry=1920x1080 } function my_he { echo -e \"=============linux relative:======================== \\n\" echo -e \"vim ~/.myfunction.sh\" echo -e \"my_reStartVnc\" echo -e \"refresh linux sources: . ~/workingSpace/env-config/linux/ubuntu/sources/change-sources.sh\" echo -e \"Ubuntu version: cat /etc/issue\" echo -e \"grep \"baidu\" -rl ./\" echo -e \"kill process： ps -ef | grep android && kill -9 19703 \" echo -e \"=============adb relative:======================== \\n\" echo -e \"win: adbkit usb-device-to-tcp -p 7788 FA6930305260 ------> 与是否有手机无关\" echo -e \"linux: adb connect host.docker.internal:7788 ------> 与是否有手机无关，已经添加my_start\" echo -e \"=============aosp relative:======================== \\n\" echo -e \"source build/envsetup.sh && lunch aosp_sailfish-userdebug\" echo -e \"=============gdb relative:======================== \\n\" echo -e \"search PID: adb shell ps -ef | grep mediaserver\" echo -e \"Method1: gdbclient.py -p PID\" echo -e \"Method2: adb forward tcp:1235 tcp:1235 && adb shell gdbserver :1235 --attach pid\" echo -e \"breakpoint: (gdb) b android::MediaPlayerService::Client::start\" echo -e \"breakpoint: (gdb) b frameworks/av/media/libmediaplayerservice/MediaPlayerService.cpp:1072\" } 1.9.3. 本地复制代码到远端 展开 #copyLocal2remote.py #!/usr/bin/python # -*- coding: UTF-8 -*- import os import shutil # 需要copy的文件，需要维护 IDEFilepaths = [ r\"I:\\working_pan\\Demo\\MyHandlerDemo\\app\\src\\main\\java\\com\\example\\myhandlerdemo\\MainActivity.java\", ] # 映射map，需要维护 IDERoot = r'I:\\working_pan\\Demo\\MyHandlerDemo\\app\\src\\main' remoteRoot = r'C:\\Users\\24234\\Desktop\\Newfolder' def cp_winFiles_to_linux(): for i in range(0, len(IDEFilepaths)): relativePath = IDEFilepaths[i].split(IDERoot)[1] print(\"relativePath:\" + relativePath) remotePath = remoteRoot + relativePath print(\"remotePath: \" + remotePath) # cmd = \"xcopy %s %s /s/y/h \" % (IDEFilepaths[i], remotePath) # os.system(cmd) shutil.copy(IDEFilepaths[i],remotePath) if __name__ == '__main__': cp_winFiles_to_linux() 1.9.4. 编译aosp相关命令的 封装 技巧： 所有的cd ，可以用 my_root= ./ 替换（用root路径定位其他路径） 不要cd到其他路径去执行 function my_rm { cp -r $master_root/out/release/java/graphic/* $master_root/interface/java/graphic/; cp -r $master_root/out/release/graphic/* $master_root/interface/sdk/graphic/; } function reposync { ~/bin/repo forall -c 'git clean -d -fx; git clean -df; git add .;git ~/bin/repo forall -c 'git clean -d -fx;git clean -df; git add ;git stash; git stash clear' ~/bin/repo forall -c 'git reset HEAD --hard' repo sync -c } 2. 格式 忽略： 隐藏 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/debugSkills.html":{"url":"coding/Tool/debugSkills.html","title":"Debug Skills","keywords":"","body":"1. 技巧，工具层面：1.1. 断点调试技巧：1.1.1. 暂停等待attach1.1.2. 多线程1.1.3. 改写值之----Evaluate（或watchs）1.1.4. 改写值之----Evaluate and log1.1.5. 改写值之 反射1.1.6. 断点日志： 动态地 改写值、添加log （调用栈）1.1.7. 异常断点1.1.8. 方法断点1.1.9. 字段断点和方法断点1.1.10. 断点调试时，关闭ANR1.1.11. 过滤之 condition1.1.12. 过滤之watch1.1.13. 杀进程1.1.14. 改app代码，而非framework源码1.1.15. debug的遗憾1.1.16. 注意事项：1.2. IDEA DEBUG技巧整理1.3. AS断点调试 Build.gradle的详细配置1.4. 用源码搭建java断点调试环境----法一1.4.1. 新建一个空的工程1.4.2. 根目录下新建与app同级的module1.4.3. 删掉src、libs1.4.4. 为base下代码设置为source1.4.5. 同步，保证环境1.4.6. 最重要一点：1.4.7. 最重要第二点：1.4.8. 不允许添加两个module1.4.9. 关于aidl的调试（万能调试）：1.4.10. 移除module1.4.11. 技巧：1.5. 用源码搭建java断点调试环境----法二，有问题1.6. 用源码搭建java断点调试环境----法三，有问题1.7. framework java 断点调试 环境（jdb）1.7.1. 总结：1.7.2. 环境1.8. framework Native 断点调试 环境（GDB）1.8.1. 最终目标：1.8.2. gdbclient.py方法步骤1.8.3. 通用GDB方法的步骤（TODO:验证补充）1.8.4. 注意：1.8.5. 参考1.8.6. 待整理1.9. framework Native Clion 调试环境（linux下）1.9.1. clion配置1.9.2. clion端开始debug1.9.3. 技巧：1.9.4. 参考1.10. 断点调试环境 lib64 、lib 区分1.10.1. 解决办法：1.10.2. 以上所有判断 环境OK不OK的办法1.11. framework Native Clion 跳转环境（linux下）1.11.1. 基本原理1.11.2. 具体步驟：1.11.3. 一些问题：1.11.4. 参考：1.12. 搜索能力：1.12.1. 搜索技巧之搜索同类1.12.2. aosp本地代码 全量搜索1.12.3. 对知识点的搜索途径1.13. 断点环境问题1.14. debug环境规定：2. LOG2.1. system log2.1.1. ProtoLog动态log2.2. EventLog2.2.1. 参考2.3. kernel Log 驱动相关的log2.4. log环境规定3. log、debug适用的场景4. 如何定位bug？ 思路层面4.1. 定位bug总体原则4.2. 显示问题定位4.3. 闪屏问题定位：4.4. 缺少应用代码的情况下的定位TreeviewCopyright © aleen42 all right reserved, powered by aleen42 断点调试技巧： 暂停等待attach 多线程 改写值之----Evaluate（或watchs） 改写值之----Evaluate and log 改写值之 反射 应用一：修改debug开关 ---》修改后，脱离断点调试 调用方法 技巧： .java反射 补充：实例化Class类对象的三种方式 断点日志： 动态地 改写值、添加log （调用栈） 断点日志，最优实践 Evaluate and log之 写代码 异常断点 方法断点 字段断点和方法断点 断点调试时，关闭ANR 过滤之 condition 过滤之watch 杀进程 利用断点调试杀进程 利用命令行杀进程 改app代码，而非framework源码 debug的遗憾 注意事项： IDEA DEBUG技巧整理 AS断点调试 Build.gradle的详细配置 用源码搭建java断点调试环境----法一 新建一个空的工程 根目录下新建与app同级的module 删掉src、libs 为base下代码设置为source 同步，保证环境 最重要一点： 最重要第二点： 不允许添加两个module 关于aidl的调试（万能调试）： 方法一：万能的classes.jar 方法二： 移除module 技巧： 同时调试 应用+ framework代码： iml本质 同包的两个类不能引用导致飘红 用源码搭建java断点调试环境----法二，有问题 用源码搭建java断点调试环境----法三，有问题 framework java 断点调试 环境（jdb） 总结： 环境 附：可能的报错 framework Native 断点调试 环境（GDB） 最终目标： gdbclient.py方法步骤 步骤1：docker容器（linux）与手机如何adb 链接？ 步骤2：aosp初始化环境 步骤3：gdbserver 与 gdbclient 链接 步骤4：GDB操作 通用GDB方法的步骤（TODO:验证补充） 注意： 参考 待整理 framework Native Clion 调试环境（linux下） clion配置 clion端开始debug 技巧： 参考 断点调试环境 lib64 、lib 区分 解决办法： 方法一（天然ok）： 方法二： 方法三：强制APK底层调用bit32库（优） 以上所有判断 环境OK不OK的办法 framework Native Clion 跳转环境（linux下） 基本原理 具体步驟： 一些问题： 参考： 搜索能力： 搜索技巧之搜索同类 aosp本地代码 全量搜索 对知识点的搜索途径 断点环境问题 debug环境规定： LOG system log ProtoLog动态log EventLog 参考 kernel Log 驱动相关的log log环境规定 log、debug适用的场景 如何定位bug？ 思路层面 定位bug总体原则 显示问题定位 闪屏问题定位： 缺少应用代码的情况下的定位 1. 技巧，工具层面： 1.1. 断点调试技巧： 1、可以复制调用栈！！！---->调用流程 2、 sdk或lib或dependency的jar文件，可以断点！ 3、基于2，可以做很多事情： 1）huawei改动了Google源码，导致真机与安卓sdk行数不一致 >方法： 复制源码，直接到.class文件里 注意：必须重新编译一次，不能破坏环境！！！！！ 2）对应Z代码，如何用AS调试？？？？同样道理， 编译Z的jar，添加到dependency里就OK了（也可以直接copy源码） 编好的jar，也可添加到SDK的source里！！！！！？？？ 更优秀 ​ 3） 极其优 利用云帆的方法， 将其他盘的java文件，通过gradle引入成source， 既然成source就会纳入调试的代码？？？？？？。而且在其他盘改动代码，自动同步过来！！！！ ​ 4）源码，copy到sdk的source目录下？？？（或者copy到工程目录下？？？） 4、如何配合log？？？各适合哪些场景？？？？ 5、回退：回到上一个函数状态（当然已经改变的值是不会恢复的） 6、条件断点 对于循环和有if的语句超级实用！！！ 1.1.1. 暂停等待attach 方法一： 手点击启动应用，但代码中加wait Debug.waitForDebugger() ===》暂停等待attach -------> 代码背后原理： 会让手机进程保持阻塞状态,直到连上调试器后,才会继续执行后续的代码 场景举例: ​ AS debug，无法对onCreate方法进行调试è点开，就执行完了 仍然存在的问题： 因为attach时必须绑定app进程名（包名），所以必须在Activity new之后，在APP应用侧代码容易添加waitForDebugger （如果想看activity起来之前加断点呢呢？？） 方法一：framework里添加Debug.waitForDebugger();---->编译framework 方法二；framework里添加log 方法三：在app起来后，销毁重建activty------>横竖屏切换 进入acitivy，1，wait 2 横竖屏切换。这个有个很大优点:可以解决activity之前的 方法四：（极优） 以debug模式启动应用，命令adb shell am start –D –n 包名/类名（包名和类名可以在反编译出的AndroidManifest.xml中找到，不详细介绍） 注： -D 是debug adb shell am start -D -n com.example.BarrierFree_demo/.MainActivity ------->可以做很多事情： 补充： 1、这个命令的等待点，实际上是launchActivity，此时应用已经起来了---> 所以，launchActivity之前的流程断点不上？ 2、没有-D，就是普通起一个MainActivity 方法三： 以debug模式启动应用，AS中Debug图标启动，是可以暂停的 1.1.2. 多线程 多进程之间切换调试 1、在代码中加断点(此时可能不知道是哪个线程会走这个代码) 2、打开app，启动主线程 多个线程设置debugger Intellij IDEA 的debug断点调试是有一个模式的选择的，就像下面这张图，平时我们都使用的是默认的 ALL（在Eclipse中默认是线程模式） ，这种模式我们只能将一个线程断下来，但其他线程却已经执行过了；而将其改为 Thread 后，就可以多个线程都断下来，并且可以很方便的切换线程的执行流程，这就是多线程调试。 在debug控制台能够很方便的查看线程的执行状态，也可以很方便的选择某个线程去执行： 1.1.3. 改写值之----Evaluate（或watchs） ----->极优！！！获取运行时信息 + 强制改变运行态的代码 Watchs中不仅可以观看值，也可以执行代码修改值，可以执行任意代码！！！！！！！！！ 同样的，Evaluate（更推荐！！！！！ 优点：只会执行一次） https://blog.csdn.net/Peng_Hong_fu/article/details/79994860 这个技巧非常有用，可以强制改变运行态的代码，场景： （1）用来阅读代码，要理解某个量的影响---->制造冲突：修改某个量，观察变化，从而理解代码 （2）用来写代码：当代码量比较小的时候，完全可以用Evaluate添加或者修改几行代码！！！！！！！极优！！！！不用编译，也不用导包重启 （3）用来解问题很适合，查看某些量，某些信息，尤其可以看到这个量周围量的信息！！！！！ watchs改变值：优点：更加图形化，不用写代码 1.1.4. 改写值之----Evaluate and log 见《断点日志》 1.1.5. 改写值之 反射 利用断调试 动态 反射修改final数据域 ---》 极优 参考： https://www.cnblogs.com/fudashi/p/6624379.html 注意： 修改后，就不依赖于 断点调试环境了，永远修改了！！！！！！！！ -----》 自然，除非重启手机 TODO: 能用反射，必然可以发挥的空间很大!! 应用一：修改debug开关 ---》修改后，脱离断点调试 修改final数据域: // 构造一个Person类，里面有个final字段NAME Person p = new Person(); Field field = p.getClass().getDeclaredField(\"NAME\"); field.setAccessible(true); field.set(p,\"Hello\"); 修改static final数据域，比如： Class clz = ActivityTaskManagerDebugConfig.class; Field field = clz.getDeclaredField(\"DEBUG_STATES\"); field.setAccessible(true); field.set(new ActivityTaskManagerDebugConfig(),true); 效果： 调用方法 例2：以无参方法为例子： // 在view.java中 调用 Activity.java方法： Class clz = this.getContext().getClass(); Method method = clz.getMethod(\"dismissKeyboardShortcutsHelper\"); method.toString(); method.invoke(this.getContext()); //结果： public final void android.app.Activity.dismissKeyboardShortcutsHelper() 例3：以两参方法为例子： // 在view.java中 调用 Activity.java方法performResume： Class clz = this.getContext().getClass(); Method method = clz.getDeclaredMethod(\"performResume\",boolean.class,String.class); method.toString(); method.invoke(this.getContext()); //结果： -----》 Method threw 'java.lang.NoSuchMethodException' exception Class clz = this.getContext().getClass(); Method[] method = clz.getDeclaredMethods(); Arrays.toString(method); //本类方法 [static com.example.myhandlerdemo.MainActivity$MyHandler com.example.myhandlerdemo.MainActivity.access$000(com.example.myhandlerdemo.MainActivity), protected void com.example.myhandlerdemo.MainActivity.onCreate(android.os.Bundle), public void com.example.myhandlerdemo.MainActivity.testJump2anotherApp()] //view.java Class clz = this.getContext().getClass(); Method[] method = clz.getMethods(); Arrays.toString(method); 纵向横向： getMethods()：能够获取类的所有public方法，包括自身定义的以及从父类继承的。 -----> 即限制在public里（纵向） getDeclaredMethods()：能够获取类本身的所有方法，包括private方法，实现的接口方法，但是不能获取从父类继承的非public方法 ------> 即限制在本类里（横向） 如何调用父类的 private方法呢？ 只能用父类来调用，即 子.getSuperclass() 参考： https://blog.csdn.net/u013425438/article/details/92637055 所以： // 在view.java中 调用 Activity.java方法performResume： Class clz = this.getContext().getClass(); Method method = clz.getDeclaredMethod(\"performResume\",boolean.class,String.class); method.toString(); method.invoke(this.getContext()); 应该为： Class clz = this.getContext().getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass(); 技巧： 一个复杂的代码/脚本，验证一点，添加一点 全量的东西是好的，万能的：比如 getMethods()先查看，有哪些方法 每一行提前验证，结果验证： Class clz = this.getContext().getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass(); clz.toString(); //验证 Method[] methods = clz.getMethods(); Arrays.toString(methods); //全量，为后一步提供验证 Method method = clz.getDeclaredMethod(\"performResume\",boolean.class,String.class); method.toString(); //验证 //调用 method.invoke(this.getContext(), false, \"RESUME_ACTIVITY\"); method.invoke((Activity)this.getContext(), false, \"RESUME_ACTIVITY\"); ---------> 因为非公有方法，调用需要 method.setAccessible(true); 可以运行的最后脚本： Class clz = this.getContext().getClass().getSuperclass().getSuperclass().getSuperclass().getSuperclass().getSuperclass(); clz.toString(); Method method = clz.getDeclaredMethod(\"performResume\",boolean.class,String.class); method.setAccessible(true); method.invoke(this.getContext(), false, \"RESUME_ACTIVITY\"); 进一步优化，OK： //优化点，用while找到对应的类 Class clz = this.getContext().getClass(); Class superclass = clz.getSuperclass(); while (superclass != null) { if(superclass.getSimpleName().equals(\"Activity\")){ break; } superclass = superclass.getSuperclass(); } clz = superclass; clz.toString(); Method method = clz.getDeclaredMethod(\"performResume\",boolean.class,String.class); method.setAccessible(true); method.invoke(this.getContext(), false, \"RESUME_ACTIVITY\"); 参考：https://blog.csdn.net/huangxinyu_it/article/details/73499490 .java反射 https://blog.csdn.net/weixin_56442629/article/details/115430249 补充：实例化Class类对象的三种方式 package HelloClass; class Hello { } public class GetClassDemo { public static void main(String[] args) throws ClassNotFoundException { Class c1 = null; Class c2 = null; Class c3 = null; //1. c1 = Class.forName(\"HelloClass.Hello\"); //2. c2 = new Hello().getClass(); //3. c3 = Hello.class; 1.1.6. 断点日志： 动态地 改写值、添加log （调用栈） 既然可以断点调试了，为啥还要log（调用栈）？------> 断点log，不要勾选Suspend！！！ 原因在于： 1、断点调试太慢，会将思路打断，消耗人的意志力 ------> 快速有快速的好处，整体 结构更强 2、有些流程，就不适合降速，比如有时间要求的 -极优： 1、断点日志 与 普通日志 没有任何区别（除了不用编译） 2、不会阻塞线程。很多流程不能阻塞 ​ 注意，不要勾选Suspend，不会阻塞线程 3、在attach过程中，还可以修改、添加log 4、一直attach，不会导致ANR 5、部分第三方jar，aar里面外面更是无法手动添加log代码---》 该方法OK 注意：最终结果，一定以string， 布尔型等的形式表达出来 常见的log： //当前线程名 \"Thread: \" + Thread.currentThread().getName() + \", \" + Thread.currentThread().getId() + \", \" + new java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\").format(System.currentTimeMillis()); // 当前系统时间 new java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\").format(System.currentTimeMillis()) //当前具体实例 \",\" + this; //当前函数名 \"func: \" + Thread.currentThread().getStackTrace()[2].getMethodName(); //调用栈 勾选 Stack trace 综合脚本： String s = \"Thread: \" + Thread.currentThread().getName() + \", \" + Thread.currentThread().getId() + \", \" + new java.text.SimpleDateFormat(\"yyyy-MM-dd HH:mm:ss:SSS\").format(System.currentTimeMillis())+ \",\" + this.getSimpleName() + \", func: \" + Thread.currentThread().getStackTrace()[2].getMethodName(); 注意： 可以多行代码，比如： // 在view.java中 调用 Activity.java方法： Class clz = this.getContext().getClass(); Method method = clz.getMethod(\"dismissKeyboardShortcutsHelper\"); method.toString(); method.invoke(this.getContext()); -------> 只有最后一行结果，会被打印出来 调用栈 优点： 相当于目录+大纲： 1、方便快速跳转 2、不会 走到细节分支 3、观察触发点，触发点是锚点，建立记忆逻辑 断点日志，最优实践 不在debug里输出 ------> 缺点：（1）没有时间戳 （2）只能打印一个string 真正意义上在debug过程中使用 （1）log能做的事情，这里都能做 Evaluate and log之 写代码 TODO: 一个很可能的做法是，在这个框里写自己的需求代码。而不需要重新编译 -----> 极优 1.1.7. 异常断点 https://blog.csdn.net/weixin_35735663/article/details/114159806 捕获android运行的时候抛出的异常 ------> 给车祸的第一现场拍照 TODO: 啥区别 例子： 虽然看不到微信代码，但是可以看到它抛了异常 1.1.8. 方法断点 TODO: 好像没有什么价值 参考 https://blog.csdn.net/weixin_35735663/article/details/114159806 不需要关心这个方法里面的变量是怎么变化的时候？ 1.1.9. 字段断点和方法断点 1.1.10. 断点调试时，关闭ANR 断点调试，很耗费时间，安卓触摸事件等，有ANR机制，让进程挂了。 -----> 技巧：关闭ANR机制 https://www.coder.work/article/140491 https://qa.1r1g.com/sf/ask/3854914871/ TODO: 命令行如何关闭ANR? （有些阉割系统，设置里根本没有这个选项） 因为可以看到ANR代码机制，所以，理论上，一定可以调试时破坏这个机制 1.1.11. 过滤之 condition 过滤的重要性（一种化简）： 大量的log，必须过滤，1、否则没法看 2、断点次数会卡 condition断点： 1.1.12. 过滤之watch watch把自己要观察的多级内层的一个值，外提 -------》 以便于观察。断点 + 按F9, 当watch是自己想要的，停下---------> 过滤作用 1.1.13. 杀进程 利用断点调试杀进程 先attach，然后关闭attach 利用命令行杀进程 使用情况：经常需要杀进程 见《手机命令》 1.1.14. 改app代码，而非framework源码 很多时候，想要观察framework源码 ？？？？？？？？？？？？？ 1.1.15. debug的遗憾 只能修改值（内存里的值），无法给函数打桩 (无法直接return 或者 返回固定值)------------> 而C语言是可以的 ----> TODO 1.1.16. 注意事项： 为了防止调试过程中应用被系统AMS干掉，先把开发者选项中的【显示所有应用程序无响应】开关打开，不打开的情况下断点调试过程中应用进程很容易挂掉。 1.2. IDEA DEBUG技巧整理 https://blog.csdn.net/weixin_43981673/article/details/106298812 TODO：视频教程 https://www.bilibili.com/video/BV1g4411k7UJ?p=15 技巧，搜索所有AS问题都可以搜索IDEA，更广泛！！！！ 1.3. AS断点调试 Build.gradle的详细配置 Build.gradle apply plugin: 'com.android.application'//说明module的类型，com.android.application为程序，com.android.library为库 android { compileSdkVersion 22//编译的SDK版本 buildToolsVersion \"22.0.1\"//编译的Tools版本 defaultConfig {//默认配置 applicationId \"com.nd.famlink\"//应用程序的包名 minSdkVersion 8//支持的最低版本 targetSdkVersion 19//支持的目标版本 versionCode 52//版本号 versionName \"3.0.1\"//版本名 manifestPlaceholders = [ UMENG_CHANNEL_VALUE:\"hsq\" ]//声明友盟渠道名是可变的 } sourceSets {//目录指向配置 main { manifest.srcFile 'AndroidManifest.xml'//指定AndroidManifest文件 java.srcDirs = ['src']//指定source目录 resources.srcDirs = ['src']//指定source目录 aidl.srcDirs = ['src']//指定source目录 renderscript.srcDirs = ['src']//指定source目录 res.srcDirs = ['res']//指定资源目录 assets.srcDirs = ['assets']//指定assets目录 jniLibs.srcDirs = ['libs']//指定lib库目录 } debug.setRoot('build-types/debug')//指定debug模式的路径 release.setRoot('build-types/release')//指定release模式的路径 } signingConfigs {//签名配置 release {//发布版签名配置 storeFile file(\"fk.keystore\")//密钥文件路径 storePassword \"123\"//密钥文件密码 keyAlias \"fk\"//key别名 keyPassword \"123\"//key密码 } debug {//debug版签名配置 storeFile file(\"fk.keystore\") storePassword \"123\" keyAlias \"fk\" keyPassword \"123\" } } buildTypes {//build类型 release {//发布 minifyEnabled true//混淆开启 proguardFiles getDefaultProguardFile('proguard-android.txt'), 'proguard-project.txt'//指定混淆规则文件 signingConfig signingConfigs.release//设置签名信息 } debug {//调试 signingConfig signingConfigs.release } } packagingOptions { exclude 'META-INF/ASL2.0' exclude 'META-INF/LICENSE' exclude 'META-INF/NOTICE' exclude 'META-INF/MANIFEST.MF' } lintOptions { abortOnError false//lint时候终止错误上报,防止编译的时候莫名的失败 } //打包-渠道 productFlavors { hsq{} hsq_dx{} hsq_wx{} baidu{} yingyongbao{} ppzhushou{} anzhi{} zhushou360{} huawei{} lenovomm{} wandoujia{} mumayi{} meizu{} youyi{} sougou{} } //打包-防渠道代码重复处理 productFlavors.all { flavor -> flavor.manifestPlaceholders = [ UMENG_CHANNEL_VALUE:name ] } } dependencies {//依赖 compile fileTree(dir: 'libs', exclude: ['android-support*.jar'], include: ['*.jar']) //编译lib目录下的.jar文件 compile project(':Easylink')//编译附加的项目 compile project(':ImageLibrary') compile project(':ImageResLibrary') compile project(':Ofdmtransport') compile project(':PullToRefreshLibrary') compile project(':RecorderLibrary') compile project(':WebSocket') compile project(':WidgetLibrary') compile 'com.nostra13.universalimageloader:universal-image-loader:1.9.3'//编译来自Jcenter的第三方开源库 } 1.4. 用源码搭建java断点调试环境----法一 法一：copy aosp源码到工程目录 https://blog.csdn.net/Gsony6501/article/details/110139734 https://blog.csdn.net/qq_38998213/article/details/81907253 优点：本地代码，不受网速影响 缺点：服务器代码copy到 本地工程目录 1.4.1. 新建一个空的工程 保证可同步sync，可编译，可安装 1.4.2. 根目录下新建与app同级的module 选择： 并取名frameworks ---》后面代码导入该目录下 ----》加入module ，再次编译app，保证环境可编译，可安装 注意生成的module 级两个文件：frameworks.iml 与 build.gradle 1.4.3. 删掉src、libs 删掉frameworks下自动生成的文件夹：src、libs ，并copy代码到该目录下比如base目录下 1.4.4. 为base下代码设置为source // sourceSets{ //目录指向配置 main { manifest.srcFile 'AndroidManifest.xml' //指定AndroidManifest.xml文件 java.srcDirs = ['base'] //指定source目录 resources.srcDirs = ['base'] //指定source目录 aidl.srcDirs = ['base'] //指定source目录 renderscript.srcDirs = ['base'] //指定source目录 res.srcDirs = ['base/core/res/res']//指定资源目录 assets.srcDirs = ['base/core/res/res/assets']//指定assets目录 jniLibs.srcDirs = ['libs']//指定lib库目录 } } 1.4.5. 同步，保证环境 会出现 需要增加与base同级的AndroidManifest.xml ： 再同步，直到成功 ---》保证环境 1.4.6. 最重要一点： 配置跳转优先级（点击鼠标左键时）：这里当然是把jdk和sdk的依赖放到最后---》可以优先依赖到sourceFolder frameworks.iml 文件： 这样就完成了一个可断点调试的环境 补充：对于linux下 AS，该文件处于： 1.4.7. 最重要第二点： 避免attach的时候，优先attach到sdk里的代码。删除app.iml 中sdk依赖： 注意：只是临时删除。编译时还要加回来，不然编译不过 1.4.8. 不允许添加两个module 规定：不允许添加两个依赖。。。。只添加一个root（子目录framework、packages） 因为 两个依赖之间，无法跳转（飘红之 依赖间无法跳转） 例子： android { ............. sourceSets{ //目录指向配置 main { manifest.srcFile 'AndroidManifest.xml' //指定AndroidManifest.xml文件 java.srcDirs = ['frameworks','packages'] //指定source目录 resources.srcDirs = ['frameworks','packages'] //指定source目录 aidl.srcDirs = ['frameworks','packages'] //指定source目录 renderscript.srcDirs = ['frameworks','packages'] //指定source目录 res.srcDirs = ['frameworks/base/core/res/res']//指定资源目录 assets.srcDirs = ['frameworks/base/core/res/res/assets']//指定assets目录 jniLibs.srcDirs = ['libs']//指定lib库目录 } } } 1.4.9. 关于aidl的调试（万能调试）： 方法一：万能的classes.jar （优的方法，万能且可以包含所有类！！！！） framework.jar原始没有打包加密的jar路径： \\out\\target\\common\\obj\\JAVA_LIBRARIES\\framework_intermediates\\classes.jar 基于此，可以做很多事情： 1、依赖跳转 --》飘红问题 2、依赖编译 --》超越sdk编译 3、依赖断点调试 ---》aidl等调试 方法：1、classes.jar改名framework.jar，添加到依赖里 2、sync后，gradle里有： 3、class文件可以加断点调试（只是行号对不上，因为这是class文件） 注：IActivityTaskManager$Stub$Proxy 指的是IActivityTaskManager类里的Stub类里的Proxy类 方法二： 找到aidl编译出的源码java文件，IActivityTaskManager.java 在app的依赖framework里添加一个路径laji: 特别注意一点：要检查package android.app;没有被IDE修改为laji ----》否则无法断点上 方式三： aidl的理解 1.4.10. 移除module 不能直接删 1.4.11. 技巧： 同时调试 应用+ framework代码： demo和源码放到同一工程，作为不同module，可以同时调试 应用+ framework代码 iml本质 根据gradle中sourceSets生成的依赖关系集合（包括sourceFolder等） 同包的两个类不能引用导致飘红 同包却无法引用-------》 1、方法1：右键，将包名上一级即java作为source --->缺点：source里不能嵌套source，需要将base取消 2、方法2：修改iml文件，可以source嵌套source！！！ 添加： 技巧：方法2快速添加技巧: 右键java，exclude iml文件会新增： 修改为source-folder 3、方法3： 方法2的界面化操作： 先取消framework的，添加java为source，最后还原framework 图： 1.5. 用源码搭建java断点调试环境----法二，有问题 法二：修改app/build.gradle -----> 在android的域中添加sourcesets项, 指定JAVA的源码目录(java.srcDirs为服务器的java源码目录) 优点：1、服务器代码不用copy到 本地工程目录 2、可以引入多个 缺点：对网速要求高 #app/build.gradle android { compileSdkVersion 28 .......... sourceSets { main { // 在此处添加你需要的代码路径(注意是java目录) java.srcDirs = ['X:\\\\agpdev\\\\foundation\\\\graphic\\\\java\\\\src', 'X:\\\\foundation\\\\graphic\\\\test\\\\agp_sample\\\\demo_app\\\\app\\\\src\\\\main\\\\java', ] // 在此处添加你需要的资源路径 //resources.srcDirs = ['W:\\\\WCL_WorkSpase\\\\EMUI10.0_GP\\\\packages\\\\apps\\\\Settings\\\\app\\\\src\\\\main\\\\res'] // 清单文件路径 //manifest.srcFile = 'W:\\\\app\\\\src\\\\main\\\\ AndroidManifest.xml' } } 优点：保存了源码最原始的目录。。。。srcDirs为指定的 很大缺点：似乎把整个盘都index了，很慢！！！ -------> TODO: 以前似乎不是这样？？？？ 参考： 《源码导入IDE说明java_cpp跳转.pdf》 1.6. 用源码搭建java断点调试环境----法三，有问题 settings.gradle中添加： include ':Custom' project(\":Custom\").projectDir = new File(\"I:\\\\dockerSharedFiles\\\\aosp_1200_r28_sourceRoot\\\\frameworks\\\\base\\\\core\") include ':Custom2' project(\":Custom2\").projectDir = new File(\"I:\\\\dockerSharedFiles\\\\aosp_1200_r28_sourceRoot\\\\frameworks\\\\base\\\\services\") 优点：一行修改搞定 很大缺点：一个projectDir会变成一个module -------> 左边目录，无法保持aosp源码目录，没有显示frameworks\\base目录（尤其只需要一部分代码时） ​ 两个module之间不能跳转！ 1.7. framework java 断点调试 环境（jdb） 主要参考链接： https://developer.aliyun.com/article/24084 https://blog.csdn.net/SCHOLAR_II/article/details/81562459?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_title~default-4.control&spm=1001.2101.3001.4242 java jdb 命令行调试程序 https://blog.csdn.net/arkblue/article/details/39718947 1.7.1. 总结： 1、环境： adb shell am start -D -n com.example.BarrierFree_demo/.MainActivity && @ping -n 3 127.1>nul 2>nul && adb shell ------> 极优：以debug模式打开，给足够的时间attach。不限于jdb，任何调试环境都可以这样！GDB adb shell ps | findstr client adb forward tcp:9000 jdwp:27681 jdb -connect com.sun.jdi.SocketAttach:port=9000,hostname=localhost 2、jdb： stop at com.example.BarrierFree_demo.MainActivity:85 1.7.2. 环境 adb shell ps查看进程的信息： system 835 793 208564 29768 ffffffff afe0c57c S system_server radio 873 793 112816 21252 ffffffff afe0d674 S com.android.phone app_8 876 793 98044 17336 ffffffff afe0d674 S android.process.media app_7 879 793 123780 28452 ffffffff afe0d674 S android.process.acore app_0 926 793 104916 18372 ffffffff afe0d674 S com.google.process.gapps app_11 956 793 96008 16392 ffffffff afe0d674 S com.android.alarmclock app_16 989 793 105304 16772 ffffffff afe0d674 S com.android.mms app_23 999 793 96324 15552 ffffffff afe0d674 S org.broncho.powermonitor app_19 1010 793 98492 16044 ffffffff afe0d674 S com.android.setupwizard app_7 1022 793 106708 19204 ffffffff afe0d674 S com.android.inputmethod.pinyin 建立网络数据转发关系，pid 873 adb forward tcp:9000 jdwp:873 # 查看是否成功 adb forward --list 设置jdb源代码路径，这里设置了android系统内的JAVA路径，如果调试自己的应用程序 ，可以加在后面 set ANDROID_SRC=\"G:\\dockerSharedFiles\\aosp_android1000_r17\\aosp_android1000_r17\" set ANDROID_SRC_PATH=$ANDROID_SRC/frameworks/base/opengl/java:$ANDROID_SRC/frameworks/base/awt/java:$ANDROID_SRC/frameworks/base/core/java:$ANDROID_SRC/frameworks/base/location/java:$ANDROID_SRC/frameworks/base/sax/java:$ANDROID_SRC/frameworks/base/graphics/java:$ANDROID_SRC/frameworks/base/telephony/java:$ANDROID_SRC/frameworks/base/services/java:$ANDROID_SRC/frameworks/base/media/java:$ANDROID_SRC/frameworks/base/wifi/java:$ANDROID_SRC/frameworks/base/im/java:$ANDROID_SRC/dalvik/libcore/suncompat/src/main/java:$ANDROID_SRC/dalvik/libcore/nio_char/src/main/java:$ANDROID_SRC/dalvik/libcore/nio_char/src/main/java/java:$ANDROID_SRC/dalvik/libcore/security-kernel/src/main/java:$ANDROID_SRC/dalvik/libcore/security-kernel/src/main/java/java:$ANDROID_SRC/dalvik/libcore/security/src/main/java:$ANDROID_SRC/dalvik/libcore/security/src/main/java/java:$ANDROID_SRC/dalvik/libcore/archive/src/main/java:$ANDROID_SRC/dalvik/libcore/archive/src/main/java/java:$ANDROID_SRC/dalvik/libcore/awt-kernel/src/main/java:$ANDROID_SRC/dalvik/libcore/awt-kernel/src/main/java/java:$ANDROID_SRC/dalvik/libcore/luni/src/main/java:$ANDROID_SRC/dalvik/libcore/luni/src/main/java/java:$ANDROID_SRC/dalvik/libcore/math/src/main/java:$ANDROID_SRC/dalvik/libcore/math/src/main/java/java:$ANDROID_SRC/dalvik/libcore/x-net/src/main/java:$ANDROID_SRC/dalvik/libcore/openssl/src/main/java:$ANDROID_SRC/dalvik/libcore/dalvik/src/main/java:$ANDROID_SRC/dalvik/libcore/auth/src/main/java:$ANDROID_SRC/dalvik/libcore/concurrent/src/main/java:$ANDROID_SRC/dalvik/libcore/concurrent/src/main/java/java:$ANDROID_SRC/dalvik/libcore/sql/src/main/java:$ANDROID_SRC/dalvik/libcore/sql/src/main/java/java:$ANDROID_SRC/dalvik/libcore/prefs/src/main/java:$ANDROID_SRC/dalvik/libcore/prefs/src/main/java/java:$ANDROID_SRC/dalvik/libcore/xml/src/main/java:$ANDROID_SRC/dalvik/libcore/text/src/main/java:$ANDROID_SRC/dalvik/libcore/text/src/main/java/java:$ANDROID_SRC/dalvik/libcore/luni-kernel/src/main/java:$ANDROID_SRC/dalvik/libcore/luni-kernel/src/main/java/java:$ANDROID_SRC/dalvik/libcore/regex/src/main/java:$ANDROID_SRC/dalvik/libcore/regex/src/main/java/java:$ANDROID_SRC/dalvik/libcore/nio/src/main/java:$ANDROID_SRC/dalvik/libcore/nio/src/main/java/java:$ANDROID_SRC/dalvik/libcore/json/src/main/java:$ANDROID_SRC/dalvik/libcore/crypto/src/main/java:$ANDROID_SRC/dalvik/libcore/icu/src/main/java:$ANDROID_SRC/dalvik/libcore/annotation/src/main/java:$ANDROID_SRC/dalvik/libcore/annotation/src/main/java/java:$ANDROID_SRC/dalvik/libcore/junit/src/main/java:$ANDROID_SRC/dalvik/libcore/logging/src/main/java:$ANDROID_SRC/dalvik/libcore/logging/src/main/java/java:$ANDROID_SRC/dalvik/libcore-disabled/instrument/src/main/java:$ANDROID_SRC/dalvik/libcore-disabled/instrument/src/main/java/java:$ANDROID_SRC/dalvik/libcore-disabled/sound/src/main/java 启动jdb jdb -sourcepath $ANDROID_SRC_PATH -attach localhost:9000 这里的端口号9000，是由前面的tcp:9000决定 附：可能的报错 原因：Android Studio占用了jdb, 关闭Android Studio 重试 需要关闭AS。。。同时再次执行：adb forward tcp:9000 jdwp:17652 1.8. framework Native 断点调试 环境（GDB） https://blog.csdn.net/weixin_34419326/article/details/90306477 1.8.1. 最终目标： 执行linux下 gdbclient.py ---> GOOGLE封装好的断点脚本 chengang@89d22fcdad99:~/workingSpace/aosp_android1000_r17$ which gdbclient.py /home/chengang/workingSpace/aosp_android1000_r17/development/scripts/gdbclient.py //todo: 看一下源码 所以条件是：1、linux下 2、linux与手机互联（问题） 1.8.2. gdbclient.py方法步骤 步骤1：docker容器（linux）与手机如何adb 链接？ 见《docker连 主机pc连的安卓设备》 即： 宿主windows侧： adbkit usb-device-to-tcp -p 7788 FA6930305260 docker容器一侧 adb connect host.docker.internal:7788 步骤2：aosp初始化环境 # 运行shell脚本，配置环境 $ source build/envsetup.sh # 然后选择自己要调试的编译版本 $ lunch $ aosp_sailfish-userdebug // 或直接 lunch aosp_sailfish-userdebug --->作用： gdbclient.py 在根目录下，可以索引到所有变量，比如gdb、gdbclient等 步骤3：gdbserver 与 gdbclient 链接 gdbserver // 是push进手机里的 gdbclient // 在linux里，google封装的gdbclient.py 即： # windows侧： adb root adb remount adb push G:\\dockerSharedFiles\\aosp_android1000_r17\\aosp_android1000_r17\\prebuilts\\misc\\gdbserver\\android-arm64\\gdbserver64 /system/bin/ 启动gdbclient.py （封装了先启动gdbserver，后gdbclient），命令： gdbclient.py -p PID 其中，进程PID获取：adb shell ps -ef | grep mediaserver 步骤4：GDB操作 设置断点：(gdb) b android::MediaPlayerService::Client::start 设置continue：(gdb) c 操作手机，然后就断点住了 1.8.3. 通用GDB方法的步骤（TODO:验证补充） google是封装了gdbclient.py 通用的，就是gdbclient.py 封装的细节： 1、设置GDB路径、端口号、符号目录、路径映射（不用）： 学习Google是如何配置符号的 2、 设置端口转发，attach进程pid adb forward tcp:1235 tcp:1235 ---》前面选定的端口 adb shell gdbserver :1235 --attach pid 或 adb shell gdbserver64 :1235 --attach pid 3、设置断点 1.8.4. 注意： 1、需要保证所有环境adb version是一致的，否则会连不起来 哪些环境？ win、linux的通用adb、linux aosp根目录下的adb 2、gdbserver是可以手动起的，gdbclient的脚本会执行，见参考。 3、通过wifi调试，设备连接wifi,保证服务器和设备在同一个局域网内 $ adb tcpip 5555 #在设备端运行 $ adb connect #在服务端运行 4、adb forward tcp:1991 tcp:1991 6.0以后不用执行，gdbclient的脚本会执行（client侧的） 5、需要源码嘛？ 1.8.5. 参考 https://blog.csdn.net/hongguifengd/article/details/115423968 https://blog.csdn.net/wangzaieee/article/details/83895089 https://blog.csdn.net/weixin_34419326/article/details/90306477 https://source.android.com/docs/core/tests/debug/gdb 官方文档 1.8.6. 待整理 《docker，cpp断点调试》 对于好的项目的东西，要学着打开来看，比如 TODO: 学习gdbclient.py ，学习Google如何搭建GDB环境的 ----> 通用能力！！！！！！！！非常重要 至少有 设置sysroot 这四个值，最终路径是啥？对于GDB如何设置的 1.9. framework Native Clion 调试环境（linux下） 调试的前提：-------- 1、符号表 2、cmake跳转，见：framework Native Clion 跳转环境（linux下）。 缺点：比纯粹的GDB，跳转慢一些 1.9.1. clion配置 1、链接 见，docker容器（linux）与手机如何adb 链接 2、设置远程调试： Run -> Edit Configurations 点击+号，选择GDB Remote Debug 3、设置GDB路径、端口号、符号目录、路径映射（不用）： GDB路径：不要用clion自带的。技巧：用AOSP的，匹配度最好 端口号 ：后面设置端口转发的 符号目录：/out/target/product/sailfish/symbols 注意：此目录下有lib64和lib两套！！！ 路径映射（不用）：用来同步代码的， 宿主机与 linux机 之间代码映射 1.9.2. clion端开始debug 1、 设置端口转发，attach进程pid adb forward tcp:1235 tcp:1235 ---》前面选定的端口 adb shell gdbserver :1235 --attach pid 或 adb shell gdbserver64 :1235 --attach pid 2、设置断点 3、CLion点击Debug ‘AndroidRemoteDebug’ 1.9.3. 技巧： 技巧1： 命令行GDB 与 界面可以同时用！！！！！！ -------》优： 1、在界面的情况下，也建议使用GDB命令行，要比F7、F8快捷键要快：GDB 牵动界面变化 ​ 2、界面只用于 显示代码 + 查看临时变量 技巧2： 部分难的断点也用GDB，不用界面。比如，断点在Thread12上面，界面做不到 b android::Looper::wake thread 12 技巧2： 显示放左边。控制GDB 放右边 1.9.4. 参考 https://blog.csdn.net/iamdy/article/details/111272854 https://cloud.tencent.com/developer/article/1406250 1.10. 断点调试环境 lib64 、lib 区分 ----> 从debug角度，为啥需要？ 用于选择gdbServer/gdbServer64、lib/lib64 https://qa.1r1g.com/sf/ask/2230326521/ 如果您的apk是用纯java(没有jni)编写的,那么在64位 - 原始/ 32位辅助Android操作系统上,默认情况下, 您的应用程序将始终以64位模式运行 理解：https://blog.csdn.net/TyearLin/article/details/121370999?spm=1001.2101.3001.6650.4&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121370999-blog-107559416.pc_relevant_multi_platform_whitelistv3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-4-121370999-blog-107559416.pc_relevant_multi_platform_whitelistv3&utm_relevant_index=4 1.10.1. 解决办法： 方法一（天然ok）： jdb下环境，gdbClient.py 脚本已经判断是多少位了，并选择gdbsever、lib 64或32。。。gdbClient.py加log打印 方法二： clion环境下，gdbsever不会自动选择、lib自动选择 ---> 手动选择 gdbsever64： adb shell gdbserver64 :1235 --attach pid 补充： gdbsever选错的现象： （1） （2）(gdb)info sh info sharedlibrary 显示共享库为空 方法三：强制APK底层调用bit32库（优） ---> 然后用方法一、方法二 参考：如何强制Android应用程序使用32位或64位库： https://qa.1r1g.com/sf/ask/2230326521/ 步骤： 1、编译对应的位数的apk（似乎并不必要） // build.gradle android { compileSdkVersion 29 buildToolsVersion \"30.0.3\" defaultConfig { ............. } splits { abi { enable true reset() include 'armeabi-v7a', 'arm64-v8a' //select ABIs to build APKs for universalApk true //generate an additional APK that contains all the ABIs } } } dependencies { ........... } 补充： android中的armeabi、armeabi-v7a、arm64-v8a及x86等 https://blog.csdn.net/u013083465/article/details/122453664 2、指定ABI安装apk（这是关键点） 安装apk时可以指定ABI 。 在ARM设备的情况下, 要在32位模式下运行安装使用, adb install --abi armeabi-v7a 要在64位模式下运行安装使用, adb install --abi arm64-v8a 1.10.2. 以上所有判断 环境OK不OK的办法 显示共享库： (gdb) info sharedlibrary 1.11. framework Native Clion 跳转环境（linux下） 1.11.1. 基本原理 跳转的基本原理：--------1、cmake链接文件正常。 注意：跳转不依赖符号表， 调试 依赖符号表 注：cmake链接文件正常实际上 即：没有飘红 2、index索引完 1.11.2. 具体步驟： 1、编译生成CMakeLists.txt： build目录下有文档build/soong/docs/clion.md // 打开开关，编译时生成CMakeLists.txt export SOONG_GEN_CMAKEFILES=1 export SOONG_GEN_CMAKEFILES_DEBUG=1 // 全编译 make -j32 // 或者编译单独模块 make frameworks/native/service/libs/ui // CMakeLists.txt会生成在 out/development/ide/clion/frameworks/native/libs/ui/libui-arm64-android/CMakeLists.txt 2、导入 新建总的CMakeLists.txt放到 源代码根目录上 cmake_minimum_required(VERSION 3.6) project(AOSP-Native) #// CMAKE_HOME_DIRECTORY是系统给定的值 set(ANDROID_ROOT \"${CMAKE_HOME_DIRECTORY}\") set(CMAKE_DIRECTORY_FOR_CLION \"${ANDROID_ROOT}/out/development/ide/clion\") #// 导入各个子cmakeList。工程很多，用到了再导入: add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/art/dalvikvm/dalvikvm-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/art/libdexfile/libdexfile-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/art/runtime/libart-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/external/compiler-rt/lib/sanitizer_common/libsan-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/av/media/libaaudio/src/libaaudio-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/av/soundtrigger/libsoundtrigger-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/base/core/jni/libandroid_runtime-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/native/cmds/installd/installd-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/native/cmds/servicemanager/servicemanager-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/frameworks/native/libs/binder/libbinder-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/libcore/libjavacore-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/libcore/libopenjdk-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/libnativehelper/libnativehelper-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/libnativehelper/libnativehelper_compat_libc++-arm-android) #// 内核的CMakeLists是自己写的，只导入了头文件，跳转还有问题 #//系统工具 add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/base/libbase-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/init/libinit-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/libziparchive/libziparchive-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/liblog/liblog-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/libcutils/libcutils-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/libutils/libutils-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/libprocessgroup/libprocessgroup-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/logcat/logcatd-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/logcat/logcat-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/logd/logd-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/logd/liblogd-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/lmkd/liblmkd_utils-arm-android) add_subdirectory(${CMAKE_DIRECTORY_FOR_CLION}/system/core/lmkd/lmkd-arm-android) 3、导入 打开CLion 选择「New CMake Project from Sources」 指定包含 CMakeLists.txt 4、clion编译器配置： 技巧：选择aosp cmakeList指定的clang 。 用Ubuntu的gcc和clang，编译基本上有问题 1.11.3. 一些问题： 有时候自动生成出来的cmakeList是有问题的，需要手动修改(注意：必须用clion修改，这样clion会重新load project) 比如：导致.h没有进入，导致关联不上.h 1.11.4. 参考： https://blog.csdn.net/iamdy/article/details/106658583 build/soong/docs/clion.md 官方文档 art/tools/generate_cmake_lists.py ------》 自动生成cmakelist的脚本 TODO 1.12. 搜索能力： 1、代码方面： 2、Google方面 1.12.1. 搜索技巧之搜索同类 // Parcel.java private static native long nativeCreate(); .......... private static native boolean nativeHasFileDescriptors(long nativePtr); 比如想要在AOSP native代码中搜索nativeCreate，会很多，但是可以搜索比较独特的nativeHasFileDescriptors 搜索的核心在于，独特，唯一 1.12.2. aosp本地代码 全量搜索 在全量搜索的情况下，由于本地ide导入的代码量大，搜索很慢 -----> 全量搜索，用Android Code Search搜索，速度快，且全 之后，找到本地对应代码路径 在线 + 本地 1.12.3. 对知识点的搜索途径 Google、baidu、new Bing、bibili 1.13. 断点环境问题 1、找不到system_process 2、system_process debug过程中，没有断到任何断点上 -------------> 先在APP进程上断点上，然后再尝试system_process 3、attach 上 system_process之后，直接重启 1.14. debug环境规定： 1、ANR显示crash对话、show后台ANR 2、关闭动画？ 3、select an APP可以不ANR的 4、次要环境：显示点击的位置 2. LOG 2.1. system log 作用： 记录手机android上层app以及framework相关活动的log，比如你写的app打印的log，就在这里面 adb shell logcat -v 2.1.1. ProtoLog动态log Android ProtoLog动态开启相关wm logging源码分析补充 https://blog.csdn.net/liaosongmao1/article/details/130597983?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-0-130597983-blog-110820407.235^v38^pc_relevant_default_base3&spm=1001.2101.3001.4242.1&utm_relevant_index=3 2.2. EventLog 作用： 非常简洁明了地展现当前Activity各种状态 -----》 状态性日志，而不是流程性 ActivityManager、powerManager等相关的log adb shell logcat -b events adb shell logcat -b events | findstr \"am_ wm_\" // 同时过滤AMS与Wms ---------》 注意：普通的adb shell logcat 日志里没有 event log 涉及的源码类： EventLog.java, EventLogTags.java 2.2.1. 参考 http://gityuan.com/2016/05/15/event-log/ Android EventLog含义 ----> 详细 https://blog.csdn.net/junjle/article/details/87184120?utm_medium=distribute.pc_relevant.none-task-blog-2~default~baidujs_baidulandingword~default-1-87184120-blog-117734286.235^v38^pc_relevant_default_base3&spm=1001.2101.3001.4242.2&utm_relevant_index=4 2.3. kernel Log 驱动相关的log ctrl+alt+shift+i 2.4. log环境规定 规定： 1、永远不允许用AS抓log （日志过多，AS端日志会冲掉） 用 adb logcat -c && adb logcat -v time > logcat.txt 2、log buffer选择最大 -----> 否则，有可能丢日志 3. log、debug适用的场景 1、对于复杂问题，log是最终手段，疯狂加log 2、debug适合一次调用 ​ 适合看变量的值 ​ 看调用栈（一次调用） 循环调用的函数（for遍历的、多次调用的）-------> 适合用log来看 生命周期这种（循环分发的）-------> log TODO: log与debug结合？ log的分层模型设计 《---------如何打印log？？？一级log、二级log log如何处理多线程？ log与trace的结合 ​ 4. 如何定位bug？ 思路层面 4.1. 定位bug总体原则 原则1：最好的情况，能找到一个没有bug的环境（如何能找到，已经成功了一大半）： ​ 比如： 其他设备、其他仓代码、其他应用、其他人的环境 原则2：在定位问题之前，先初步界定 问题的范围（目的在于：正向定位太细太耗时间，缩小范围可以大大缩短时间）： ​ 比如显示问题，是Activity级别的，window级别的，还是view级别的 原则3：第一要义是改值坐实，最后的最后才分体深层次原因 --------> 目的：还是缩小范围，不浪费正向定位的精力 ​ 比如：弹框没谈出来，涉及到很多状态。可以直接debug动态修改标志数值，来验证哪一个影响了。最后才追溯 标志值的来源，为什么是这个值，以及判定的代码逻辑（一般很长，没必要读） 原则:4：正向定位时，先从主干、核心节点入手。看流程是否完整。 ​ 比如显示问题，首要的是：activiy生命周期是否完整 原则5：解耦 + 化简。我们永远不可能理解复杂的东西。 ​ 化简之排除干扰------------闪屏问题：关闭动画 ​ ------------ 抓log，先清一把； debug时，先把之前应用杀掉，从头再来（保证环境一致） 原则6： 尽量做化简，无论是不是问题的根因、无论是否有影响： ​ 先列举所有可能影响因素 ​ 为啥我想不到要关闭动画？ 原则7：断点和log，作为定位的第一步，是灾难性质的 ​ 因为纵向，陷入细节，太费精力 4.2. 显示问题定位 上面总体原则 4.3. 闪屏问题定位： 1、化简之排除干扰 ---------> 关闭动画： 法一：开发者选项里，关闭动画 法二： 反射方法，破坏系统动画功能 ----------> 这是一种万能方法 # 在WMS流程中 2、winscope，见winscope章节 4.4. 缺少应用代码的情况下的定位 1、反编译 TODO: 反编译技能 2、framework ap层本身就可以断点 3、纯APP进程的APP层代码，可否无源码调试？ console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/Docker.html":{"url":"coding/Tool/Docker.html","title":"Docker","keywords":"","body":"1. 目录2. docker2.1. docker账号：2.2. 目前使用的版本2.2.1. images版本2.2.2. docker版本2.3. docker安装配置2.3.1. Docker Desktop 安装2.3.2. 安装后，修改docker的镜像目录 2.3.3. 源的配置---> 可选2.4. 教程链接2.5. docker 代理配置2.5.1. 法一： Ubuntu内部设置代理2.5.2. 法二： 宿主win给 Ubuntu共享代理网络2.6. docker命令2.6.1. docker启动：2.6.2. 挂载磁盘2.6.3. ssh链接2.6.4. 账号2.6.5. docker commit（禁止使用）2.6.6. Dockerfile 定制镜像2.6.7. 合并镜像层 squash2.6.8. docker puase2.6.9. Docker 容器连接的优化：2.6.10. 远端2.6.11. docker网站，2.6.12. 下载别人的镜像2.6.13. 镜像保存成jar到本地2.6.14. docker rmi 删除镜像2.6.15. 磁盘overlay满了2.7. error2.7.1. docker报错:图标变红 方法1：2.7.2. 启动异常报错--》方法2:2.7.3. 启动异常报错 方法3:（优）2.7.4. 启动异常报错 方法4:（极优）2.8. docker连 主机pc连的安卓设备2.9. docker容器安装图形桌面2.9.1. 问题1：VNC连不上的2.9.2. 关于VNC 客户端的选择2.10. 剪切板复制 docker与win2.10.1. 报错与解决办法2.11. 一些环境规定：2.12. 关于docker网络的几个概念区分：2.13. 优化TreeviewCopyright © aleen42 all right reserved, powered by aleen42 docker docker账号： 目前使用的版本 images版本 docker版本 docker安装配置 Docker Desktop 安装 安装后，修改docker的镜像目录 源的配置---> 可选 教程链接 docker 代理配置 法一： Ubuntu内部设置代理 方法一步骤 配置核心执行文件 订阅配置 最终结果： 遇到的问题： 基于方法一，给Ubuntu配置系统全局代理---一个终端(临时) 基于方法一，给Ubuntu配置系统全局代理---持久化 基于方法一，Ubuntu下浏览器链接代理 基于方法一，Ubuntu下clion链接代理 法二： 宿主win给 Ubuntu共享代理网络 docker命令 docker启动： 挂载磁盘 ssh链接 账号 docker commit（禁止使用） Dockerfile 定制镜像 关于Dockerfile详细说明： 合并镜像层 squash docker puase Docker 容器连接的优化： 远端 docker账号登录：docker login docker push docker网站， 下载别人的镜像 镜像保存成jar到本地 docker rmi 删除镜像 磁盘overlay满了 error docker报错:图标变红 方法1： 启动异常报错--》方法2: 启动异常报错 方法3:（优） 启动异常报错 方法4:（极优） docker连 主机pc连的安卓设备 docker容器安装图形桌面 问题1：VNC连不上的 关于VNC 客户端的选择 剪切板复制 docker与win 报错与解决办法 一些环境规定： 关于docker网络的几个概念区分： 优化 1. 目录 [TOC] 2. docker 官方文档是学习一门新技术的灯塔 官方用户手册 https://docs.docker.com/docker-for-windows/#file-sharing 2.1. docker账号： ID chen85 1519........ 2.2. 目前使用的版本 2.2.1. images版本 每个版本增加什么功能！！！！！ 2.2.2. docker版本 原始安装版本以及更新后的版本： docker version 2021年10月： 2022年11月： 2.3. docker安装配置 2.3.1. Docker Desktop 安装 分为WSL2方式和 Hyper-v方式 注意：install required windows components for WSL 2 不要勾选 原因在于：上面勾选了WSL 2, 后面 setting中配置 resources只能用 .wslconfig 文件来配置了 ​ 1、不勾选 WSL 2 --->使用的是Hyper-V ---> 界面配置： ​ 2、勾选 ---> 使用的是WSL 2 ---> .wslconfig 文件配置 2.3.2. 安装后，修改docker的镜像目录 跟版本有关！！！！！！！ 其他版本可能可以用： mklink /J \"C:\\Users\\Public\\Documents\\Hyper-V\\Virtual Hard Disks\" E:\\docker\\Hyper-V docker的配置文章： https://www.it610.com/article/1290832596699258880.htm https://www.runoob.com/docker/docker-mirror-acceleration.html https://blog.csdn.net/whatday/article/details/86770609 https://www.cnblogs.com/brock0624/p/9792203.html 2.3.3. 源的配置---> 可选 { \"builder\": { \"gc\": { \"defaultKeepStorage\": \"20GB\", \"enabled\": true } }, \"registry-mirrors\": [ \"https://registry.docker-cn.com\", \"http://hub-mirror.c.163.com\", \"https://docker.mirrors.ustc.edu.cn\" ], \"experimental\": true, \"features\": { \"buildkit\": true } } 2.4. 教程链接 https://yeasy.gitbook.io/docker_practice/image/build docker入门到实践 https://docs.docker.com/engine/reference/commandline/image_build/ 官方文档，包括所有命令参数 https://docs.docker.com/desktop/ 2.5. docker 代理配置 2.5.1. 法一： Ubuntu内部设置代理 （与宿主win无关） docker run ^ -p 127.0.0.1:10000:22 ^ -p 127.0.0.1:15901:5901 ^ --cap-add SYS_ADMIN --device /dev/fuse ^ -t -i -v I:\\dockerSharedFiles:/home/chengang/workingSpace/local ^ -v H:\\dockerSharedFiles_Gpan\\dockerSharedFiles_Gpan:/home/chengang/workingSpace/local2 %imagesId% /bin/bash // --cap-add SYS_ADMIN --device /dev/fuse 作用： qv2ray会使用到fuse，见 https://stackoverflow.com/questions/48402218/fuse-inside-docker https://stackoverflow.com/questions/51263555/riofs-fuse-device-not-found 教程：TODO: 完善自己的 https://bwfish.xyz/archives/linux%E4%B8%AD%E5%8F%AF%E7%94%A8%E7%9A%84%E6%9C%BA%E5%9C%BA%E5%B7%A5%E5%85%B7qv2ray. https://www.zsxcool.com/7137.html 方法一步骤 配置核心执行文件 订阅配置 最终结果： 注意：方法一的关键点：ping的时间在100ms左右。否则，打开Google非常卡，有时候打不开；Clion用不了 遇到的问题： 脚本执行后，卡在这个位置 解决办法：新开一个terminal， 再次执行： sudo ./Qv2ray-v2.7.0-linux-x64.AppImage # if clinet UI does apper, try sudo ./Qv2ray-v2.7.0-linux-x64.AppImage again 有时候遇到界面没有跳出来，需要手动点开： 基于方法一，给Ubuntu配置系统全局代理---一个终端(临时) todo： 是不是clion和浏览器就不用配置了？-----> 测试浏览器不是 参考：Ubuntu设置全局socks代理 https://blog.csdn.net/weixin_45033342/article/details/118075525?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-118075525-blog-128040047.pc_relevant_3mothn_strategy_recovery&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7EBlogCommendFromBaidu%7ERate-1-118075525-blog-128040047.pc_relevant_3mothn_strategy_recovery&utm_relevant_index=2 export ALL_PROXY='socks5://127.0.0.1:1089' //验证 curl http://www.baidu.com curl http://www.google.com curl https://www.google.com 取消设置的代理 unset ALL_PROXY 基于方法一，给Ubuntu配置系统全局代理---持久化 # 配置代理 编辑vi ~/.bashrc，增加代理配置 ----> 持久化 export http_proxy=\"127.0.0.1:8889\" export https_proxy=\"127.0.0.1:8889\" 或 export ALL_PROXY='socks5://127.0.0.1:1089' 注意： 此处在bashrc中配置了HTTP代理，但它可能会影响那些需要访问本地网络的bash命令行工具的使用。譬如：kubernetes集群客户端工具kubectl。在开启代理的情况下，kubectl无法顺利连接到APIServer，需要unset http_proxy和https_proxy两个环境变量，才可恢复正常。 基于方法一，Ubuntu下浏览器链接代理 基于方法一，Ubuntu下clion链接代理 2.5.2. 法二： 宿主win给 Ubuntu共享代理网络 ----> TODO: 不知道怎么用的 2.6. docker命令 2.6.1. docker启动： docker images -a 暂时不用： docker run -t -i eca1757c6d5c /bin/bash 2.6.2. 挂载磁盘 主机F:\\shareFiles挂载到/home/chen目录下 docker run -t -i -v F:\\shareFiles:/home/chen/workingSpace/local f2bab1877e15 /bin/bash 前提： 下面命令，包括：挂载，以及ssh ------------>常用链接 需修改： 13874e71186c docker run -p 10000:22 -t -i -v G:\\dockerSharedFiles:/home/chen/workingSpace/local -v H:\\dockerSharedFiles_Gpan\\dockerSharedFiles_Gpan:/home/chen/workingSpace/local2 403c641a0264 /bin/bash ----》目前：10000需要改成20000 注意：需设置 2.6.3. ssh链接 关于ssh链接： https://blog.csdn.net/Leo_csdn_/article/details/96150534?utm_medium=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param&depth_1-utm_source=distribute.pc_relevant.none-task-blog-BlogCommendFromMachineLearnPai2-3.channel_param https://blog.csdn.net/qq_37955980/article/details/83044482 docker学习之ssh连接 https://blog.csdn.net/vincent2610/article/details/52490397?utm_medium=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-BlogCommendFromMachineLearnPai2-1.channel_param ssh远程连接docker中的container 主机端口：10000 使用MobaXterm远程连接步骤： （1）进入容器并重新开启ssh ----> 每次都需要 [root@68e7598797d7 /] # /usr/sbin/sshd -D & （2）使用MobaXterm远程连接 通过xshell或者其他连接工具进行远程连接了，记住，ip是宿主机的IP地址，端口号宿主机上的端口，=即上面端口映射命令中的10000 ！ 注意:主机ip很容易变动！！！！ MobaXterm设置：框内是主机的ip，即是IPV4 2.6.4. 账号 user：cheng 密码：151937Cgkent. root账号密码：151937Cgkent. 注意：最初cmd窗口就是root 2.6.5. docker commit（禁止使用） docker退出 docker ps -l docker commit 7a96e91 newName: v2 Ubuntu镜像 规定提交的格式为： 1、 docker tag 1be049d70e93 chen85/ubuntu16.04_aosp1000_r17:v1 ---》这个是docker hub push识别的格式 2、或：docker commit 7a96e91 chen/ubuntu16.04_aosp1000_r17:v1 禁止原因： docker commit 制作镜像，以及后期修改的话，每一次修改都会让镜像更加臃肿一次，所删除的上一层的东西并不会丢失，会一直如影随形的跟着这个镜像，即使根本无法访问到。这会让镜像更加臃肿。 2.6.6. Dockerfile 定制镜像 docker build使用 Dockerfile 定制镜像 ---》防止image臃肿 #H:\\docker_anzhuang2\\Dockerfile FROM chen85/ubuntu16.04_aosp1000_r17:v1 RUN echo '这是一个本地构建的nginx镜像' > /home/chen/index.html 在 Dockerfile 文件所在目录执行： docker build -t chen85/ubuntu16.04_aosp1000_r17:v2 . 关于Dockerfile详细说明： 概念： 技巧：用一个RUN命令替代多个 ---> 产生一个层 FROM debian:stretch RUN apt-get update RUN apt-get install -y gcc libc6-dev make wget RUN wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" RUN mkdir -p /usr/src/redis RUN tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 RUN make -C /usr/src/redis RUN make -C /usr/src/redis install 正确： FROM debian:stretch RUN set -x; buildDeps='gcc libc6-dev make wget' \\ && apt-get update \\ && apt-get install -y $buildDeps \\ && wget -O redis.tar.gz \"http://download.redis.io/releases/redis-5.0.3.tar.gz\" \\ && mkdir -p /usr/src/redis \\ && tar -xzf redis.tar.gz -C /usr/src/redis --strip-components=1 \\ && make -C /usr/src/redis \\ && make -C /usr/src/redis install \\ && rm -rf /var/lib/apt/lists/* \\ && rm redis.tar.gz \\ && rm -r /usr/src/redis \\ && apt-get purge -y --auto-remove $buildDeps 到这一组命令的最后添加了清理工作的命令，清理了所有下载、展开的文件，并且还清理了apt 缓存文件 2.6.7. 合并镜像层 squash --squash --> Squash newly built layers into a single new layer 优点：1、把Image多层变成一层，合并多个commit，有效减小体积！ docker build --squash -t chen85/ubuntu16.04_aosp1000_r17:v4 . ---》默认使用了Dockerfile，需要修改 2、docker history 076f7dad0851 信息并没有减 查看层数： 2.6.8. docker puase docker pause/unpause 不用时，docker puase ---》 sleep所有进程 ------》极大的降低CPU使用率 2.6.9. Docker 容器连接的优化： 原始： docker run ^ -p 10000:22 ^ -p 15901:5901 ^ -t -i -v G:\\dockerSharedFiles:/home/chengang/workingSpace/local ^ -v H:\\dockerSharedFiles_Gpan\\dockerSharedFiles_Gpan:/home/chengang/workingSpace/local2 4753178ab18f /bin/bash MobaXterm链接时的ip使用主机的： 对应运行的 优化： docker run ^ -p 127.0.0.1:10000:22 ^ -p 127.0.0.1:15901:5901 ^ -t -i -v G:\\dockerSharedFiles:/home/chengang/workingSpace/local ^ -v H:\\dockerSharedFiles_Gpan\\dockerSharedFiles_Gpan:/home/chengang/workingSpace/local2 4753178ab18f /bin/bash MobaXterm链接时的ip使用主机的127.0.0.1，固定！！！！ 相当于有一层代理，具体使用时，不用管具体ip是多少 对应运行的 2.6.10. 远端 docker账号登录：docker login chen85 docker push docker push tag 1be049d70e93 chen85/ubuntu16.04_aosp1000_r17:v1 见：https://www.cnblogs.com/kevingrace/p/9599988.html 通过容器提交镜像（docker commit）以及推送镜像（docker push）笔记 下载 2.6.11. docker网站， 类似gitHub https://hub.docker.com/ 2.6.12. 下载别人的镜像 docker pull wangshibo/myubuntu:v1 2.6.13. 镜像保存成jar到本地 https://blog.csdn.net/qq_37797234/article/details/103660748 保存镜像到本地！！！！ docker save ubuntu16.04_0902 -o E:\\docker\\ubuntu16.04_0902.jar docker save chengang/ubuntu16.04_aosp1000_r17:vnc_ok -o H:\\docker_jarFiles\\ubuntu16.04_aosp1000_r17_vnc_20221026.jar 加载本地镜像 C:\\Users\\xixi>docker load -i F:\\VirtualMachine\\Docker\\ubuntu.tar 2.6.14. docker rmi 删除镜像 方法一：通过imageID： docker rmi ee7cbd482336 删除镜像难以删除的情况： 1、一个ImageID 对应多个 repositories： 删除方法（优）： 注意：不能在cmd下运行 docker rmi chen85/ubuntu16.04_aosp1000_r17:v1 2、被正在运行的容器关联了： container 368027944f2e is using its referenced image 方法：删除所有容器，再删image docker stop $(docker ps -a -q) #全关 docker rm $(docker ps -a -q) #删除全部容器 docker rmi ubuntu16.04_aosp1000_r17:latest #删除image 2.6.15. 磁盘overlay满了 (1)docker system prune ----> 清除不用的镜像和缓存，慎用！！！ https://www.cnblogs.com/wswang/p/10736726.html （3)删？？？？‪ (2) https://segmentfault.com/q/1010000020545464 https://www.jianshu.com/p/9174914ec07d 2.7. error 2.7.1. docker报错:图标变红 方法1： cmd报错：open //./pipe/docker_engine: The system cannot find the file specified. 解决方法： 重置配置，，，，再重启电脑！ reset to factory defaults ----> 规定：后面不准用这种方法，会造成setting改变 2.7.2. 启动异常报错--》方法2: 运行docker出现System.InvalidOperationException错误 解决办法： 1.管理员方式运行cmd 2.输入命令：netsh winsock reset 3.重新启动Docker 4.重新switch to Linux Containers 5.成功 技巧，特别注意： 此时，应该所有的image都没有了。尽量不要重新load image，应该把这个文件复制到setting目录下面 移动文件需要everyone权限 2.7.3. 启动异常报错 方法3:（优） reset to factory defaults仍然报错 ----> 规定：后面不准用这种方法，会造成setting改变 ---》技巧：不要重新装docker软件 关闭docker，重启win，删除DockerDesktop.vhdx，启动docker ----》docker会自动生成 优点：不用重新装docker，setting不会变 2.7.4. 启动异常报错 方法4:（极优） 1、备份好的DockerDesktop.vhdx 2、基于方法3，恢复环境 3、copy .vhdx至目录下，重启 ----> 优化了load jar的时间 TODO: 以后备份都用.vhdx？ 而不是jar？ 2.8. docker连 主机pc连的安卓设备 1、宿主为windows： https://testerhome.com/topics/8049 https://blog.csdn.net/qq_42693848/article/details/109505849 使用方法 ​ 宿主windows侧：起服务 安装 nodejs 推荐使用 nvm 安装： http://events.jianshu.io/p/5db570f53e6a win10中使用nvm安装nodejs遇到的坑整理 ------> ==很好的教程== 安装 adbkit $ npm i -g adbkit 启动 usb 转 tcp 服务 $ adbkit usb-device-to-tcp -p $port $serial // serial是手机序列号 比如：adbkit usb-device-to-tcp -p 7788 FA6930305260 docker侧：连接服务 在docker侧（装有 adb 的机器上）进行设备的连接 假设启动 adbkit 服务的机器 ip 是 10.0.0.1 端口是 15555 ----> ip试了HOST的真实ip，以及 $ adb connect 10.0.0.1:7788 ​ 万能方法： 为了方便docker提供了专门的标志表示母机的ip：host.docker.internal ​ 见：https://blog.csdn.net/qq_42693848/article/details/109505849 adb connect host.docker.internal:$port adb connect host.docker.internal:7788 其他注意事项 adb连接手机默认使用的是5037，母机与容器交互的接口无法在使用该端口，需要选择其他端口。 2、宿主linux：https://stackoverflow.com/questions/29563183/connecting-to-a-usb-android-device-in-a-docker-container-via-adb 2.9. docker容器安装图形桌面 VNC远程win： tigervncserver -vncClient 参考： https://blog.csdn.net/lxyoucan/article/details/121679346 视频教程：https://www.bilibili.com/video/BV1mL41177Av 总之，使用： docker run ^ -p 10000:22 ^ -p 15901:5901 ^ -t -i -v G:\\dockerSharedFiles:/home/chen/workingSpace/local ^ -v H:\\dockerSharedFiles_Gpan\\dockerSharedFiles_Gpan:/home/chen/workingSpace/local2 8ea41f5aa2f9 /bin/bash :: /usr/sbin/sshd -D & :: -p 10000:22 用于ssh登录 ---》使用win ip + 10000 ： 192.168.1.4:10000 :: -p 15901:5901 用于VNC界面登录 ---》使用win 的Ethernet adapter ip + 15901: 172.18.28.1:15901 或 127.0.0.1::15901 ----》 永恒不变 注意点： 1、关于vnc链接的ip ： 使用win 的Ethernet adapter ip 登录： 2.9.1. 问题1：VNC连不上的 报错：connection closed 操作方法： // 1、重启一下服务试试 vncserver -kill :1 vncserver -kill :2 vncserver -kill :3 vncserver -kill :4 vncserver :1 -localhost no -geometry=1920x1080 // 2、如果上述不行，看有没有提示： Warning: 4fcb1df56031:1 is taken because of /tmp/.X1-lock ----》删掉这个文件 Remove this file if there is no X server 4fcb1df56031:1 2.9.2. 关于VNC 客户端的选择 1、TurboVNC Viewer（优） 可以双屏 全屏切换快捷键 ALT + Enter 2、集成了TurboVNC Viewer的 MobaXterm 有些问题：必须全屏 + stay on TOP 有些快捷键才生效； 复制粘贴 偶现问题 2.10. 剪切板复制 docker与win https://zhuanlan.zhihu.com/p/518188941 VNC 复制粘贴中文乱码问题及解决方案 https://unix.stackexchange.com/questions/35030/how-can-i-copy-paste-data-to-and-from-the-windows-clipboard-to-an-opensuse-clipb 结合两个帖子： vim ~/.vnc/xstartup #加入： # win --> docker vncconfig -nowin & vncconfig -iconic & autocutsel -fork& 注意： 1、重启一个vnc服务 2.10.1. 报错与解决办法 vnc: failed to open clipboard https://blog.csdn.net/qq_39590599/article/details/116228624 2.11. 一些环境规定： docker 命令必须在bash环境下执行，不能用cmd（除了启动的） 2.12. 关于docker网络的几个概念区分： 1、使用的网络类型是bridge，桥接的宿主网络(组成局域网) （1）在容器外使用时： moba连接时，用的127.0.0.1，为啥？ -----> 因为原先用的宿主的ip，宿主ip对于寄生的docker就是127.0.0.1 （2）在容器内使用时： 必须用宿主机的绝对ip，不能是127.0.0.1？-----> 因为在内部，相对ip172是其自己 2、使用--network=host，这样的话使用 -p 参数映射端口就没用了， 即所有端口都是开放和宿主机共享的 （2）在容器内使用时： 能用127.0.0.1 -----> 因为127是自己 ，也是host，共享的端口 代理软件： 本地 关系：AS对win是本地的关系; AS对docker 容器 moba对win是本地的关系 局域网关系： docker内部对win 2.13. 优化 自动保存 DockerDesktop.vhdx 脚本 ：vhdx_backup.bat ---> 不影响docker 容器unbuntu正常工作的，可以白天经常做 自动build、save、load脚本：docker_build_save_load.bat ---> 必须晚上 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/git.html":{"url":"coding/Tool/git.html","title":"Git","keywords":"","body":"1. 结构：2. git2.1. 两个节点之间差异2.2. 本地有代码修改，如何 rebase 主干(或其他分支):2.3. git push2.4. 配置git + 查看已经配置2.5. 关于git push 443链接 报错：3. 参考：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 git 两个节点之间差异 本地有代码修改，如何 rebase 主干(或其他分支): git push 配置git + 查看已经配置 关于git push 443链接 报错： 参考： 1. 结构： 参考： https://www.zhihu.com/question/38305012 可见： fech获取时，并未合并到本地仓库 --------> 推论：cherry-pick需要的commiId，可以利用fech获取 2. git git reflog -----------历史上所有的commit（即使被删除了、即使被修改了） ​ 记录了所有引起HEAD指针变化的原因：真正commit、或reset、或checkout 或 pull 或 merge 或 clone 如何读reflog？ （1）新增一笔提交 7ace9e6282a9 （2）reset: moving to 4bd4cf2ac7dd （自然from 7ace9e6282a） （3）cherry-pick test 节点（自然，形成新节点） 范围： 参考： https://www.jianshu.com/p/7e4cef3863e7 git commit 技巧： git commit --amend --no-edit -----> 不会弹出commit message (reusing the previous one) 在 bash中自定义 见《任意ide（As 或 clion 等）, 默认 Terminal 如何使用 bash?》 //.myfunction.sh #!/bin/bash #git_rebase function g_pu0 { export a=$(git rev-parse --abbrev-ref HEAD) # git.exe push --progress \"origin\" $a:$a #注意第一个a是本地分支名，第二个是远程分支名: feature/xa_powerterminal:feature/xa_power } function g_pul { export a=$(git rev-parse --abbrev-ref HEAD) git.exe push --force-with-lease --progress \"origin\" $a:$a } function g_re_f{ #获得某个分支所对应的远程分支 export a=$(git rev-parse --abbrev-ref --symbolic-full-name @{u}) git.exe fetch -v --progress \"origin\" git clean -d -fx #git fetch --all git reset --hard HEAD~5 #仓有问题的话,有垃圾文件,直接 rebase 远端,可能会冲突。先 reset 本地--->强制 git reset --hard $a #仓有问题的话,有垃圾文件,直接 rebase 远端,可能会冲突。先 reset 本地--->强制 rebase remotesBranch=\"remotes/\"$a #shell拼接字符串 git rebase $remotesBranch } function g_re{ #获得某个分支所对应的远程分支 #git fetch --all git.exe fetch -v --progress \"origin\" export a=$(git rev-parse --abbrev-ref --symbolic-full-name @ {u}) git rebase $remotesBranch remotesBranch=\"remotes/\"$a git rebase $remotesBranch } function g_co{ git commit -m \"修改\" } function g_he{ echo \"git.exe fetch -v --progress \"origin\"\" echo \"git log-graph\" echo \": git rev-parse --abbrev-ref--symbolic-full-name @{u}\" echo \"dos2unix unix2dos filename\" echo \"删除 git 没有track的文件:git clean -d -fx\" echo \"git checkout -b feature/master_enterprise2 remotes/origin/master\" echo \"推送： git push -u origin feature/master_local:main -f; 本地分支：远程分支获取：git branch -a\" echo \"=========commit===============\" echo \"git commit -m \"TraceNo.:REQ20220“\" echo \"git commit --amend --no-edit -----> 不会弹出commit message (reusing the previous one)\" echo \"删除某个commit: git rebase -i 9fd15a8880fc41290d7dc^ 修改pick为drop\" echo \" commit: git rebase -i HEAD~4 s\" echo \"任意调整 commit顺序、任意合并: git rebase -i commitID,id之后的所有commit\" } function g_st { git status } function g_fe { git fetch } function g_co_am { git commit --amend } 总结: git restore 文件名 会撤销到缓存区(如果有,add区域) 或者 当前版本库版本(commit区) git命令回退 某个文件 到指定的版本： git chekcout 版本号 文件 如何合并？TODO git大文件： git Ifs pull // 下载大文件 git lfs uninstall 管理: 硬件十几个人对软件一个人,提十几个单,修改txt ----------> 应该让硬件出一个人,软件只对接这个一个人。硬件单提一个 2.1. 两个节点之间差异 git diff 8064cff987043e2272746a46e3240e4ea7336e5b 3e62c71ee5dd6c714fc0bdeaa7faf0a2aa226e91 > /1111.txt 两个节点之间差异, 提取所有文件名: git diff 8064cff987043e2272746a46e3240e4ea7336e5b 3e62c71ee5dd6c714fc0bdeaa7faf0a2aa226e91 --name-only >./1111.txt 2.2. 本地有代码修改，如何 rebase 主干(或其他分支): 方法一: 新建一个分支(可行): git fetch (必须把远端的拉下来) git checkout -b feature/sh_c111111_x214 remotes/origin/master pick之前分支的修改 方法二 (优选): git fetch (把远端的拉下来,本质: 拉到本地,但是没有合入到本地, git log 不变---》git fetch 对代码没有任何影响) git rebase origin/master (当前分支的base,同步到本地的 origin/master) 验证:git log, 代码跟新到新, 而且自己的 commit 在第一个 方法三: 命令的小乌龟界面操作: 拉取+小乌龟界面rebase (找到 head origin,右键 rebase) 2.3. git push 提交代码： git.exe push --progress \"origin\" 本地分支:远程分支 本地分支:远程分支 由 git branch -a 查得 注意： 没有本地分支时（安卓开发中多见），提交代码： git push origin HEAD:refs/for/branch_master ----》以HEAD替代本地分支？ 2.4. 配置git + 查看已经配置 参考： https://blog.csdn.net/lovedingd/article/details/121288974 主要配置有： 1、user.name、user.email 2、proxy配置 查看配置： 1、git config --list 2、 .gitconfig文件 2.5. 关于git push 443链接 报错： fatal: unable to access 'https://github.com/KentTJ/-book.git/': Recv failure: Connection was reset 或 fatal: unable to access 'https://github.com/KentTJ/-book.git/': Failed to connect to github.com port 443 参考： https://blog.csdn.net/qq_42777433/article/details/129026998?spm=1001.2101.3001.6650.1&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129026998-blog-123270948.235%5Ev38%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-129026998-blog-123270948.235%5Ev38%5Epc_relevant_default_base3&utm_relevant_index=2 git config --global http.proxy http://127.0.0.1:7890 git config --global https.proxy http://127.0.0.1:7890 3. 参考： https://blog.csdn.net/renfeideboke/article/details/130930418?spm=1001.2101.3001.6661.1&utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-130930418-blog-120540819.235%5Ev38%5Epc_relevant_anti_t3&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-1-130930418-blog-120540819.235%5Ev38%5Epc_relevant_anti_t3&utm_relevant_index=1 Git创建本地分支并关联远程分支 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/phoneCommand.html":{"url":"coding/Tool/phoneCommand.html","title":"Phone Command","keywords":"","body":"1. 手机命令1.1. 参考：1.2. 编译替换1.3. 手机恢复系统1.4. 删除开机向导：1.5. 页面 --> 包名 -> apk之间的关系1.6. 环境中 查看系统版本：1.7. 安卓log的添加：1.8. 抓log1.8.1. 实时log1.8.2. log脚本1.9. 软件唯一，核心法则--------结构：1.10. 关于整个屏幕结构的dump、观察1.10.1. Activity的结构1.10.2. window的结构1.10.3. viewTree的结构观察：1.11. 安卓的dump工具详解1.11.1. AMS的dump1.11.2. WMS的dump1.11.3. 推论：获取当前 最前面activty的脚本：1.11.4. 原理1.12. adb查看手机是32位还是64位1.13. ADB网络wifi调试和常见命令1.13.1. 最简单的方法1.13.2. 重启后依然有效方法1.14. DropBox1.15. adb命令行：1.16. UIAutomator2自动化（操作手机）1.16.1. 环境配置1.16.2. 操作命令：1.17. 计算云连真机2. 手机环境问题2.1. adb 授权3. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 手机命令 参考： 编译替换 手机恢复系统 删除开机向导： 页面 --> 包名 -> apk之间的关系 环境中 查看系统版本： 安卓log的添加： 抓log 实时log log脚本 软件唯一，核心法则--------结构： 关于整个屏幕结构的dump、观察 Activity的结构 window的结构 viewTree的结构观察： 安卓的dump工具详解 AMS的dump WMS的dump 文件结构 dumpsys window lastanr dumpsys window displays dumpsys window windows 推论：获取当前 最前面activty的脚本： 原理 adb查看手机是32位还是64位 ADB网络wifi调试和常见命令 最简单的方法 重启后依然有效方法 DropBox adb命令行： UIAutomator2自动化（操作手机） 环境配置 操作命令： 计算云连真机 手机环境问题 adb 授权 格式 [TOC] 1. 手机命令 1.1. 参考： https://droid10.com/Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ 1.2. 编译替换 adb root adb remount adb shell rm -rf /system/framework/arm adb shell rm -rf /system/framework/arm64 adb shell rm -rf /system/framework/oat/ adb push framework.jar /system/framework adb push services.jar /system/framework adb push libbinder.so /system/lib pause adb reboot -注意： 删除这个目录下面的oat，arm，arm64三个目录(不删除会一直卡在开机动画) 1.3. 手机恢复系统 adb shell rm -rf cache/overlay 手机恢复系统 》piexl不起作用 ----》HW手机有作用！！！！！！包括system下的，以及预支apk 1.4. 删除开机向导： EMUI： adb shell settings put secure hw_suw_frp_state 0 adb shell pm disable com.huawei.hwstartupguide 海外版本：（安卓原生） 删除云空间：(为什么要删除它呢？因为dump出来，激活界面是它的！！！！！！) adb shell rm -rf /system/app/HwCloudDrive/HwCloudDrive.apk 1.5. 页面 --> 包名 -> apk之间的关系 当前页面，如何找到当前页面的包名? :adb shell dumpsys window w | findstr 查看处于当前栈顶的Window和Activity adb shell dumpsys window windows | findstr -E 'mCurrentFocus' adb shell dumpsys activity | grep mFocusedActivity 由包名-----》apk路径： HWLIO:/system/priv-app # pm path com.huawei.hidisk package:/system/app/HwCloudDrive/HwCloudDrive.apk 1.6. 环境中 查看系统版本： 1、手机上直接查看： 2、命令： 1.7. 安卓log的添加： import android.util.Log; Log.i(TAG, \"chen, loadKeyboard start\"); Log.i(TAG, \"chen, loadKeyboard\" + System.identityHashCode(Object)); Log.i(TAG, \"chen, loadKeyboard\" + Log.getStackTraceString(new Throwable())); // 调用栈 System.out.println(System.identityHashCode(Object)) adb shell dumpsys window //native // 引入log头文件 #include // log标签 #define TAG \"chen1_native\" // 定义info信息 #define LOGI(...) __android_log_print(ANDROID_LOG_INFO,TAG,__VA_ARGS__) // 定义debug信息 #define LOGD(...) __android_log_print(ANDROID_LOG_DEBUG, TAG, __VA_ARGS__) // 定义error信息 #define LOGE(...) __android_log_print(ANDROID_LOG_ERROR,TAG,__VA_ARGS__) LOGI(\"chen, array.length:%d\", len); android::CallStack cs(\"***********Parcel::initState(), chen***********\") native调用栈 https://blog.csdn.net/u013120422/article/details/108485664 #include \"utils/CallStack.h\" android::CallStack cs(\"***********Parcel::initState(), chen***********\") LOGI(\"array.length:%d\", len); shared_libs: [ \"libbase\", \"liblog\", \"libcutils\", \"libutils\", \"libbinderthreadstate\", \"libutilscallstack\", //引用动态库 ], 1.2、引用动态库 Andorid O以上 Android.mk: LOCAL_SHARED_LIBRARIES里包含libutilscallstack Android.bp: shared_libs里包含libutilscallstack //--->这里 Android O Android.mk: LOCAL_SHARED_LIBRARIES里包含libutils Android.bp: shared_libs里包含libutils Android N 以前版本 Android.mk: LOCAL_SHARED_LIBRARIES里包含libutils 原文链接：https://blog.csdn.net/u013120422/article/details/108485664 1.8. 抓log 1.8.1. 实时log adb shell logcat -c //清理 adb shell logcat -v time > C:\\Users\\Administrator\\Desktop\\logcat.txt 1.8.2. log脚本 adb remount adb root adb devices -l if \"%l\"\"\"( for /f \"skip=1 tokens=1\" %%i in ('adb devices-l') do ( move %%i \"%%i\"bk adb -s %%i shell setprop persist.sys.hilog.debug.on true adb -s %%i shell setprop debug.ld.all dlerror,dlopen adb-s %%i pull datalog %%i adb-s %%i pull datatombstones %%i adb-s %%i logcat > %%i.txt ) ) pause 抓crash脚本： todo 全集脚本，getLogs.bat： 参考： https://droid10.com/Android/Android%E5%9F%BA%E7%A1%80%E6%93%8D%E4%BD%9C/ adb root set d=%date:~0,4%%date:~5,2%%date:~8,2% if %time:~0,2% LEQ 9 (set t=0%time:~1,1%%time:~3,2%%time:~6,2%) else (set t=%time:~0,2%%time:~3,2%%time:~6,2%) echo %d%-%t% mkdir Log-%d%-%t% cd Log-%d%-%t% adb shell ps -A > ps.txt :: ::adb shell am dumpheap 1051 /data/local/tmp/system-server.hprof :: 安装GitBash, 并将C:\\Program Files\\Git\\usr\\bin 加到环境变量 :: grep system_server ps.txt | awk \"{print $2}\" | xargs -I {} echo adb shell am dumpheap {} /data/local/tmp/system-server.hprof > tmp.bat ::echo adb pull /data/local/tmp/system-server.hprof >> tmp.bat ::echo adb shell rm /data/local/tmp/system-server.hprof >> tmp.bat ::grep mediaserver ps.txt | awk \"{print $2}\" |xargs -I {} echo adb shell debuggerd -b {} \"> mediaserver.txt\" >> tmp.bat ::echo exit >> tmp.bat ::start tmp.bat ::cat tmp.bat adb pull /data/logs adb pull /data/anr adb pull /data/tombstones adb pull /data/system/dropbox adb pull /sys/kernel/debug/binder md _dump cd _dump ::adb shell uiautomator dump /data/local/tmp/app.uix ::adb pull /data/local/tmp/app.uix ::dump view的层级 adb shell uiautomator dump --compressed /data/local/tmp/uidump.xml && adb pull /data/local/tmp/uidump.xml adb shell screencap -p /sdcard/app.png adb pull /sdcard/app.png ::dump view的层级 adb shell top -n 1 > top.txt adb shell free -m > free.txt adb shell procrank > procrank.txt adb shell dumpsys > dumpsys.txt ::dumpsys.txt包括了所有的服务 :: 重点的两个服务，AMS 和WMS adb shell dumpsys activity > AMS_dump.txt adb shell dumpsys window > WMS_dump.txt adb shell dumpsys car_service > dumpsys_car_service.txt adb shell dumpsys meminfo system_server > system_server_mem.txt adb shell dumpsys meminfo mediaserver > mediaserver_mem.txt adb shell dmesg > dmsg.txt cd .. adb shell perfetto -o /data/misc/perfetto-traces/trace_file.perfetto-trace -t 30s sched freq idle am wm gfx view binder_driver hal dalvik camera input res memory adb pull /data/misc/perfetto-traces/trace_file.perfetto-trace del tmp.bat cd .. pause 1.9. 软件唯一，核心法则--------结构： 事物本身的结构 --------------------> 对应的代码结构 需要的描述量 事物本身的结构 的变化--------------------> 对应代码结构 描述量的变化 观察点： 事物本身 -----> 最好是肉眼可见的图形化的。。比如view本身、比如google做的view显示工具。截图 dump出代码结构的状态。。比如xml ------> TODO: 从设计的角度理解google的做法，工具、dump、代码结构 中间化的工具，xml变成图形界面，可以点击 -------> 即使利用工具，也要向图形化靠（人对图形理解力 与 文字理解力，不在一个数量级上） 理解事物、理解业务、理解代码、添加维测，最深刻的就是理解结构 ------> 所以，dump出结构是非常重要的。尤其是图形化的结构 （软件唯一，核心法则--------结构） ----> 这也是dump工具背后的思想 所以，整个软件的理解就是： 结构 + 结构的演变（即算法） 再具体一点： Frame1 (结构)--------> Frame2(结构) + 两帧之间变化的算法 再再具体一点： 0 ----> 初始化ok状态， 初始化OK状态-----> 下一阶段状态 所以，我们首要 理解是 结构，其次是基于结构 的演化 举例子1: 如何理解activity1启动activity2的流程？ 我们关注点应该是 调用栈嘛： 流程1-----》流程2----》流程3----》流程4 ？？？ 错误！！！ - 基于结构的认识论：！！ Frame1下（物理界面状态、AMS侧stack状态、task状态，wms侧window的结构的状态） Frame2下（物理界面状态、AMS侧stack状态、task状态，wms侧window的结构的状态） Frame1下状态，到Frame2，是如何变化的？ 1.10. 关于整个屏幕结构的dump、观察 TODO：https://zhuanlan.zhihu.com/p/589688318 透视Android WindowManagerService 1.10.1. Activity的结构 视图结构，见viewTree的结构观察 activity所在位置结构：有哪些维度？ （1）在哪个进程？ （2）在哪个task里，task结构怎么样？ （3）在哪个stack里，stack结构怎么样？ （4）对应的Intent是啥，被谁唤起来的？ （5）尺寸 。。。。。。。。 见《AMS的dump》 1.10.2. window的结构 1.10.3. viewTree的结构观察： 方法一：dump出具体的数字 adb shell uiautomator dump --compressed /data/local/tmp/uidump.xml && adb pull /data/local/tmp/uidump.xml 方法二： 截图，使用dpx测量工具 方法三（极优）： AS工具：Tools ----> Layout Inspector 具体见《systrace.md》 1.11. 安卓的dump工具详解 dumpsys ----总命令： adb shell dumpsys > dumpsys.txt 1、dump出 系统当前的所有正在运行的服务的信息，总共多达67000行（总共170个服务） -----------> （1） dump出来的是 整个系统 ------->十分自然，了解一个系统，就要了解整个系统的frame结构 ​ （2） dump的是服务侧，不是APP侧的数据： ​ 服务侧是所有数据的汇聚处，好一次性dump ​ 服务侧也是各种数据的决定者，最后才同步给APP // dumpsys.txt // 主要的几个： Currently running services: SurfaceFlinger accessibility //----> accessibilityMS activity //----> AMS .............. cpuinfo display dropbox hardware input //----> IMS input_method //----> IMMS .............. window //----> WMS ———————————————— 注意：那么多服务之间，很容易出问题！！！这里也是保证不出问题的关键，保证每一帧dump都OK 每个服务信息之间使用横线间隔 1.11.1. AMS的dump adb shell dumpsys activity > AMS_dump.txt 或从 dumpsys.txt中找： ------------------------------------------------------------------------------- DUMP OF SERVICE activity: -文件分析： 1、文件结构： 搜索 dumpsys，可见是四大组件的管理者：activity、service、broadcast、provider 注：括号里是命令 2、ACTIVITY MANAGER SETTINGS (dumpsys activity settings) ------> 做啥的？TODO 3、ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents) ​ 记录当前待处理的Intent（AMS运行中，有些Intent还没处理完） 场景：TODO ​ 参考： https://blog.csdn.net/zhangjg_blog/article/details/39852309 ACTIVITY MANAGER PENDING INTENTS (dumpsys activity intents) * com.android.providers.calendar: 1 items #0: PendingIntentRecord{b70c970 com.android.providers.calendar broadcastIntent} * com.sohu.inputmethod.sogou: 2 items #0: PendingIntentRecord{72c156e com.sohu.inputmethod.sogou broadcastIntent} #1: PendingIntentRecord{d60d40f com.sohu.inputmethod.sogou broadcastIntent} * com.android.quicksearchbox: 1 items #0: PendingIntentRecord{5710c9c com.android.quicksearchbox startActivity} * com.tencent.mm: 13 items //【】微信发出了13个Intent，AMS还没处理(包括 发送广播的、启动服务的) #0: PendingIntentRecord{b3e1ef4 com.tencent.mm broadcastIntent} #1: PendingIntentRecord{3881a7a com.tencent.mm broadcastIntent} #2: PendingIntentRecord{d60a22b com.tencent.mm startService} #3: PendingIntentRecord{bd05688 com.tencent.mm startService} 4、activity相关的：(dumpsys activity activities) Frame1：在微信主页面 展开 ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities) // 表明是activities Display #0 (activities from top to bottom): //Display 0 因为一个屏幕 Stack #2: type=standard mode=fullscreen // Stack 结构： 类型？全屏模式？ isSleeping=false // 是否在后台？ mBounds=Rect(0, 0 - 0, 0) // 大小 Task id #49 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{c30999d #49 A=com.tencent.mm U=0 StackId=2 sz=1} //【】所处的task？？ userId=0 effectiveUid=u0a133 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 affinity=com.tencent.mm // userId intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.tencent.mm/.ui.LauncherUI} //【】 启动信息: 该actvity被 LAUNCHER 拉起来的 mActivityComponent=com.tencent.mm/.ui.LauncherUI //【】这个actvity实例是 LauncherUI类的实例，是 com.tencent.mm 应用的 autoRemoveRecents=false isPersistable=true numFullscreen=1 activityType=1 // activityType? TODO rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49}] //【】这个actvity实例是 LauncherUI类的实例 askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{b902b90 8627:com.tencent.mm/u0a133} stackId=2 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mSupportsPictureInPicture=false isResizeable=true lastActiveTime=728733 (inactive for 71s) // 【】此时应该可见了 Hist #0: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.tencent.mm/.ui.LauncherUI bnds=[237,84][439,361] } // TODO: 这里和上面什么区别？ ProcessRecord{b902b90 8627:com.tencent.mm/u0a133} Running activities (most recent first): //TODO:什么叫正在运行的？ TaskRecord{c30999d #49 A=com.tencent.mm U=0 StackId=2 sz=1} Run #0: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} mResumedActivity: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} // 【】mResumedActivity，非常重要的标志，标志activity已经真正可见！！！！！！！！ Stack #0: type=home mode=fullscreen // Stack #0 TODO:没有Stack #1？？？ isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #47 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{1c2adb3 #47 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} // 【】launcher的task？？？？ userId=0 effectiveUid=u0a80 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 intent={act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000100 cmp=com.android.launcher3/.Launcher} // launcher的页面是被HOME调起来的，实际上是系统ready mActivityComponent=com.android.launcher3/.Launcher autoRemoveRecents=false isPersistable=true numFullscreen=1 activityType=2 rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47}] askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{5f0411c 1996:com.android.launcher3/u0a80} stackId=0 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE mSupportsPictureInPicture=false isResizeable=true lastActiveTime=719656 (inactive for 80s) Hist #0: ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47}//【】栈中Activity调用历史 Intent { act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000100 cmp=com.android.launcher3/.Launcher } ProcessRecord{5f0411c 1996:com.android.launcher3/u0a80} Running activities (most recent first): TaskRecord{1c2adb3 #47 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} Run #0: ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47} ResumedActivity:ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} ResumedActivity: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} ActivityStackSupervisor state: topDisplayFocusedStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} displayId=0 stacks=2 mHomeStack=ActivityStack{4b0720f stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks} mPreferredTopFocusableStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} mLastFocusedStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} mCurTaskIdForUser={0=49} mUserStackInFront={} isHomeRecentsComponent=true KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false Occluded=false DismissingKeyguardActivity=null at display=0 mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] launcher 把 tencent 拉起来，却不在一个stack里，好像也不在一个task里？？ Frame2：基于Frame1点击搜索 后的页面 展开 ACTIVITY MANAGER ACTIVITIES (dumpsys activity activities) Display #0 (activities from top to bottom): Stack #2: type=standard mode=fullscreen isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #49 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{c30999d #49 A=com.tencent.mm U=0 StackId=2 sz=2} //【】task没有变（都是微信创建的task），因为跳跳跳没有断 userId=0 effectiveUid=u0a133 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 affinity=com.tencent.mm intent={act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.tencent.mm/.ui.LauncherUI} mActivityComponent=com.tencent.mm/.ui.LauncherUI autoRemoveRecents=false isPersistable=true numFullscreen=1 activityType=1 rootWasReset=true mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49}, ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49}] askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{b902b90 8627:com.tencent.mm/u0a133} stackId=2 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE_VIA_SDK_VERSION mSupportsPictureInPicture=false isResizeable=true lastActiveTime=856993 (inactive for 57s) Hist #1: ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49} Intent { cmp=com.tencent.mm/.plugin.fts.ui.FTSMainUI (has extras) } ProcessRecord{b902b90 8627:com.tencent.mm/u0a133} Hist #0: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} Intent { act=android.intent.action.MAIN cat=[android.intent.category.LAUNCHER] flg=0x10200000 cmp=com.tencent.mm/.ui.LauncherUI bnds=[237,84][439,361] } ProcessRecord{b902b90 8627:com.tencent.mm/u0a133} Running activities (most recent first): TaskRecord{c30999d #49 A=com.tencent.mm U=0 StackId=2 sz=2} //【】该task（跳跳跳） 有两个界面： LauncherUI -> FTSMainUI Run #1: ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49} Run #0: ActivityRecord{3c203df u0 com.tencent.mm/.ui.LauncherUI t49} mResumedActivity: ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49} //【】当前界面是 FTSMainUI Stack #0: type=home mode=fullscreen //【】 Stack 0 是launcher，不变 isSleeping=false mBounds=Rect(0, 0 - 0, 0) Task id #47 mBounds=Rect(0, 0 - 0, 0) mMinWidth=-1 mMinHeight=-1 mLastNonFullscreenBounds=null * TaskRecord{1c2adb3 #47 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} userId=0 effectiveUid=u0a80 mCallingUid=u0a80 mUserSetupComplete=true mCallingPackage=com.android.launcher3 intent={act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000100 cmp=com.android.launcher3/.Launcher} mActivityComponent=com.android.launcher3/.Launcher autoRemoveRecents=false isPersistable=true numFullscreen=1 activityType=2 rootWasReset=false mNeverRelinquishIdentity=true mReuseTask=false mLockTaskAuth=LOCK_TASK_AUTH_PINNABLE Activities=[ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47}] askedCompatMode=false inRecents=true isAvailable=true mRootProcess=ProcessRecord{5f0411c 1996:com.android.launcher3/u0a80} stackId=0 hasBeenVisible=true mResizeMode=RESIZE_MODE_RESIZEABLE mSupportsPictureInPicture=false isResizeable=true lastActiveTime=719656 (inactive for 195s) Hist #0: ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47} Intent { act=android.intent.action.MAIN cat=[android.intent.category.HOME] flg=0x10000100 cmp=com.android.launcher3/.Launcher } ProcessRecord{5f0411c 1996:com.android.launcher3/u0a80} Running activities (most recent first): TaskRecord{1c2adb3 #47 I=com.android.launcher3/.Launcher U=0 StackId=0 sz=1} Run #0: ActivityRecord{a4790b1 u0 com.android.launcher3/.Launcher t47} ResumedActivity:ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49} ResumedActivity: ActivityRecord{223ab1e u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t49} ActivityStackSupervisor state: topDisplayFocusedStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} displayId=0 stacks=2 mHomeStack=ActivityStack{4b0720f stackId=0 type=home mode=fullscreen visible=false translucent=true, 1 tasks} mPreferredTopFocusableStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} //【】mHomeStack 用作桌面的 mLastFocusedStack=ActivityStack{bed6e12 stackId=2 type=standard mode=fullscreen visible=true translucent=false, 1 tasks} mCurTaskIdForUser={0=49} //【】最后获焦的stack，即微信产生的那个 mUserStackInFront={} isHomeRecentsComponent=true KeyguardController: mKeyguardShowing=false mAodShowing=false mKeyguardGoingAway=false Occluded=false DismissingKeyguardActivity=null at display=0 mDismissalRequested=false mVisibilityTransactionDepth=0 LockTaskController mLockTaskModeState=NONE mLockTaskModeTasks= mLockTaskPackages (userId:packages)= u0:[] 1.11.2. WMS的dump adb shell dumpsys window > WMS_dump.txt 文件结构 为什么有两个display，不一样？ dumpsys window lastanr dumpsys window displays 展开 WINDOW MANAGER DISPLAY CONTENTS (dumpsys window displays) Display: mDisplayId=0 // 一般只有一个 init=1080x1920 420dpi cur=1080x1920 app=1080x1794 rng=1080x1017-1794x1731 deferred=false mLayoutNeeded=false mTouchExcludeRegion=SkRegion((0,0,1080,1920)) mLayoutSeq=825 // ? mDeferredRotationPauseCount=0 mCurrentFocus=Window{267a445 u0 com.tencent.mm/com.tencent.mm.plugin.fts.ui.FTSMainUI} // 当前是tencent的搜索界面 mFocusedApp=AppWindowToken{afbe8c7 token=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}}} mLastStatusBarVisibility=0x8008 displayId=0 mWallpaperTarget=null mLastWallpaperX=0.33333334 mLastWallpaperY=0.5 mSystemGestureExclusion= Application tokens in top down Z order: // Z order 顺序 mStackId=19 mDeferRemoval=false mBounds=[0,0][1080,1920] // taskId=90 mBounds=[0,0][1080,1920] mdr=false appTokens=[AppWindowToken{5320efa token=Token{ba10d25 ActivityRecord{fcfcd1c u0 com.tencent.mm/.ui.LauncherUI t90}}}, AppWindowToken{afbe8c7 token=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}}}] mDisplayedBounds=[0,0][0,0] Activity #1 AppWindowToken{afbe8c7 token=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}}} windows=[Window{267a445 u0 com.tencent.mm/com.tencent.mm.plugin.fts.ui.FTSMainUI}] // FTSMainUI的窗口 windowType=2 hidden=false hasVisible=true // 窗口可见性 app=true mVoiceInteraction=false component=com.tencent.mm/.plugin.fts.ui.FTSMainUI task={taskId=90 appTokens=[AppWindowToken{5320efa token=Token{ba10d25 ActivityRecord{fcfcd1c u0 com.tencent.mm/.ui.LauncherUI t90}}}, AppWindowToken{afbe8c7 token=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}}}] mdr=false} mFillsParent=false mOrientation=1 hiddenRequested=false mClientHidden=false reportedDrawn=true reportedVisible=true mNumInterestingWindows=2 mNumDrawnWindows=2 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false Activity #0 AppWindowToken{5320efa token=Token{ba10d25 ActivityRecord{fcfcd1c u0 com.tencent.mm/.ui.LauncherUI t90}}} // tencent最初的activity windows=[Window{866c225 u0 com.tencent.mm/com.tencent.mm.ui.LauncherUI}] windowType=2 hidden=false hasVisible=true app=true mVoiceInteraction=false component=com.tencent.mm/.ui.LauncherUI task={taskId=90 appTokens=[AppWindowToken{5320efa token=Token{ba10d25 ActivityRecord{fcfcd1c u0 com.tencent.mm/.ui.LauncherUI t90}}}, AppWindowToken{afbe8c7 token=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}}}] mdr=false} mFillsParent=true mOrientation=1 hiddenRequested=false mClientHidden=false reportedDrawn=true reportedVisible=true mNumInterestingWindows=1 mNumDrawnWindows=1 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false mStackId=0 // 对应launcher mDeferRemoval=false mBounds=[0,0][1080,1920] taskId=71 mBounds=[0,0][1080,1920] mdr=false appTokens=[AppWindowToken{b3377dc token=Token{cc8e44f ActivityRecord{653eae u0 com.android.launcher3/.Launcher t71}}}] mDisplayedBounds=[0,0][0,0] Activity #0 AppWindowToken{b3377dc token=Token{cc8e44f ActivityRecord{653eae u0 com.android.launcher3/.Launcher t71}}} windows=[Window{7e835a0 u0 com.android.launcher3/com.android.launcher3.Launcher}] windowType=2 hidden=true hasVisible=true app=true mVoiceInteraction=false component=com.android.launcher3/.Launcher task={taskId=71 appTokens=[AppWindowToken{b3377dc token=Token{cc8e44f ActivityRecord{653eae u0 com.android.launcher3/.Launcher t71}}}] mdr=false} mFillsParent=true mOrientation=5 hiddenRequested=true mClientHidden=true reportedDrawn=false reportedVisible=false mAppStopped=true mNumInterestingWindows=1 mNumDrawnWindows=1 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false mStackId=15 // 对应settings（在此之后，又退回launcher） mDeferRemoval=false mBounds=[0,0][1080,1920] taskId=86 mBounds=[0,0][1080,1920] mdr=false appTokens=[AppWindowToken{9b2d0f3 token=Token{f6e2762 ActivityRecord{2e6262d u0 com.android.settings/.Settings t86}}}, AppWindowToken{bf1ee3a token=Token{c83e165 ActivityRecord{4644a5c u0 com.android.settings/.SubSettings t86}}}, AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}}] mDisplayedBounds=[0,0][0,0] Activity #2 AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}} windows=[Window{6c14d20 u0 com.android.settings/com.android.settings.SubSettings}] // 在Settings里，我跳转了三次，有三个activity windowType=2 hidden=true hasVisible=true app=true mVoiceInteraction=false component=com.android.settings/.SubSettings task={taskId=86 appTokens=[AppWindowToken{9b2d0f3 token=Token{f6e2762 ActivityRecord{2e6262d u0 com.android.settings/.Settings t86}}}, AppWindowToken{bf1ee3a token=Token{c83e165 ActivityRecord{4644a5c u0 com.android.settings/.SubSettings t86}}}, AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}}] mdr=false} mFillsParent=true mOrientation=-1 hiddenRequested=true mClientHidden=true reportedDrawn=false reportedVisible=false mAppStopped=true mNumInterestingWindows=1 mNumDrawnWindows=1 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false Activity #1 AppWindowToken{bf1ee3a token=Token{c83e165 ActivityRecord{4644a5c u0 com.android.settings/.SubSettings t86}}} windows=[Window{5343dde u0 com.android.settings/com.android.settings.SubSettings}] windowType=2 hidden=true hasVisible=true app=true mVoiceInteraction=false component=com.android.settings/.SubSettings task={taskId=86 appTokens=[AppWindowToken{9b2d0f3 token=Token{f6e2762 ActivityRecord{2e6262d u0 com.android.settings/.Settings t86}}}, AppWindowToken{bf1ee3a token=Token{c83e165 ActivityRecord{4644a5c u0 com.android.settings/.SubSettings t86}}}, AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}}] mdr=false} mFillsParent=true mOrientation=-1 hiddenRequested=true mClientHidden=true reportedDrawn=false reportedVisible=false mAppStopped=true mNumInterestingWindows=1 mNumDrawnWindows=1 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false Activity #0 AppWindowToken{9b2d0f3 token=Token{f6e2762 ActivityRecord{2e6262d u0 com.android.settings/.Settings t86}}} windows=[Window{9103d82 u0 com.android.settings/com.android.settings.Settings}] windowType=2 hidden=true hasVisible=true app=true mVoiceInteraction=false component=com.android.settings/.homepage.SettingsHomepageActivity task={taskId=86 appTokens=[AppWindowToken{9b2d0f3 token=Token{f6e2762 ActivityRecord{2e6262d u0 com.android.settings/.Settings t86}}}, AppWindowToken{bf1ee3a token=Token{c83e165 ActivityRecord{4644a5c u0 com.android.settings/.SubSettings t86}}}, AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}}] mdr=false} mFillsParent=true mOrientation=-1 hiddenRequested=true mClientHidden=true reportedDrawn=false reportedVisible=false mAppStopped=true mNumInterestingWindows=1 mNumDrawnWindows=1 inPendingTransaction=false allDrawn=true lastAllDrawn=true) startingData=null removed=false firstWindowDrawn=true mIsExiting=false homeStack=Stack=0 DockedStackDividerController mLastVisibility=false mMinimizedDock=false mAdjustedForIme=false // 没有adjust，因为底下窗口1080,1920还是全屏 ------> 奇怪的是，没有输入法的？ mAdjustedForDivider=false PinnedStackController defaultBounds=[533,622][1038,906] mDefaultMinSize=284 mDefaultStackGravity=85 mDefaultAspectRatio=1.777778 movementBounds=[42,105][1038,906] mIsImeShowing=true mImeHeight=846 mIsShelfShowing=false mShelfHeight=262 mReentrySnapFraction=-1.0 mIsMinimized=false mAspectRatio=1.777778 mMinAspectRatio=0.41841003 mMaxAspectRatio=2.39 mActions=[] mDisplayInfo=DisplayInfo{\"内置屏幕, displayId 0\", uniqueId \"local:0\", app 1080 x 1794, real 1080 x 1920, largest app 1794 x 1731, smallest app 1080 x 1017, mode 1, defaultMode 1, modes [{id=1, width=1080, height=1920, fps=60.000004}], colorMode 0, supportedColorModes [0, 7], hdrCapabilities android.view.Display$HdrCapabilities@40f16308, rotation 0, density 420 (442.451 x 443.345) dpi, layerStack 0, appVsyncOff 2000000, presDeadline 11666666, type BUILT_IN, address {port=0}, state ON, FLAG_SECURE, FLAG_SUPPORTS_PROTECTED_BUFFERS, removeMode 0} DisplayFrames w=1080 h=1920 r=0 mStable=[0,63][1080,1794] mStableFullscreen=[0,0][1080,1794] mDock=[0,63][1080,1794] mCurrent=[0,63][1080,948] mSystem=[0,0][1080,1920] mContent=[0,63][1080,948] mVoiceContent=[0,63][1080,948] mOverscan=[0,0][1080,1920] mRestrictedOverscan=[0,0][1080,1794] mRestricted=[0,0][1080,1794] mUnrestricted=[0,0][1080,1920] mDisplayInfoOverscan=[0,0][0,0] mRotatedDisplayInfoOverscan=[0,0][0,0] mDisplayCutout=WmDisplayCutout{DisplayCutout{insets=Rect(0, 0 - 0, 0) boundingRect={Bounds=[Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0), Rect(0, 0 - 0, 0)]}}, mFrameSize=null} DisplayPolicy mCarDockEnablesAccelerometer=true mDeskDockEnablesAccelerometer=true mDockMode=EXTRA_DOCK_STATE_UNDOCKED mLidState=LID_OPEN mAwake=true mScreenOnEarly=true mScreenOnFully=true mKeyguardDrawComplete=true mWindowManagerDrawComplete=true mHdmiPlugged=false mLastSystemUiFlags=0x8008 mResettingSystemUiFlags=0x0 mForceClearedSystemUiFlags=0x0 mShowingDream=false mDreamingLockscreen=false mDreamingSleepToken=null mStatusBar=Window{f83a40d u0 StatusBar} isStatusBarKeyguard=false mNavigationBar=Window{14de074 u0 NavigationBar0} mNavBarOpacityMode=0 mNavigationBarCanMove=true mNavigationBarPosition=4 mFocusedWindow=Window{267a445 u0 com.tencent.mm/com.tencent.mm.plugin.fts.ui.FTSMainUI} mFocusedApp=Token{a582a06 ActivityRecord{229bce1 u0 com.tencent.mm/.plugin.fts.ui.FTSMainUI t90}} mTopFullscreenOpaqueWindowState=Window{267a445 u0 com.tencent.mm/com.tencent.mm.plugin.fts.ui.FTSMainUI} mTopFullscreenOpaqueOrDimmingWindowState=Window{267a445 u0 com.tencent.mm/com.tencent.mm.plugin.fts.ui.FTSMainUI} mForcingShowNavBar=true mForcingShowNavBarLayer=0 mTopIsFullscreen=false mForceStatusBar=false mForceStatusBarFromKeyguard=false mForceShowSystemBarsFromExternal=false mAllowLockscreenWhenOn=false BarController.StatusBar mState=WINDOW_STATE_SHOWING mTransientBar=TRANSIENT_BAR_NONE mContentFrame=Rect(0, 0 - 1080, 63) BarController.NavigationBar mState=WINDOW_STATE_SHOWING mTransientBar=TRANSIENT_BAR_NONE mContentFrame=Rect(0, 1794 - 1080, 1920) Looper state: Looper (android.ui, tid 20) {ec23c4e} (Total messages: 0, polling=true, quitting=false) DisplayRotation mCurrentAppOrientation=SCREEN_ORIENTATION_PORTRAIT mLandscapeRotation=ROTATION_90 mSeascapeRotation=ROTATION_270 mPortraitRotation=ROTATION_0 mUpsideDownRotation=ROTATION_180 mSupportAutoRotation=true WindowOrientationListener mEnabled=true mCurrentRotation=ROTATION_0 mSensorType=null mSensor={Sensor name=\"Device Orientation\", vendor=\"Google\", version=1, type=27, maxRange=3.0, resolution=1.0, power=0.1, minDelay=0} mRate=2 OrientationSensorJudge mDesiredRotation=-1 mProposedRotation=-1 mTouching=false mTouchEndedTimestampNanos=25447710901675 mCarDockRotation=-1 mDeskDockRotation=-1 mUserRotationMode=USER_ROTATION_LOCKED mUserRotation=ROTATION_0 mAllowAllRotations=unknown mDemoHdmiRotation=ROTATION_90 mDemoHdmiRotationLock=false mUndockedHdmiRotation=-1 mLidOpenRotation=-1 mFixedToUserRotation=false InputConsumers: name=recents_animation_input_consumer pid=2114 user=UserHandle{0} name=pip_input_consumer pid=1749 user=UserHandle{0} WindowInsetsStateController InsetsState InsetsSource type=TYPE_UNKNOWN_10 frame=[0,948][1080,1920] visible=false InsetsSource type=TYPE_BOTTOM_TAPPABLE_ELEMENT frame=[0,1794][1080,1920] visible=true InsetsSource type=TYPE_TOP_TAPPABLE_ELEMENT frame=[0,0][1080,63] visible=true InsetsSource type=TYPE_RIGHT_GESTURES frame=[1080,0][1080,1920] visible=true InsetsSource type=TYPE_LEFT_GESTURES frame=[0,0][0,1920] visible=true InsetsSource type=TYPE_BOTTOM_GESTURES frame=[0,1794][1080,1920] visible=true InsetsSource type=TYPE_TOP_GESTURES frame=[0,0][1080,63] visible=true InsetsSource type=TYPE_SIDE_BAR_1 frame=[0,1794][1080,1920] visible=true InsetsSource type=TYPE_TOP_BAR frame=[0,0][1080,63] visible=true Control map: TODO: ------> 奇怪的是，没有输入法的？ dumpsys window windows 返回当前所有窗口的信息： 所有窗口的名称和类型。 当前前台应用程序的窗口。 当前屏幕上的所有窗口的坐标、大小和可见性等信息。 各个窗口的层级关系和焦点状态等。 展开 WINDOW MANAGER WINDOWS (dumpsys window windows) Window #0 Window{4bf30ad u0 PointerLocation - display 0}: mDisplayId=0 stackId=0 mSession=Session{e09d58 1285:1000} mClient=android.view.ViewRootImpl$W@e928cd7 mOwnerUid=1000 mShowToOwnerOnly=true package=android appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan} layoutInDisplayCutoutMode=always ty=SECURE_SYSTEM_OVERLAY fmt=TRANSLUCENT if=NO_INPUT_CHANNEL fl=NOT_FOCUSABLE NOT_TOUCHABLE LAYOUT_IN_SCREEN FULLSCREEN HARDWARE_ACCELERATED pfl=FORCE_HARDWARE_ACCELERATED} Requested w=1080 h=1920 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{32e2a56 PointerLocation - display 0}: Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1080 x 1920 transform=(1.0, 0.0, 1.0, 0.0) mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #1 Window{14de074 u0 NavigationBar0}: mDisplayId=0 stackId=0 mSession=Session{46a0dca 1749:u0a10088} mClient=android.os.BinderProxy@bc85f86 mOwnerUid=10088 mShowToOwnerOnly=false package=com.android.systemui appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan} ty=NAVIGATION_BAR fmt=TRANSLUCENT fl=NOT_FOCUSABLE NOT_TOUCH_MODAL TOUCHABLE_WHEN_WAKING WATCH_OUTSIDE_TOUCH SPLIT_TOUCH HARDWARE_ACCELERATED FLAG_SLIPPERY pfl=COLOR_SPACE_AGNOSTIC} Requested w=1080 h=126 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{c8a5a95 NavigationBar0}: mAnimationIsEntrance=true Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1080 x 126 transform=(1.0, 0.0, 1.0, 0.0) mLastFreezeDuration=+27s737ms mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #2 Window{f83a40d u0 StatusBar}: mDisplayId=0 stackId=0 mSession=Session{46a0dca 1749:u0a10088} mClient=android.os.BinderProxy@2bf3937 mOwnerUid=10088 mShowToOwnerOnly=false package=com.android.systemui appop=NONE mAttrs={(0,0)(fillx63) gr=TOP CENTER_VERTICAL sim={adjust=resize} layoutInDisplayCutoutMode=always ty=STATUS_BAR fmt=TRANSLUCENT fl=NOT_FOCUSABLE TOUCHABLE_WHEN_WAKING WATCH_OUTSIDE_TOUCH SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=COLOR_SPACE_AGNOSTIC} Requested w=1080 h=63 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{f62df9b StatusBar}: Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1080 x 63 transform=(1.0, 0.0, 1.0, 0.0) mLastFreezeDuration=+1h27m17s927ms mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #3 Window{65dd8dd u0 Application Not Responding: com.tencent.mm}: mDisplayId=0 stackId=0 mSession=Session{e09d58 1285:1000} mClient=android.view.ViewRootImpl$W@a330d87 mOwnerUid=1000 mShowToOwnerOnly=false package=android appop=SYSTEM_ALERT_WINDOW mAttrs={(0,0)(wrapxwrap) gr=CENTER sim={adjust=pan forwardNavigation} ty=SYSTEM_ALERT fmt=TRANSLUCENT wanim=0x10302ff surfaceInsets=Rect(84, 84 - 84, 84) fl=DIM_BEHIND ALT_FOCUSABLE_IM SPLIT_TOUCH HARDWARE_ACCELERATED pfl=SHOW_FOR_ALL_USERS SYSTEM_ERROR} Requested w=1024 h=514 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{b78eb5b Application Not Responding: com.tencent.mm}: mAnimationIsEntrance=true Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1192 x 682 transform=(1.0, 0.0, 1.0, 0.0) mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #4 Window{3fe946b u0 Application Not Responding: com.tencent.mm}: mDisplayId=0 stackId=0 mSession=Session{e09d58 1285:1000} mClient=android.view.ViewRootImpl$W@c83aee5 mOwnerUid=1000 mShowToOwnerOnly=false package=android appop=SYSTEM_ALERT_WINDOW mAttrs={(0,0)(wrapxwrap) gr=CENTER sim={adjust=pan forwardNavigation} ty=SYSTEM_ALERT fmt=TRANSLUCENT wanim=0x10302ff surfaceInsets=Rect(84, 84 - 84, 84) fl=DIM_BEHIND ALT_FOCUSABLE_IM SPLIT_TOUCH HARDWARE_ACCELERATED pfl=SHOW_FOR_ALL_USERS SYSTEM_ERROR} Requested w=1024 h=514 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{1fc0a6a Application Not Responding: com.tencent.mm}: mAnimationIsEntrance=true Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1192 x 682 transform=(1.0, 0.0, 1.0, 0.0) mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #5 Window{6d82633 u0 AssistPreviewPanel}: mDisplayId=0 stackId=0 mSession=Session{46a0dca 1749:u0a10088} mClient=android.os.BinderProxy@929a96d mOwnerUid=10088 mShowToOwnerOnly=true package=com.android.systemui appop=NONE mAttrs={(0,0)(fillx656) gr=BOTTOM START CENTER sim={state=unchanged adjust=nothing} ty=VOICE_INTERACTION_STARTING fmt=TRANSLUCENT fl=NOT_FOCUSABLE NOT_TOUCHABLE LAYOUT_IN_SCREEN HARDWARE_ACCELERATED vsysui=LAYOUT_STABLE LAYOUT_HIDE_NAVIGATION LAYOUT_FULLSCREEN} Requested w=0 h=0 mLayoutSeq=14 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{a1c9f38 AssistPreviewPanel}: mShownAlpha=0.0 mAlpha=1.0 mLastAlpha=0.0 mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #6 Window{f821bb6 u0 DockedStackDivider}: mDisplayId=0 stackId=0 mSession=Session{46a0dca 1749:u0a10088} mClient=android.os.BinderProxy@4640478 mOwnerUid=10088 mShowToOwnerOnly=false package=com.android.systemui appop=NONE mAttrs={(0,0)(fillx126) sim={adjust=pan} layoutInDisplayCutoutMode=always ty=DOCK_DIVIDER fmt=TRANSLUCENT fl=NOT_FOCUSABLE NOT_TOUCH_MODAL WATCH_OUTSIDE_TOUCH SPLIT_TOUCH HARDWARE_ACCELERATED FLAG_SLIPPERY pfl=NO_MOVE_ANIMATION vsysui=LAYOUT_STABLE LAYOUT_HIDE_NAVIGATION LAYOUT_FULLSCREEN} Requested w=1080 h=126 mLayoutSeq=733 mPolicyVisibility=false mLegacyPolicyVisibilityAfterAnim=false mAppOpVisibility=true parentHidden=false mPermanentlyHidden=false mHiddenWhileSuspended=false mForceHideNonSystemOverlayWindow=false mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{4030b11 DockedStackDivider}: mShownAlpha=0.0 mAlpha=1.0 mLastAlpha=0.0 mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #7 Window{582c745 u0 com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI}: mDisplayId=0 stackId=17 mSession=Session{b9b078e 19282:u0a10133} mClient=android.os.BinderProxy@cd99bbc mOwnerUid=10133 mShowToOwnerOnly=true package=com.tencent.mm appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=resize forwardNavigation} layoutInDisplayCutoutMode=always ty=BASE_APPLICATION fmt=TRANSLUCENT wanim=0x7f12001c sysuil=true fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND vsysui=LIGHT_STATUS_BAR} Requested w=1080 h=1920 mLayoutSeq=733 mHasSurface=true isReadyForDisplay()=true mWindowRemovalAllowed=false WindowStateAnimator{5111055 com.tencent.mm/com.tencent.mm.plugin.appbrand.ui.AppBrandUI}: Surface: shown=true layer=0 alpha=1.0 rect=(0.0,0.0) 1080 x 1920 transform=(1.0, 0.0, 1.0, 0.0) mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=true isVisible=true Window #8 Window{7e835a0 u0 com.android.launcher3/com.android.launcher3.Launcher}: mDisplayId=0 stackId=0 mSession=Session{6ec805d 2114:u0a10080} mClient=android.os.BinderProxy@4eeaea3 mOwnerUid=10080 mShowToOwnerOnly=true package=com.android.launcher3 appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan forwardNavigation} layoutInDisplayCutoutMode=always ty=BASE_APPLICATION fmt=TRANSPARENT wanim=0x10302f1 fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SHOW_WALLPAPER SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND vsysui=LAYOUT_STABLE LAYOUT_HIDE_NAVIGATION LAYOUT_FULLSCREEN} Requested w=1080 h=1920 mLayoutSeq=716 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{85da77 com.android.launcher3/com.android.launcher3.Launcher}: mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 mWallpaperX=0.33333334 mWallpaperY=0.5 mWallpaperXStep=0.33333334 mWallpaperYStep=1.0 isOnScreen=false isVisible=false Window #9 Window{36924d u0 com.tencent.mm/com.tencent.mm.ui.LauncherUI}: mDisplayId=0 stackId=16 mSession=Session{fc9edf0 19057:u0a10133} mClient=android.os.BinderProxy@9f10de4 mOwnerUid=10133 mShowToOwnerOnly=true package=com.tencent.mm appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=nothing} layoutInDisplayCutoutMode=always ty=BASE_APPLICATION fmt=TRANSLUCENT wanim=0x7f1201e3 fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND vsysui=LAYOUT_STABLE LAYOUT_FULLSCREEN} Requested w=1080 h=1920 mLayoutSeq=691 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{daf2fc4 com.tencent.mm/com.tencent.mm.ui.LauncherUI}: mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #10 Window{6c14d20 u0 com.android.settings/com.android.settings.SubSettings}: mDisplayId=0 stackId=15 mSession=Session{8a3d7f7 17988:1000} mClient=android.os.BinderProxy@4a77423 mOwnerUid=1000 mShowToOwnerOnly=true package=com.android.settings appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan} ty=BASE_APPLICATION wanim=0x10302f1 fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND} Requested w=1080 h=1920 mLayoutSeq=647 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{57a95e2 com.android.settings/com.android.settings.SubSettings}: mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #11 Window{5343dde u0 com.android.settings/com.android.settings.SubSettings}: mDisplayId=0 stackId=15 mSession=Session{8a3d7f7 17988:1000} mClient=android.os.BinderProxy@84cd919 mOwnerUid=1000 mShowToOwnerOnly=true package=com.android.settings appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan} ty=BASE_APPLICATION wanim=0x10302f1 fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND} Requested w=1080 h=1920 mLayoutSeq=603 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{da8dd73 com.android.settings/com.android.settings.SubSettings}: mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #12 Window{9103d82 u0 com.android.settings/com.android.settings.Settings}: mDisplayId=0 stackId=15 mSession=Session{8a3d7f7 17988:1000} mClient=android.os.BinderProxy@74840cd mOwnerUid=1000 mShowToOwnerOnly=true package=com.android.settings appop=NONE mAttrs={(0,0)(fillxfill) sim={adjust=pan} ty=BASE_APPLICATION wanim=0x10302f1 fl=LAYOUT_IN_SCREEN LAYOUT_INSET_DECOR SPLIT_TOUCH HARDWARE_ACCELERATED DRAWS_SYSTEM_BAR_BACKGROUNDS pfl=FORCE_DRAW_STATUS_BAR_BACKGROUND vsysui=LAYOUT_STABLE LAYOUT_HIDE_NAVIGATION} Requested w=1080 h=1920 mLayoutSeq=596 mHasSurface=false isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{e518430 com.android.settings/com.android.settings.Settings}: mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 isOnScreen=false isVisible=false Window #13 Window{924eb8e u0 com.android.systemui.ImageWallpaper}: mDisplayId=0 stackId=0 mSession=Session{46a0dca 1749:u0a10088} mClient=android.os.BinderProxy@9e1ef89 mOwnerUid=10088 mShowToOwnerOnly=true package=com.android.systemui appop=NONE mAttrs={(0,0)(2160x1920) gr=TOP START CENTER layoutInDisplayCutoutMode=always ty=WALLPAPER fmt=RGBX_8888 wanim=0x103030e fl=NOT_FOCUSABLE NOT_TOUCHABLE LAYOUT_IN_SCREEN LAYOUT_NO_LIMITS SCALED LAYOUT_INSET_DECOR pfl=WANTS_OFFSET_NOTIFICATIONS} Requested w=2880 h=2560 mLayoutSeq=721 mIsImWindow=false mIsWallpaper=true mIsFloatingLayer=true mWallpaperVisible=false mHasSurface=true isReadyForDisplay()=false mWindowRemovalAllowed=false WindowStateAnimator{e320202 com.android.systemui.ImageWallpaper}: Surface: shown=false layer=0 alpha=1.0 rect=(-360.0,0.0) 2880 x 2560 transform=(0.75, 0.0, 0.75, 0.0) mLastFreezeDuration=+29s218ms mForceSeamlesslyRotate=false seamlesslyRotate: pending=null finishedFrameNumber=0 mHScale=0.75 mVScale=0.75 mWallpaperX=0.33333334 mWallpaperY=0.5 mWallpaperXStep=0.33333334 mWallpaperYStep=1.0 isOnScreen=true isVisible=false mGlobalConfiguration={1.0 ?mcc?mnc [zh_CN_#Hans,en_US] ldltr sw411dp w411dp h659dp 420dpi nrml port night finger -keyb/v/h -nav/h winConfig={ mBounds=Rect(0, 0 - 1080, 1920) mAppBounds=Rect(0, 0 - 1080, 1794) mWindowingMode=fullscreen mDisplayWindowingMode=fullscreen mActivityType=undefined mAlwaysOnTop=undefined mRotation=ROTATION_0} s.8} mHasPermanentDpad=false mTopFocusedDisplayId=0 mInTouchMode=true mLastDisplayFreezeDuration=0 due to Window{f83a40d u0 StatusBar} mLastWakeLockHoldingWindow=null mLastWakeLockObscuringWindow=Window{6682f7b u0 com.tencent.mm/com.tencent.mm.ui.LauncherUI} mFullSnapshotScale=1.0 SnapshotCache Entry taskId=88 topApp=AppWindowToken{da37ed5 token=Token{153378c ActivityRecord{27614bf u0 com.tencent.mm/.plugin.appbrand.ui.AppBrandUI t88}}} snapshot=TaskSnapshot{ mTopActivityComponent=com.tencent.mm/.plugin.appbrand.ui.AppBrandUI mSnapshot=android.graphics.GraphicBuffer@f2f7cc2 (1080x1920) mColorSpace=sRGB IEC61966-2.1 (id=0, model=RGB) mOrientation=1 mContentInsets=[0,63][0,126] mReducedResolution=false mScale=1.0 mIsRealSnapshot=true mWindowingMode=1 mSystemUiVisibility=8192 mIsTranslucent=true Entry taskId=86 topApp=AppWindowToken{c1d119a token=Token{761f645 ActivityRecord{10c26bc u0 com.android.settings/.SubSettings t86}}} snapshot=TaskSnapshot{ mTopActivityComponent=com.android.settings/.SubSettings mSnapshot=android.graphics.GraphicBuffer@c1c18a9 (1080x1920) mColorSpace=sRGB IEC61966-2.1 (id=0, model=RGB) mOrientation=1 mContentInsets=[0,63][0,126] mReducedResolution=false mScale=1.0 mIsRealSnapshot=true mWindowingMode=1 mSystemUiVisibility=0 mIsTranslucent=false WINDOW MANAGER TRACE (dumpsys window trace) Status: Disabled Log level: 1 Buffer size: 2097152 bytes Buffer usage: 0 bytes Elements in the buffer: 0 推论： dumpsys window | grep windows 这其实是输出：从上到下沿Z轴的应用token 1.11.3. 推论：获取当前 最前面activty的脚本： adb shell dumpsys activity activities|findstr ResumedActivit ----------> 有针对性 D:\\laji>adb shell dumpsys activity activities|findstr ResumedActivit mResumedActivity: ActivityRecord{915ceaa u0 com.example.sourceCode/.MainActivity t51} 同时可以知道具体的子类名 1.11.4. 原理 1.12. adb查看手机是32位还是64位 adb shell getprop ro.product.cpu.abi arm64-v8a 1.13. ADB网络wifi调试和常见命令 https://www.jianshu.com/p/2d256f338634 使用网络首先得在Android设备设置网络adb监听的端口，再通过adb连接到设备进行控制； 设置网络adb监听的端口 1.13.1. 最简单的方法 先是使用usb线连接电脑跟安卓设备，执行adb命令，该条命令是设置网络adb监听的端口，5555是默认，也可以设置其他的，在安卓设备重启后会失效，不需要root权限 adb tcpip 3333 1.13.2. 重启后依然有效方法 在root权限下执行 adb rootadb shell setprop service.adb.tcp.port 3333 输入命令连接到设备 adb connect 192.168.31.166:3333 1.14. DropBox https://blog.csdn.net/rzleilei/article/details/128328967 作用： dropbox是安卓系统中用来记录一些异常信息的模块，比如某个应用crash了或者anr了，系统最终都会把记录的异常信息记录到dropbox中 位置： data/system/dropbox 文件类型： CRASH，ANR，墓碑日志，native崩溃 获取脚本： adb devices adb root adb pull /data/system/dropbox/ pause 清理： adb root adb remount adb shell rm -rf /data/system/dropbox/* pause 原理： https://blog.csdn.net/rzleilei/article/details/128328967 具体场景举例子： TODO 1.15. adb命令行： https://blog.csdn.net/chen801090/article/details/103962118 ---> 很全 屏幕相关： 锁屏、唤醒屏幕: WAKE ​ 或 adb shell input keyevent KEYCODE_POWER ----> 锁屏与唤醒自动切换 滑动屏幕 adb shell input swipe x_start y_start x_end y_end 截屏：adb shell /system/bin/screencap -p /sdcard/screenshot.png 录屏：adb shell screenrecord --time-limit 10 /sdcard/demo.mp4 禁用自动旋转: adb shell content insert --uri content://settings/system --bind name:s:accelerometer_rotation --bind value:i:0 旋转屏幕 : adb shell content insert --uri content://settings/system --bind name:s:user_rotation --bind value:i:1 后面跟的不同的值代表旋转为不同的方向，取值范围为0，1，2，3 安卓开机禁止锁屏: adb shell settings put system def_lockscreen_disabled true 禁止屏幕休眠: adb shell settings put system screen_off_timeout 3600000 //一个小时 adb shell settings put system screen_off_timeout 2147483647 // 永不休眠 手势操作： 向下滑：adb shell input touchscreen swipe 930 380 930 880 向右滑：adb shell input touchscreen swipe 330 880 930 880 向左滑：adb shell input touchscreen swipe 930 880 330 880 模拟鼠标点击操作：adb shell input mouse tap 100 500 长按：adb shell input swipe startX startY startX startY 500 滑动解锁：adb shell input swipe 300 1000 300 500 app相关： adb卸载系统应用+安装为系统应用， 见 《 AndriodSystem_Others》 冷启动app：adb shell am start -W -n package/activity 热启动：①停止app： adb shell input keyevent 3 ②adb shell am start -W -n package/activity 关闭app： 法一： 查进程: adb shell \"ps | grep tencent\" ​ 杀进程 adb shell \" kill -9 \" ​ 法二： 用包名： adb shell am force-stop com.tencent.com ​ 法三：用利用断点调试杀进程，见断点调试 获取系统状态（AMS、WMS）信息： 当前页面： adb shell dumpsys activity activities|findstr ResumedActivit 屏幕刷新率 获取环境信息： 屏幕分辨率、手机型号、版本号、 查询手机上是userdebug或user版本： adb shell getprop ro.build.type 使用adb 查看Android版本号 和 SDK版本号 adb shell getprop ro.build.version.release adb shell getprop ro.build.version.sdk bat脚本相关： reboot之后，等待手机启动： adb wait-for-device 安卓多屏： 虚拟屏VirtualDisplay相关操作：https://blog.csdn.net/vviccc/article/details/119785457 1、创建 #创建一块辅助屏显示器，如下所示： $settings put global overlay_display_devices \"1920x1080/320,secure\" #创建两块辅助屏显示器，如下所示： $settings put global overlay_display_devices \"1920x1080/320,secure;1920x1080/320,secure\" #创建三块辅助屏显示器也是类似，以此类推，如下所示： $settings put global overlay_display_devices \"1920x1080/320,secure;1920x1080/320,secure;1920x1080/320,secure\" #关闭辅助屏显示器 如下所示： $settings put global overlay_display_devices “null” 2、虚拟屏，不能点击，只能命令，自然： #启动activity在虚拟屏上 adb shell am start --display 2 包名/activity名 #触摸 adb shell input -d 2 tap 500 600 https://blog.csdn.net/weixin_44008788/article/details/118029592 Android系统adb模拟按键操作方法 TODO: adb shell logcat -S 1.16. UIAutomator2自动化（操作手机） https://blog.csdn.net/d1240673769/article/details/113809889?utm_medium=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link&depth_1-utm_source=distribute.pc_relevant_t0.none-task-blog-2%7Edefault%7ECTRLIST%7Edefault-1.no_search_link ----> 全量 1.16.1. 环境配置 1、安装uiautomator2 pip install --pre uiautomator2 pip install pillow （如果需要截图，可安装这个库） 12 2、设备安装atx-agent ---》手机上 首先设备连接到PC，并能够adb devices发现该设备。 执行下面的命令会自动安装本库所需要的设备端程序：uiautomator-server，atx-agent，openstf / minicap，openstf / minitouch # init就是所有USB连接电脑的手机上都安装uiautomator2 python -m uiautomator2 init # 指定手机安装uiautomator2， 用 --mirror python -m uiautomator2 init --mirror --serial $SERIAL # 嫌弃慢的话，可以用国内的镜像 python -m uiautomator2 init --mirror 12345678 最后提示success，代表atx-agent初始化成功。 3、安装weditor 有了这个，方便我们快速的识别手机上的元素，方便写代码 pip install -U weditor 安装好之后，就可以在命令行运行 weditor --help 确认是否安装成功了。 Windows系统可以使用命令在桌面创建一个快捷方式: weditor --shortcut 1.16.2. 操作命令： 1、连接： import uiautomator2 as u2 d = u2.connect() 2、查看当前UI界面的结构 -----》包括任意一个元素，非常有用！！！！！！（很多时候，我们不清楚一个UI某个控件具体的类！！！！！） d.dump_hierarchy() 例子 def execuiautomator2Command(): print(\"execuiautomator2Command=\") d = u2.connect() val = 1 while val: val +=1 print(val) clickButton = '立即购买' if isTimeOK(d, clickButton): doClick(d, clickButton) else: #d.drag(400, 400, 300, 900, 0.04) # 0.01s #time.sleep(0.3) #等待web加载时间 # continue print(val) clickButton = \"确定\" if isTimeOK(d, clickButton): doClick(d, clickButton) else: print(val) # d.drag(400, 400, 300, 900, 0.04) # 0.01s # time.sleep(0.3) #等待web加载时间 # continue clickButton = \"提交订单\" if isTimeOK(d, clickButton): doClick(d, clickButton) else: print(val) # d.drag(400, 400, 300, 900, 0.04) # 0.01s # time.sleep(0.3) #等待web加载时间 # continue def doClick(d, ans): print(\"doMaiPiao=\") # x, y = d(text=\"K305\").center() try: x, y = d(text=ans).center() d.click(x, y) except: print(\"except\") # time.sleep(0.8) # 等待web加载时间 # selectPeople(d, \"确定\") # time.sleep(0.8) #等待web加载时间 # selectPeople(d, \"提交订单\") def isTimeOK(d, buttonName): mash = \"马上抢\" # if d.xpath(\"//android.widget.TextView[@text='立即购买']\").exists: print(\"//android.widget.TextView[@text='%s']\" % (buttonName)) result = False if d.xpath( \"//android.widget.TextView[@text='%s']\" %(buttonName) ).exists: result = True elif d.xpath( \"//android.widget.Button[@text='%s']\" %(buttonName) ).exists: result = True elif d.xpath(\"//android.view.View[@text='%s']\" % (buttonName)).exists: result = True else: result = False return result def selectPeople(d, name): print(name) x2, y2 = d(text=name).center() d.click(x2, y2) print(name + \"end\") def main(): #参数： # checi = \"K1041\" ---》！！！ # time = '12点30分起售' ----》！！！ #二等、硬卧 #乘车人 # 是否提交订单 ----》！！！！！ execuiautomator2Command() if __name__ \"__main__\": main() 。。。。其他命令 1.17. 计算云连真机 方式一： 主机： C:\\Windows\\system32>adb kill-server C:\\Windows\\system32>adb -a -P 9999 nodaemon server 计算云：ip是主机的 adb connect 192.168.31.200:9999 adb -H 192.168.31.200 -P 9999 devices 注意：adb版本统一用39的！！！！ ​ 所有adb命令，变成 adb -H 192.168.31.200 -P 9999 方式二：见《docker连 主机pc连的安卓设备》 2. 手机环境问题 2.1. adb 授权 Android设备adb授权的原理【转】： https://blog.51cto.com/u_8475449/5606594 在新电脑上/重装系统后恢复 adb 授权 https://zhuanlan.zhihu.com/p/559998688?utm_id=0 3. 格式 忽略： 隐藏 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/software_pcSettings.html":{"url":"coding/Tool/software_pcSettings.html","title":"Software Pc Settings","keywords":"","body":"1. 其他次要软件/工具1.1. 软件大全1.2. Source Insight1.3. vscode1.4. markdown1.4.1. 设置 编辑器 的宽度1.5. Q-dir1.6. 截图工具Snipaste1.7. mobaXterm1.7.1. 提高效率的做法1.7.2. 启动sh，可以定制一些东西1.7.3. 技巧1：1.7.4. 技巧2：1.7.5. 极优的点：1.8. 远程桌面：1.8.1. 远程桌面之内网穿透1.8.2. 远程桌面之 公网ip（ipV6）1.8.3. 优化之 ipv6租约时间1.8.4. 远程桌面之 音频传输1.9. git bash1.10. gitBook----个人网站1.10.1. 环境搭建：1.10.2. PC本地调试，优1.10.3. 各种插件1.10.4. md、html 生成ok标准：1.10.5. GitHub1.10.6. 优化之book sm1.11. EA1.11.1. 自动生成类图1.11.2. 以java文件的粒度，创建 导入一个class 模型1.11.3. EA中边界框架的添加方法1.11.4. EA的缺点：1.12. Edraw1.12.1. 1、技巧：edraw的组合1.12.2. 2、自定义view组件存储的地方：1.12.3. 3、技巧：选中主题，有外框和标注1.12.4. 对齐与大小同步1.12.5. 画图基本元素1.12.6. 链接线不允许手动画1.12.7. 格式刷 刷链接线1.12.8. 文字如何统一修改格式？1.12.9. 如何统一修改框的格式1.12.10. 亿图截图方法1.13. Andriod Code Search1.14. Everything1.14.1. 限定路径搜索1.15. Typora1.15.1. 快捷键1.15.2. Typora 设置标题自动编号1.16. 所有软件自定义热键的方法1.17. 屏幕亮度/对比度 软件调节1.18. 屏幕分区软件MaxTo1.19. 反编译工具2. 计算机其他问题及设置2.1. 软件最优的使用方式----免安装2.2. 删除文件/文件夹，有进程正在占用2.3. 蓝牙设备添加2.4. 磁盘修复及优化2.5. 装最纯净的win10系统2.6. 常见最优设置2.6.1. 剪切板，多个历史 复制值2.6.2. 双屏，次屏幕隐藏任务栏2.7. 垃圾2.8. 蓝屏问题2.9. 电脑wifi经常掉2.10. 网络较慢2.11. 关于HDMI连接 无响应2.12. 远程桌面2.12.1. 远程电脑 访问 本地电脑磁盘的方法3. 格式TreeviewCopyright © aleen42 all right reserved, powered by aleen42 其他次要软件/工具 软件大全 Source Insight vscode markdown 设置 编辑器 的宽度 Q-dir 截图工具Snipaste mobaXterm 提高效率的做法 启动sh，可以定制一些东西 技巧1： 技巧2： 极优的点： 远程桌面： 远程桌面之内网穿透 远程桌面之 公网ip（ipV6） 目标 一：有个可以在广域网ping通的ipv6 步骤1：1级光猫配置（可直接使用光猫wifi的 ipv6） 步骤2：二级路由器的设置 二级路由器也存在防火墙关闭问题： 方式一：将ipv6防火墙全部关闭 方式二：在防火墙开一两个端口（将远程桌面的端口3389开） 优化之 ipv6租约时间 远程桌面之 音频传输 git bash gitBook----个人网站 环境搭建： gitbook init报TypeError [ERR_INVALID_ARG_TYPE] 选择github作为网页page的仓时 PC本地调试，优 各种插件 accordion隐藏插件 md、html 生成ok标准： GitHub 优化之book sm EA 自动生成类图 目的 以java文件的粒度，创建 导入一个class 模型 EA中边界框架的添加方法 EA的缺点： Edraw 1、技巧：edraw的组合 2、自定义view组件存储的地方： 3、技巧：选中主题，有外框和标注 对齐与大小同步 画图基本元素 链接线不允许手动画 格式刷 刷链接线 文字如何统一修改格式？ 如何统一修改框的格式 亿图截图方法 Andriod Code Search Everything 限定路径搜索 Typora 快捷键 Typora 设置标题自动编号 所有软件自定义热键的方法 屏幕亮度/对比度 软件调节 屏幕分区软件MaxTo 反编译工具 计算机其他问题及设置 软件最优的使用方式----免安装 删除文件/文件夹，有进程正在占用 蓝牙设备添加 磁盘修复及优化 装最纯净的win10系统 常见最优设置 剪切板，多个历史 复制值 双屏，次屏幕隐藏任务栏 垃圾 蓝屏问题 电脑wifi经常掉 网络较慢 关于HDMI连接 无响应 远程桌面 远程电脑 访问 本地电脑磁盘的方法 方法一：将本地的 磁盘driver 挂到远程电脑上 方法二： 共享文件夹 格式 [TOC] 1. 其他次要软件/工具 1.1. 软件大全 推荐使用： 录屏软件 EV录屏 1.2. Source Insight 见《sourceInsight.md》 1.3. vscode 编译环境的搭建： https://chowdera.com/2020/12/20201229202248553i.html https://code.visualstudio.com/docs/languages/cpp 官方文档 AddressSanitizer工具 https://docs.microsoft.com/en-us/cpp/sanitizers/asan?view=msvc-170 高亮变量: vscode的highlight-words： https://blog.csdn.net/u013171226/article/details/108868425 ​ TODO: Ubutu上安装vscode，并搭建Frame native断点调试环境 : https://www.jianshu.com/p/d84a2ec948be 使用VsCode调试Android Framework C/C++源代码 https://blog.csdn.net/zhaojia92/article/details/99774704 1.4. markdown 1.4.1. 设置 编辑器 的宽度 （也是主题）的宽度 https://blog.csdn.net/xiaojin21cen/article/details/90292315#2___12 1.5. Q-dir 1.6. 截图工具Snipaste 1、可以截取多张图片，悬浮在屏幕里---》对照方便 2、绘图展示 3、放大缩小： 4、透明度改变 1.7. mobaXterm copy将整个页面： 1、关掉右键粘贴 2、复制全部或 +号默认打开的是宿主机子win的c盘位置，相当于 打开本地的cmd ----> TODO: 这其实是很好的入口，用linux环境，做一些cmd初始化的工作 1.7.1. 提高效率的做法 同时开几个窗口 + 且用tmux： 1.7.2. 启动sh，可以定制一些东西 这一点同Linux、win的 sh脚本一样 Bash启动： 会自动执行profile文件：----> 在这里source sh文件，自定义function 1.7.3. 技巧1： bash.exe环境 是 linux下shell环境:-----------> 命令友好 但是 缺少 win环境变量（比如adb，python） -----> 方法：极优 linux环境 + win环境变量（即win环境）： 步骤： 在bash环境下，先进入cmd（拿到win环境），再exit回到 bash环境 1.7.4. 技巧2： 可以在win下任意路径，进入bash环境 即 1.7.5. 极优的点： 整个win系统的硬盘都挂在了/drives -------------> 整个win硬盘，bash都可以访问 1.8. 远程桌面： 1.8.1. 远程桌面之内网穿透 淘宝有卖 远程桌面需要的条件：局域网（没有公共IP） 或者 公网ip 或者内网穿透 https://zhuanlan.zhihu.com/p/115826053?utm_source=wechat_session&utm_medium=social&utm_oi=903075405244817408&utm_campaign=shareopn 1.8.2. 远程桌面之 公网ip（ipV6） 目标 一：有个可以在广域网ping通的ipv6 可以测试的网站： https://ipw.cn/ https://test-ipv6.com/ http://test6.ustc.edu.cn/ 步骤1：1级光猫配置（可直接使用光猫wifi的 ipv6） 登录：http://192.168.1.1/cu.html 参考：https://zhidao.baidu.com/question/1930330333758025547.html 联通光猫wo_27s的网址；192.168.1.1/cu.html 超级用户名：CUAdmin 密码：CUAdmin 拨号的配置： 防火墙设置：iPv4防火墙设置低；iPv6防火墙直接删掉 核心要点：关闭各种防火墙--------pc防火墙 + 路由器防火墙 https://blog.csdn.net/weixin_43245095/article/details/125237294 IPv6连接测试通过，但是无法ping成功问题解决（记录） https://blog.csdn.net/hua0721/article/details/128223801 ipv6外网能ping通，但无法访问服务(自建网站,远程桌面等) 注意：此时可以使用光猫wifi的 ipv6 ----》 可以被广域网 ping到。可以远程使用 步骤2：二级路由器的设置 联网设置： （1）物理网线连接 光猫 （2）登录 http://192.168.2.1/ ipv6相关设置： 账号admin 二级路由器也存在防火墙关闭问题： 同上面，也要关闭防火墙 方法一：路由器设置界面可以关掉 方法二：路由器界面就没有防火墙--------> 大招，进入系统： 参考： https://zhuanlan.zhihu.com/p/547389653 关闭服务器防火墙 进入路由器系统的方法： （1）打开ssh开关 ： 登录 http://192.168.2.1/api/set/telnet 账号admin 参考： https://429006.com/article/tag/openw （2）进入： C:\\Users\\24234>ssh -l root 192.168.2.1 方式一：将ipv6防火墙全部关闭 root@VS010:~# cd / root@VS010:/# config2 default/ root@VS010:/# ip6tables -F root@VS010:/# ip6tables -X root@VS010:/# ip6tables -P INPUT ACCEPT root@VS010:/# ip6tables -P OUTPUT ACCEPT root@VS010:/# ip6tables -P FORWARD ACCEPT root@VS010:/# //总之， config2 default/ && ip6tables -F && ip6tables -X && ip6tables -P INPUT ACCEPT && ip6tables -P OUTPUT ACCEPT && ip6tables -P FORWARD ACCEPT 远程桌面，只需要IP即可 方式二：在防火墙开一两个端口（将远程桌面的端口3389开） 优点---------》 安全性非常好 参考：http://app.myzaker.com/news/article.php?pk=626eae9d8e9f095e4a34d66f // 开放5001 ip6tables -I forwarding_rule -p tcp --dport 5010 -j ACCEPT ip6tables -I forwarding_rule -p udp --dport 5010 -j ACCEPT // 开放3389 ip6tables -I forwarding_rule -p tcp --dport 3389 -j ACCEPT ip6tables -I forwarding_rule -p udp --dport 3389 -j ACCEPT 路由器开机后自动开启 5000 和 3389 端口，这个端口号是可以根据自己的需求更改或者增加的。Windows 系统的远程桌面端口认是 3389，如果觉得不安全，可以换一个端口号。 远程桌面： [ipv6地址]:端口，比如 [ipv6地址]:3389 优化1： Windows 系统的远程桌面端口认是 3389，不安全 ------> 修改端口为5010 参考： ​ https://xinzhi.wenda.so.com/a/1630119419206952 远程桌面： [ipv6地址]:5001 优化2：把脚本写进路由器开机启动里 参考：http://app.myzaker.com/news/article.php?pk=626eae9d8e9f095e4a34d66f 写入文件：vi /etc/rc.local 1.8.3. 优化之 ipv6租约时间 路由器定时修改ipc的 IPv4和ipv6??? ------------> 解析，固定为个人域名 https://github.com/jeessy2/ddns-go 具体步骤，见md 1.8.4. 远程桌面之 音频传输 远程桌面连接后听不到remote pc的视频播放声音： 1、相关的配置： https://www.anyviewer.cn/how-to/rdp-audio-not-working-6540.html 1_1、重启本地+远程pc 2、确定remote pc已安装声卡和驱动 + 耳机，换句话说就是remote pc可以出声 3、本地pc远程： ​ 一个坑： 验证步骤2时，不能用RDP远程操作。办法： 用向日葵或直接远程pc登录验证 1.9. git bash 好处： 1、git作用 2、将win文件系统变成linux（极优） --------> 一切在linux下的命令，都可以用在win下 ​ 比如： ls -l、执行sh、git管理文件 3、任意win目录都可以变成linux目录 安装： https://blog.csdn.net/aixueai/article/details/119574135 第一次使用，设置你的名字和Email地址： git config --global user.email \"you@example.com\" git config --global user.name \"Your Name\" git push需要： 1.10. gitBook----个人网站 1.10.1. 环境搭建： https://blog.csdn.net/YunWQ/article/details/120197926?spm=1001.2101.3001.6650.3&utm_medium=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-120197926-blog-122971465.235%5Ev36%5Epc_relevant_default_base3&depth_1-utm_source=distribute.pc_relevant.none-task-blog-2%7Edefault%7ECTRLIST%7ERate-3-120197926-blog-122971465.235%5Ev36%5Epc_relevant_default_base3&utm_relevant_index=4 https://www.jianshu.com/p/a9c6b5cba8cf https://blog.csdn.net/qlql489/article/details/122971465 TODO:https://docs.docker.com/get-started/overview/ ---> 看一下别人如何搭建这么好的 gitbook init报TypeError [ERR_INVALID_ARG_TYPE] https://blog.csdn.net/qq_33641175/article/details/122508473 选择github作为网页page的仓时 每次push，网站会自动校验 pages build ： 影响 1、通不过，无法访问网站github.io 网站 2、这也解释了为啥push上去，要等很久，才更新网页（校验build需要时间） 1.10.2. PC本地调试，优 命令gitbook serve(注意是serve不是server) 并生成http://localhost:4000本地访问地址 1.10.3. 各种插件 https://blog.csdn.net/ming_97y/article/details/115202048 Gitbook详解（五）-插件的配置和使用详解 https://blog.csdn.net/xixihahalelehehe/article/details/125115239 \"plugins\": [ \"anchor-navigation-ex\", \"toggle-chapters\", \"expandable-chapters-small\", \"splitter\", \"code\", \"page-treeview\", \"popup\", \"-search\", \"-lunr\", \"search-pro\" ], 《-------gitbook install 安装上述所有 gitbook功能插件有： 插件 gitbook 介绍【updated】 gitbook 开始【updated】 gitbook 安装【updated】 gitbook README.md【updated】 gitbook SUMMARY.md【updated】 gitbook book.json 定制功能【updated】 gitbook 发布 github pages【updated】 gitbook 更新 github pages【updated】 gitbook 插件【updated】 gitbook 插件 gitbook-summary【updated】 gitbook 插件 GitBook-auto-summary【updated】 gtibook 插件 侧边导航【updated】 gitbook 插件 文章目录导航【updated】 gitbook 插件 文章 TOC 目录【updated】 gitbook 插件 提示与强调【updated】 gtibook 插件 代码块【updated】 gitbook 插件 分享【updated】 gitbook 插件 赞赏【updated】 gitbook 插件 查询【updated】 gitbook 插件 评论【updated】【adding】 gitbook 插件 版权声明【updated】 gitbook 插件 背景设置【updated】 gitbook 插件 图片查看【updated】 gitbook 插件 图标与LOGO【updated】 gitbook 插件 github【updated】 gitbook 插件 Emoji 表情【updated】 gitbook 插件 文本隐藏【updated】 gitbook 插件 TODO 代办【updated】 gitbook 插件 页面编辑【updated】 gitbook 插件 RSS【updated】 gitbook 插件 视频【updated】 gitbook 插件 SEO 【updated】 gitbook 插件 访问统计【updated】 gtibook 插件 顶部导航【updated】 gitbook 插件 主题【updated】 gitbook 插件 标签【updated】 gitbook 插件 pdf【updated】 gitbook 插件 阅读更多【updated】 gitbook 插件：音乐【updated】 accordion隐藏插件 Some title here Any content here 121321434345325243 324324324324324 %accordion%Some title here%accordion% Any content here 121321434345325243 324324324324324 %/accordion% 注：click-reveal插件，github仓编译校验不过 1.10.4. md、html 生成ok标准： md、html、md--> html 验证标准 html中搜索png，没有png、img出现 ---》所有的png图片都已经融入html中了 gitbook的 bug：不能以为行首 否则，会造成，后面的所有格式失效（包括图片） 例子： ​ md的source code模式： ​ html： 方法： 打破以 ...为首 比如：目到前面 比如： 加粗 比如：加任意字符 - 体会： md看问题，一定要在source code模式下看，因为更本质 1.10.5. GitHub 1、git push 到gitHub失败： 方法：无需关闭代理 git config --global http.proxy \"\" 注意：上述方法，网页访问速度没有改善 ----》技巧：用手机看网页 1.10.6. 优化之book sm 自动生成Summary.md文件 https://www.jianshu.com/p/4471c20fbafe Gitbook使用教程 - Summary插件：`npm install -g gitbook-summary` 1.11. EA 1.11.1. 自动生成类图 目的 (1)找出主要类（以及主要调用方向） (2)包之间依赖关系 (3)初步判断信息流向 方法： https://www.codenong.com/cs107101145/ 1.11.2. 以java文件的粒度，创建 导入一个class 模型 技巧：class模型 ---> 自动生成方法签名 ---> copy 以java文件的粒度,导入一个class 模型: 很快速 注意: 可以同时生成多个class模型-----》 ctrl+点击多个类模型 1.11.3. EA中边界框架的添加方法 见docker 1.11.4. EA的缺点： 没有重点!!!!---》 1、所以，手动画，一定要突出重点 2、TODO: EA是否能改变呢？ 1.12. Edraw https://www.edrawmax.cn/support/ShapeOperation/ShapesOperation 1.12.1. 1、技巧：edraw的组合 -----> 可以用来定制自己的view组件 ----->后面可以重复利用了~~ 1.12.2. 2、自定义view组件存储的地方： 1.12.3. 3、技巧：选中主题，有外框和标注 1.12.4. 对齐与大小同步 使用方法： 1、选择多个元素 2、Tab键选择标准 3、点击按钮 1.12.5. 画图基本元素 选用下面这个。原因：文字框在实体框内部 文字框在实体框外部：错误，禁止使用 总之，使用给定的元素，尽量不要自己造元素 1.12.6. 链接线不允许手动画 自动向四个方向延展： 1.12.7. 格式刷 刷链接线 万不得已，不要自己组合元素 -----> 这样后期，格式化可以统一刷 1.12.8. 文字如何统一修改格式？ 框选多个元素 1.12.9. 如何统一修改框的格式 方法一： 框选多个，统一修改 方法二：格式刷 1.12.10. 亿图截图方法 不要直接截图，而是选中，复制+粘贴 ------》 极优：高清 1.13. Andriod Code Search ------》下面一切都是围绕着搜索，一切为了搜索方法 https://cs.android.com/ 1、查看某一笔提交的所有改动：场景：安卓所有改动点，Z侧这些点也要注意！！！！！ 2、返回与前进：相当于AS的返回与前进！！！ 3、文件的结构： 4、查看某一行的最新改动的提交 5、所有历史提交！！！！！ 6、 1.14. Everything 1.14.1. 限定路径搜索 1.15. Typora 1.15.1. 快捷键 参考：https://www.jianshu.com/p/ca2d0420c9ea Typora 快捷键 shortcut keys 1、Ctrl+K, 创建超链接： // 自动生成： [创建超链接](#id22) 1、超链接被链接CTR + L (与Ctrl+K搭配使用) // 自动生成： 被链接 原理： 2、Ctrl+T, 创建表格 3、Ctrl+shift + K, 创建代码框： 4、Ctrl + shift + Q ：引用quota 5、 Ctrl + Shift + V Paste As Plain Text ---> 自然 5、自定义的热键 ---》 TODO: 提炼所有软件自定义热键的方法，以后可以在各个软件里自定义热键了！！！！！！！ 对于Typora.exe有： 1.15.2. Typora 设置标题自动编号 修改github.css： #write { max-width: 1024px; } body { counter-reset: body; } /* 正文标题自动序号 */ h1 { counter-reset: h1; } h2 { counter-reset: h2; } h3 { counter-reset: h3; } h4 { counter-reset: h4; } h5 { counter-reset: h5; } h6 { counter-reset: h6; } h1:before { counter-increment: body; content: counter(body) \" \"; } h2:before { counter-increment: h1; content: counter(body) \".\" counter(h1) \" \"; } h3:before { counter-increment: h2; content: counter(body) \".\" counter(h1)\".\" counter(h2) \" \"; } h4:before { counter-increment: h3; content: counter(body) \".\" counter(h1)\".\" counter(h2)\".\" counter(h3) \" \"; } h5:before { counter-increment: h4; content: counter(body) \".\" counter(h1)\".\" counter(h2)\".\" counter(h3)\".\" counter(h4) \" \"; } h6:before { counter-increment: h5; content: counter(body) \".\" counter(h1)\".\" counter(h2)\".\" counter(h3)\".\" counter(h4)\".\" counter(h5) \" \"; } /* 侧边大纲自动序号 */ .sidebar-content { counter-reset: h1 } .outline-h1 { counter-reset: h2 } .outline-h2 { counter-reset: h3 } .outline-h3 { counter-reset: h4 } .outline-h4 { counter-reset: h5 } .outline-h5 { counter-reset: h6 } .outline-h1>.outline-item>.outline-label:before { counter-increment: h1; content: counter(h1) \" \" } .outline-h2>.outline-item>.outline-label:before { counter-increment: h2; content: counter(h1) \".\" counter(h2) \" \" } .outline-h3>.outline-item>.outline-label:before { counter-increment: h3; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \" \" } .outline-h4>.outline-item>.outline-label:before { counter-increment: h4; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \" \" } .outline-h5>.outline-item>.outline-label:before { counter-increment: h5; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \" \" } .outline-h6>.outline-item>.outline-label:before { counter-increment: h6; content: counter(h1) \".\" counter(h2) \".\" counter(h3) \".\" counter(h4) \".\" counter(h5) \".\" counter(h6) \" \" } /* TOC 自动序号 */ .md-toc-inner { text-decoration: none; } .md-toc-content { counter-reset: h1toc } .md-toc-h1 { margin-left: 0; counter-reset: h2toc } .md-toc-h2 { margin-left: 1rem; counter-reset: h3toc } .md-toc-h3 { margin-left: 2rem; counter-reset: h4toc } .md-toc-h4 { margin-left: 3rem; counter-reset: h5toc } .md-toc-h5 { margin-left: 4rem; counter-reset: h6toc } .md-toc-h6 { margin-left: 5rem; } .md-toc-h1:before { counter-increment: h1toc; content: counter(h1toc) \" \" } .md-toc-h1 .md-toc-inner { margin-left: 0; } .md-toc-h2:before { counter-increment: h2toc; content: counter(h1toc) \". \" counter(h2toc) \" \" } .md-toc-h2 .md-toc-inner { margin-left: 0; } .md-toc-h3:before { counter-increment: h3toc; content: counter(h1toc) \". \" counter(h2toc) \". \" counter(h3toc) \" \" } .md-toc-h3 .md-toc-inner { margin-left: 0; } .md-toc-h4:before { counter-increment: h4toc; content: counter(h1toc) \". \" counter(h2toc) \". \" counter(h3toc) \". \" counter(h4toc) \" \" } .md-toc-h4 .md-toc-inner { margin-left: 0; } .md-toc-h5:before { counter-increment: h5toc; content: counter(h1toc) \". \" counter(h2toc) \". \" counter(h3toc) \". \" counter(h4toc) \". \" counter(h5toc) \" \" } .md-toc-h5 .md-toc-inner { margin-left: 0; } .md-toc-h6:before { counter-increment: h6toc; content: counter(h1toc) \". \" counter(h2toc) \". \" counter(h3toc) \". \" counter(h4toc) \". \" counter(h5toc) \". \" counter(h6toc) \" \" } .md-toc-h6 .md-toc-inner { margin-left: 0; } 1.16. 所有软件自定义热键的方法 安装 AutoHotkey软件 1.17. 屏幕亮度/对比度 软件调节 Monitorian https://blog.csdn.net/acecandy/article/details/126058229 1.18. 屏幕分区软件MaxTo 见： I:\\working_pan\\softWare\\MaxToSetup151110 使用： https://maxto.net/zh-hans#pricing 优点： 1、自定义分区大小 1.19. 反编译工具 jadx-1.4.7 优点：1、界面化操作。拖动即解析 ​ 2、完美的把.apk向下解析了 ----> source code 2. 计算机其他问题及设置 2.1. 软件最优的使用方式----免安装 有很多优点： 1、一次破解，终生使用 2、一台机器安装，所有机器都可以使用 3、规避安装需要管理员权限（不需要安装） 4、越过安装复杂的流程 5、可以放在任意盘里，即使U盘 ---------------------> 平时记得把大型复杂的软件都保存成免安装软件 2.2. 删除文件/文件夹，有进程正在占用 比如： 删除H:\\docker_install\\DockerDesktop\\DockerDesktop.vhdx 出现报错：文件被占用 方法： 在Handles中搜索 DockerDesktop.vhdx （很有可能搜不到，因为handle的是上一层文件夹、上上一层文件夹） 如果不行，搜索上一级 DockerDesktop 2.3. 蓝牙设备添加 2.4. 磁盘修复及优化 1、修复： 参照： https://www.reneelab.com.cn/m/external-hard-drive-repair-software.html // cmd， x盘符 chkdsk X: /r /f 2、优化： 2.5. 装最纯净的win10系统 https://zhuanlan.zhihu.com/p/219902401?utm_source=wechat_session 为什么要用最纯净的win? 1、稳定，驱动没有被其他软件更新过，不容易蓝屏 2、很干净，cpu使用率极低： 2.6. 常见最优设置 2.6.1. 剪切板，多个历史 复制值 优： 剪切板，多个历史 复制值 选择粘贴： 2.6.2. 双屏，次屏幕隐藏任务栏 空间更大 2.7. 垃圾 目前没有完成的磁盘： H盘 2.8. 蓝屏问题 1、用纯净的系统，不要更新驱动 2、磁盘修复 3、超频有可能造成蓝屏 4、硬件问题 2.9. 电脑wifi经常掉 wifi的驱动，禁止关闭 2.10. 网络较慢 1、360安全卫士解决一下 2、使用外置的无线网卡。记得控制面板里选择 3、使用 ipv4，关闭ipv6 2.11. 关于HDMI连接 无响应 很可能是HDMI驱动出了问题 不一定是硬件问题 2.12. 远程桌面 2.12.1. 远程电脑 访问 本地电脑磁盘的方法 方法一：将本地的 磁盘driver 挂到远程电脑上 效果：H盘挂过来 注意： 可以直挂部分磁盘 方法二： 共享文件夹 3. 格式 折叠 网站上显示能折叠图片 其他折叠： 点击显示答案 折叠图片不是太方便。。。。适合折叠文字 Want to ruin the surprise? Well, you asked for it! console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/sourceInsight.html":{"url":"coding/Tool/sourceInsight.html","title":"Source Insight","keywords":"","body":"1. source insight1.1. 优缺点：1.2. TODO:com 导入工程1.3. 一些设置1.3.1. search Bar保留1.3.2. 选中高亮：1.4. 快捷键：1.4.1. 多行注释1.4.2. recent file：1.4.3. 查看调用点1.5. 查找关键字1.6. 查看当前文件所处的位置1.7. 背景色设置1.8. 参考：TreeviewCopyright © aleen42 all right reserved, powered by aleen42 source insight 优缺点： TODO:com 导入工程 一些设置 search Bar保留 选中高亮： 快捷键： 多行注释 recent file： 查看调用点 查找关键字 查看当前文件所处的位置 背景色设置 参考： [TOC] 1. source insight 1.1. 优缺点： 优点： 1、极优：可以source 两个完全不同路径下的代码 （自然，可以取整个aosp多个小部分代码）。AS的source code 必须在工程目录下！！！ 2、内存使用是AS的二十分之一 极优 3、可以同时java和cpp同时跳转！ 极优 4、不需要像AS与clion，需要事先搭建一个可以编译环境，然后copy代码 5、对于远程服务器代码，不需要copy！！！！（由第一点决定！！！） 极优 6、看代码大杀器-----java、cpp、c同时OK ​ 缺点： 断点调试不行？？？？------> 办法：与AS结合使用！ 1.2. TODO:com 导入工程 重点：需要sync(否则，两个文件之间无法跳转) 1.3. 一些设置 1.3.1. search Bar保留 1.3.2. 选中高亮： 1.4. 快捷键： 文本replace （当前文件）------> 修改为 ctrl + R ​ 全局替换 ----------》 修改为 ctrl + shift + R close file --------> ctrl + W copy file path -------> ctrl +shift + c ctrl + O : open这个window ​ 1.4.1. 多行注释 法一： Source Insight4.0已有多行注释功能： 注释：ctrl + / 反注释：加shift 法二：利用宏macro 快捷键： ctrl + / macro MultiLineComment() macro MultiLineComment() { hwnd = GetCurrentWnd() selection = GetWndSel(hwnd) LnFirst =GetWndSelLnFirst(hwnd) //取首行行号 LnLast =GetWndSelLnLast(hwnd) //取末行行号 hbuf = GetCurrentBuf() if(GetBufLine(hbuf, 0) ==\"//magic-number:tph85666031\"){ stop } Ln = Lnfirst buf = GetBufLine(hbuf, Ln) len = strlen(buf) while(Ln 参考： https://it.cha138.com/tech/show-390752.html https://jingyan.baidu.com/article/90808022d313a2fd91c80f93.html 1.4.2. recent file： -----> TODO：快捷键一直不生效 退而求其次的方法： 1、快捷键CTRL + E ------> File menu 2、把 recent file至于File menu第一个，便可以键盘切换recent file 3、效果： 1.4.3. 查看调用点 或： 1.5. 查找关键字 如果 关键字是符号 ，比较快 -------> SI之前已经做好了 如果不是，会很慢（比AS慢很多）-------> 可见，AS是加载了所有文件，而SI只是符号表 技巧： 通过左右来遍历搜索结果，不用切换到results文件 1.6. 查看当前文件所处的位置 打开同级其他文件，也很方便 1.7. 背景色设置 1.8. 参考： https://www.dandelioncloud.cn/article/details/1578906401210855426 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/tmux_linux.html":{"url":"coding/Tool/tmux_linux.html","title":"Tmux Linux","keywords":"","body":"1. 为什么要用tmux？2. 安装3. 使用3.1. 会话的结构：3.2. 第一次新建会话：3.3. 终端下，进入之前的会话3.4. 在会话环境下，切换4. 优的环境：5. 最优的环境TreeviewCopyright © aleen42 all right reserved, powered by aleen42 为什么要用tmux？ 安装 使用 会话的结构： 第一次新建会话： 终端下，进入之前的会话 在会话环境下，切换 优的环境： 最优的环境 [TOC] 1. 为什么要用tmux？ 应用场景： 通过本地终端 ---->对 远端服务器做耗时操作时（长时间编译、长时间下载） tmux作用： 1、本地的休眠、本地终端的关闭、网络的中断， 不会影响到远端 注：通过本地终端让远端执行命令: 本地终端的关闭，会终止远端的Task进程 ​ 即，本地终端 与 远端task 绑定了 2、窗口共享给其他人，可以同时看到运行的情况，比如： tmux原理： 1、远端永久运行（不存在绑定关系） 并保存 命令执行结果 2、本地端只是显示远端运行 结果 + 通过会话 发送命令 规定： 以后必须用tmux，不允许直接使用 2. 安装 sudo apt-get install tmux 3. 使用 3.1. 会话的结构： 可见， 1、有五个会话： 1、2、3、4、mySession 2、会话2下有 3个窗口 3、当前本地终端attched是会话2（注意：本地终端有两个，可以attached两个） 那么，会话和窗口，分别是什么应用场景？？？ 一个会话下，有多个窗口 ------> 有什么好处？ 弊端：要不停切换窗口，不能一直显示 3.2. 第一次新建会话： tmux new -s my_S 彻底销毁会话： //法一： tmux kill-session -t [会话名] // //法二：会话中， ctrl+d d------delete 新建窗口： ctrl+b c 3.3. 终端下，进入之前的会话 1、在终端环境中，查看有哪些会话： tmux ls 2、进入： tmux a -t [会话名] // tmux a -t mySession 退出： 3.4. 在会话环境下，切换 规律： 在会话环境下，执行任何命令，都是以 ctrl+b 为开头 切换会话： ctrl+b s 切换窗口：星号是当前 ctrl+b 1 4. 优的环境： 两个本地终端 + attached 两个会话 5. 最优的环境 由于tmux，不容易看到过程日志 -----> 最优的环境，就是不用tmux ------> 方法： 直接让本地pc永远不休眠（适合公司电脑） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/virtualStudioCode.html":{"url":"coding/Tool/virtualStudioCode.html","title":"Virtual Studio Code","keywords":"","body":"1. 快捷键2. vs code优秀的点2.1. 多个符号高亮的插件2.2. 可以显示代码调用栈显示TreeviewCopyright © aleen42 all right reserved, powered by aleen42 vs code优秀的点 多个符号高亮的插件 可以显示代码调用栈显示 1. 快捷键 Ctrl + P 打开指定文件 Ctrl + G 跳转指定行 Ctrl+T 跳转符号表 F8 高亮 向前、后: alt+左右 当前页面查找：Ctrl + F 技巧: 工作区——》查找符号引用会减少 隐藏文件夹 符号调用栈 查找函数调用 2. vs code优秀的点 2.1. 多个符号高亮的插件 MultiHighlight 注意：可以修改keyMap （keyMap中搜索 MultiHighlight） AS 有同样的MultiHighlight 2.2. 可以显示代码调用栈显示 AS 有同样的Hierarchy console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"coding/Tool/稳定性_性能问题.html":{"url":"coding/Tool/稳定性_性能问题.html","title":"稳定性_性能问题","keywords":"","body":"1. 稳定性问题2. 性能问题TreeviewCopyright © aleen42 all right reserved, powered by aleen42 性能问题 1. 稳定性问题 例子：AS attach 系统进程，系统直接重启 分析： 2. 性能问题 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"English/English.html":{"url":"English/English.html","title":"English","keywords":"","body":"1. 写：2. 读2.1. 央化[ə]弱读的一种2.2. 央化[ə]：读弱2.3. 音标TreeviewCopyright © aleen42 all right reserved, powered by aleen42 读 央化[ə]弱读的一种 央化[ə]：读弱 音标 1. 写： 2. 读 th 不发音，连读 比如： I got in there myself once 2.1. 央化[ə]弱读的一种 you're we're ---》同your They're I have done it! I've done it! 一个人的听力，就是他的口语 2.2. 央化[ə]：读弱 英语要有主次： People say that communication is the key to any relationship. -------> that：thət -------> to：tə People don't say that. ---》强调：读 that Women say that ---》强调：读 that so that ---》强调：读 that once 次 of // 弱读 是 əv 重读是 2.3. 音标 ɑː ɔ: ɜː i: u: ʌ ɒ ə ɪ ʊ e æ eɪ aɪ ɔɪ ɪə eə ʊə əʊ aʊ p t k f θ s b d g v ð z ʃ h ts tʃ j tr ʒ r dz dʒ dr w m n ŋ l console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Investment/Investment.html":{"url":"Investment/Investment.html","title":"Investment","keywords":"","body":"1. 投资1.1.1. 投资原则：1.1.2. 任何一件大事情，背后都会有经济活动1.1.3. 面向对象的思想：1.1.4. 区分突发性影响和永久性影响1.1.5. 段永平1.1.6. 倾城1.1.7. 林园：1.1.8. 买基金原则，朱少醒：1.1.9. 巴菲特：1.1.10. 高瓴1.1.11. 战争TreeviewCopyright © aleen42 all right reserved, powered by aleen42 投资原则： 任何一件大事情，背后都会有经济活动 面向对象的思想： 区分突发性影响和永久性影响 段永平 倾城 林园： 买基金原则，朱少醒： 巴菲特： 高瓴 战争 1. 投资 1.1.1. 投资原则： 找现在不合理，而未来又是必然的 1.1.2. 任何一件大事情，背后都会有经济活动 ------>！！！！（思考自己可以做的事情，大局观，不要隐隐狗狗！！！） 对于大的行业而言--> 看行业线，行业能把握 瘟疫引起的: 增长是好事，萧条更是好事儿 回去画图，推理 小的东西看不到，但是大的东西是必然的，可预测的，所以，一定对大的东西不要麻木 比如，美国大选宣布总统，诺安八个点，这个我遇见了。。。但是没能及时卖掉 认知认知认知 站在2019年11月份，根据瘟疫可以预测：假设疫情时间一年（医疗、娱乐、互联网） 真实的： 娱乐行业： 有几个必然： 1、大的事件必然会引起波动：积极影响的行业、消极影响的行业---> 遇到社会性的大事，一定要与全行业联想 2、对积极影响的行业能赚钱：前期重仓买入 《---- 因为增长是必然的 3、对消极影响的行业，更容易挣钱，更保险 ----> 前期的下降必然的，后期因素消除更是必然，只是时间线有些长！！！！ ，所以长期定投这些行业 后期恢复更是必然！！！！ 4、疫情，同样也可以用于买房 1.1.3. 面向对象的思想： ------>要把所有发生的事情（对象）、与自己（对象）链接！！！！！！ 1.1.4. 区分突发性影响和永久性影响 对于突发性的大事件，如果长期一定会恢复-----> 这种稳赚不赔 永久性影响，比如公司业务逻辑变了-------> 永远不要碰！！！ 1.1.5. 段永平 抄段永平的作业！！！！ ----> 3月16号，腾讯股价增长22% 1.1.6. 倾城 一直预测2022年上半年一直下跌，准确预测到真正的底部，而不是阶段的底部！！！！！！！ 2022/5/2: 赛道股：白酒、医药、权重蓝筹，先涨，后面补跌 区别对待美股与中股1！！！！！ 中股票，所有消息，只是为了解释而找来的消息！！！！！涨跌与经济无关！！！！只与资金有关！！（国家放水、主力资金） 1.1.7. 林园： （1）未来30年医疗是主线！！！未来三年（21-24），医疗至少翻一番 （2）买垄断性公司！！！ 1.1.8. 买基金原则，朱少醒： 1、主要看好长期（3-5年以上）历史业绩都不错的基金经理：富国朱少醒、易方达张坤、交银三剑客 2、不要买太多基金：4-10个分散行业 3、长期持有, 三年以上维度！！！！！！！！！！！！！！！！！不适合短线！！！！朱少醒：我们不能买股票，如果你放在三年以上的时间维度，都应该投权益资产，三年以下就比较难说了。(放到10年以上)毫无疑问是权益资产，可以更集中到那种更长期优质的资产，你觉得置信度最好的公司，跟着公司一起慢慢变富。 4、一定要克制人的天性：追涨 + 杀跌！！！！杀跌是大忌!!!!!!! 5、 6，聪明投资者：你这12年来最赚钱的股票是什么？ 　　朱少醒：我平时不怎么看那个东西。 　　不知道你有没有看过一书上的说法，小孩画画通常有两种完全不同的状态：有的小孩边画边撕，画完就撕；还有的小孩画好了，稍好一些好的保存在那边。可能到最后，所有的画里，画的更好的是前者。投资和这个有点类似。我可能对过去的“亮点”不是特别在意，更多是看过程和未来，我享受过程，在这个过程中，反而有些教训，我会记得更清楚 从逻辑上看，最赚钱的应该是拿得最久的股票 12，聪明投资者：你一般会招什么样的人？ 　　朱少醒：研究员首先是品性要求，好的研究员还要独立思考，有开放的心态、很强的好奇心，做事有很强的韧性。智商在这个行业内从来不是瓶颈，做事情的坚韧度和毅力很重要 关于卖点：不可控的错误和可控的错误 　　15，聪明投资者：你怎么判断卖点？ 　　朱少醒：成长类投资的卖点，其实是带有艺术成分的，比较难量化、难有明确规则。 　　第一，不断去review原来的投资框架，买入之后，逻辑有没有发生变化。 　　然后，估值有没有达到你的判断，对于成长公司来讲，这方面的权重要稍微低一些，因为犯错概率也挺高的 喜欢纯粹专注把事情做到极致的人 　　29，聪明投资者：海内外，你最欣赏的投资人是谁？ 　　朱少醒：对我影响比较深的，是巴菲特和彼得林奇，可能我翻彼得林奇的书比巴菲特多一点，因为他跟我公募的行业属性有关 32，聪明投资者：你的价值观是什么？ 　　朱少醒：我没归纳过。我觉得，做投资可能跟做人方式有关，无论是我们公司的Business、还是投资，我都希望看得长远。第二，我比较喜欢能够非常纯粹专注把事情做到极致 35，聪明投资者：有时候热爱它，是因为成功给了你正反馈，会不会也是一种求证陷阱，制约了你尝试新的可能？ 　　朱少醒：只是享受成功带来的荣耀，跟热爱不一样。热爱就是你甚至没有看到曙光，老是碰壁，各种怀疑的时候，你觉得我就是喜欢，还能坚持，这才算。 1.1.9. 巴菲特： （1）赌指数基金就是赌国运 （2）只有傻子和偏执狂 才去预测市场的顶部和底部（即：方向大致正确！！！！！）不要看一时的涨与跌 价值投资《-------> 找市场中的便宜货（便宜指的是，价格/真实价值 低！！！！，不是价格低！！！） 如何找便宜货？ （1）所有人都恐慌的时候 ----> 绝大部分声音 1.1.10. 高瓴 ----> 逻辑：为什么要抄高瓴？？？因为高瓴价值投资！！！持有几年，所以季度报告延迟不影响！！！！（所以，林园不适合抄作业！！！） 关注：1、最大重仓股 2、大量新增最大重仓股！！！！3、大量减持 抓住主次----> 大量！！！！！ 减持的案例： 三季度，即在9月前卖掉的，10月底的新闻 ----> 最终可以看出，在9月10月走掉是很好的！！！ 为什么要抄袭？？？？因为我们与大机构信息不对称！！！！！！！ 1.1.11. 战争 乌克兰战争，会导致总体下降！！！ -----> 但是，黄金，原油会大涨（不是石油！！！） 2022年2月24日15时，据法新社消息，俄罗斯地面部队进入乌克兰。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Naturalaw/":{"url":"Naturalaw/","title":"Naturalaw","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Naturalaw/ReadingAndThinking.html":{"url":"Naturalaw/ReadingAndThinking.html","title":"Reading And Thinking","keywords":"","body":"1. 目录2. 开篇宗义3. 思考3.1. 结构3.1.1. 结构是更本质的东西3.1.2. 结构之-------主次3.1.3. 结构之-------锚3.1.4. 认识结构的工具3.1.5. 结构之-------化简3.2. 结构应用----之思想结构3.3. 抽象与具体3.3.1. 抽象是个骗子3.3.2. 抽象 是圭臬，是化简的有利工具3.3.3. 抽象与具体，两条腿走路才能走远3.3.4. 应用：学习之抽象 与 具象3.3.5. 工具：拆解抽象-----具体到数字3.4. 思考模式、驱动模式3.5. 思想工具：3.5.1. 如何深刻？3.5.2. 第一性原理3.5.3. 背后的背后、原理的原理3.5.4. 描述事物的工具--------SCQA模型3.5.5. 描述事物的工具--------5W2H3.5.6. 追问问题的根本原因------5Why3.5.7. 思想工具之 复利/复制/继承性3.5.8. 思想之化简3.5.9. 化简推论：重要的只有一个3.5.10. 这世间最不可靠的就是意志力3.5.11. 分析人的三模型3.6. 技巧3.7. 生活化模型----理解、记忆的利器3.8. 人生架构3.9. 学习如何学习3.9.1. 学习动力与阻力3.9.2. 学习之无招胜有招3.9.3. 无招胜有招之目的论3.9.4. 无招胜有招之链接实操3.9.5. 如何化简？3.9.6. 学习之底层逻辑3.9.7. 学习之 以问题、面试问题驱动3.9.8. 学习知识之各个维度------拆解|切割3.9.9. 学习效果拆解 &checkList3.9.10. 学习材料3.10. 分析、理解、记忆的工具----目的论3.10.1. 写技术文章（流程性）的结构一3.11. 写技术文章的结构二3.12. 如何在一个领域做到顶尖？3.13. 心理3.13.1. 立志3.13.2. 心流3.13.3. 空杯心态3.13.4. 焦虑3.13.5. 假装3.13.6. 比较3.13.7. 表达是门技术 ---> 需要去研究3.13.8. 关于选择3.14. 其他小点3.14.1. 每前进一步，把之前所有方法再轮一遍3.14.2. 每天给你自己暗示，3.14.3. 永远不要用毅力、努力，3.14.4. 对比，一定要强烈、一定要客观3.14.5. 坚持输出，以输出倒逼理解！3.14.6. 跟对人、读好的书、好的csdn3.14.7. 如何深刻？学习、知识、理解3.14.8. 积木思想：3.14.9. 问题3.14.10. 执行力3.14.11. 绩效问题：3.14.12. TODO：3.14.13. 对个人成长无益3.14.14. to整理4. 道，天道5. 精力管理5.1. 降低消耗5.1.1. 他耗：5.1.2. 内耗5.1.3. 抓大放小5.2. 睡眠5.3. 内与外 的关系5.4. 极简主义 与 扣5.5. 到底要不要 一个光鲜的外壳？5.6. 关于心态、心境--------动力问题6. 时间管理7. 阅读7.1. 为什么要读书？读完书就忘7.2. 书单7.3. 如何训练思维的深度？7.4. 思考快与慢：7.5. 穷查理宝典7.6. 如何成为技术领域的高手？7.7. 大家&大书7.8. 不要骗自己-------费曼方法7.9. 费曼学习法更一般的理论7.10. 教育7.11. 性8. 管理8.1. 管理他人8.2. 自我管理8.2.1. 每周checklist8.2.2. 时间管理9. 文章&演讲 list9.1. 丘成桐9.2. 陆奇10. 表达10.1. 普通聊天如何缓解尴尬？11. 翟东升2021年预测TreeviewCopyright © aleen42 all right reserved, powered by aleen42 开篇宗义 思考 结构 结构是更本质的东西 结构之-------主次 结构之-------锚 认识结构的工具 结构之-------化简 结构应用----之思想结构 抽象与具体 抽象是个骗子 抽象 是圭臬，是化简的有利工具 抽象与具体，两条腿走路才能走远 应用：学习之抽象 与 具象 工具：拆解抽象-----具体到数字 思考模式、驱动模式 思想工具： 如何深刻？ 第一性原理 背后的背后、原理的原理 应用一：成瘾机制分析 学习知识 如何成瘾？ 成瘾机制的消除 描述事物的工具--------SCQA模型 描述事物的工具--------5W2H 追问问题的根本原因------5Why 思想工具之 复利/复制/继承性 思想之化简 为什么要化简 如何化简？ 一些好的化简的例子 生活、记忆化简之 合并同类项 化简推论：重要的只有一个 这世间最不可靠的就是意志力 分析人的三模型 执行模型 技巧 生活化模型----理解、记忆的利器 人生架构 学习如何学习 学习动力与阻力 动力： 成瘾-----奖励机制 阻力：缓解痛苦 学习之无招胜有招 无招胜有招之目的论 无招胜有招之链接实操 如何化简？ 学习之底层逻辑 学习之 以问题、面试问题驱动 学习知识之各个维度------拆解|切割 学习效果拆解 &checkList 学习材料 分析、理解、记忆的工具----目的论 写技术文章（流程性）的结构一 写技术文章的结构二 如何在一个领域做到顶尖？ 心理 立志 心流 空杯心态 焦虑 假装 比较 表达是门技术 ---> 需要去研究 关于选择 其他小点 每前进一步，把之前所有方法再轮一遍 每天给你自己暗示， 永远不要用毅力、努力， 对比，一定要强烈、一定要客观 坚持输出，以输出倒逼理解！ 跟对人、读好的书、好的csdn 如何深刻？学习、知识、理解 积木思想： 问题 执行力 绩效问题： TODO： 对个人成长无益 to整理 道，天道 精力管理 降低消耗 他耗： 内耗 抓大放小 睡眠 内与外 的关系 极简主义 与 扣 到底要不要 一个光鲜的外壳？ 关于心态、心境--------动力问题 时间管理 阅读 为什么要读书？读完书就忘 书单 如何训练思维的深度？ 思考快与慢： 穷查理宝典 如何成为技术领域的高手？ 大家&大书 不要骗自己-------费曼方法 费曼学习法更一般的理论 教育 性 管理 管理他人 自我管理 每周checklist 时间管理 文章&演讲 list 丘成桐 陆奇 表达 普通聊天如何缓解尴尬？ 翟东升2021年预测 1. 目录 [TOC] 2. 开篇宗义 写文字是为了修剪脑袋（释放脑袋）， 同时也是为了修剪笔记本身（提取主次） -------> 所以，最终都是为了遗忘。。。。为了本质与真 希望，你的笔记越记越少 规定： 笔记里任何一句话，不超过十五个字 (多余的以括号形式补充) ------> 以突出核心，增强阅读性 3. 思考 3.1. 结构 3.1.1. 结构是更本质的东西 任何事物（无论抽象、具象），最重要的是结构。 土木结构，软件结构，人脑结构，思维结构，社会结构，收入结构 1、结构决定功能 有了结构，功能是自然的事情。（比如，代码所有类都new出来了，之间的相互功能，以及时序都是自然的。。。。再比如，排兵布阵好了，怎么工作也是自然的。。。再比如，车能跑，因为圆形轮子结构）物体如此，代码如此，社会组织更是如此。 2、结构决定行为 A是B的妈妈（家庭结构），所以A抚养B。李yang是杨qichao圈子人，所以，一直重用他。Window 在结构上包含了view体系，所以event最先是流过window，然后到rootView的 再例，屁股（结构）决定脑袋（行为想法） 3、认知与结构。认知，主要是认知结构！！！！！每一次对结构的严重冲击是好事。比如盲人摸象 代码结构，与代码流程，代码结构是更本质的东西 -------> 推论：1、基于结构，去做一切事情（去理解、去记忆、去认识、去画图、去推导、去设计、去分析原因） ​ 从结构上看问题，从结构上认识问题，从结构上想问题，万物皆结构！！ ​ 2、如果出错，一定是结构认识不清 ​ 3、时刻提醒自己，从功能、行为去反推 结构，比如：（虽然最初难以，认出结构） 行为：一个女人在给一个孩子喂奶 ------> 反推结构： 女人是孩子的母亲 ---------> 在生活中，人一定是主动反推了结构的。否则： ​ 无法理解后面女人给孩子换尿布的行为； ​ 无法理解后面女人抱着小孩子逗他玩的行为。 简之: 把握关键行为（喂奶） ----> 反推 结构 （母子关系） ----> 通过结构，去理解/推断其他行为（换尿不湿） 所以，理解代码也是如此： 关键行为----> 反推结构 4、其次重要的是，重要结构的创建过程 所有事物都是主干与次要部分。1、2、3不是好的组织方式。包括上面 软件结构要类比具体事物结构，尤其是树。 自然理解一件事情，要忘记一件事情。比如，计算机中如何组织大量数据？树怎么生长和组织了这么多叶子？ 理解.....的本质在于理解结构！！！！！（比如代码结构比功能，比时序更本质; 如何有个好绩效？？？？-----> 占据领导心中核心排名） 如果你下次不理解一些东西，问一问自己，它的结构是什么，你搞清楚了嘛？ 记忆更本质的东西 通过琐碎的问题，来看到整个结构。。。。。一定要有很多问题 如果无法组织成体系（内化为一句话），就无法真正驾驭、成为能力 一盘散沙的知识，越多越是祸害。背后的原因就是知识结构（柳冠中说过同样的话：知识是包袱。https://www.bilibili.com/video/BV1Sg411U73L/?spm_id_from=333.337.search-card.all.click 柳冠中《美的竞争力》 0:49:00位置 TODO: 总结他的方法。记性不好，但是能整合知识。但是能看到本质。） 结构是记忆与理解的锚点！我们记不住行为，从结构的角度记忆行为很好。。。。结构是静态的-----> 更容易记忆 关于记忆锚点的选择：记忆锚点尽量选择主结构，原因在于：可以从主结构推导次结构，反之则不行 做加法的同时，为什么要做减法？？？？----> 原因：化简出主干（记忆点） ------> 应用：做笔记，先写，再删 数学的结构和红楼梦的结构很像------丘成桐 鸡兔同笼问题，数学结构很美妙 -------- 杨振宁 前天刷短视频， 一位清华学子问杨振宁：怎么在20——30岁之间尽快找到自己的职业方向？ 杨振宁就举例了一个自己的小故事：小时候，父亲教他「鸡兔同笼」的数学题目，他学得很快；等到他做父亲的时候，他也教他的孩子「 鸡兔同笼」，孩子学得也很快。但唯一不同的就是：一年后，他的孩子已经完全不记得这些东西了，就好像从没学过一样，而他一直还记得。 杨振宁总结到：这不是训练出来的，就是自己天生对于数学结构的喜欢。一个人如果能够很早知道他对哪个方向是特别接近，这就有很大的好处， 或许就是未来值得去发展的方向。 你有天生的对于某些东西的「偏爱」，且对于「偏爱」能够加以训练和培养，就是人生重要的事业线。 3.1.2. 结构之-------主次 主次是贯穿于任何事情的！！！！！（要有这个意识） 抓住了主次，人生便有了锚 主要问题、主要矛盾、主要作业、主要流程 -任何事情，任何事物，都要问一句，1、结构是怎样的？？问一句，2、主次是怎样的？？？ 尤其是抽象的事情 -----> 比如，代码最主干的逻辑，买房子最主要的几个目的 执行：当分清了事物的主次，选两个以内（很多情况下，只能保证一个！！！！！！）的主次，保证这两个主要的事情达到目标即可，不管其他细节，最好不完美（这样证明两个主要的目标保证了） 例子1：买房的主次是什么？---> 增值+学区是首要的！！！！！ ​ 买合肥房子最大的失误是什么？省政府南迁，比地铁是主 ​ 上海房子没有学区，原因：那段时间学区房大降，学区政策还没定下来 例子2：每天干的事情的主次是啥？完成某一部分代码 不能因为修补房子，干了一天，恋于修正房子 例子3：简单粗暴往往很有效，比细致分析 ------> 抓住主 例子4：代数中，很多个参数，可以组成一个特征量？？？？？？？？？ 例子5：对于软件，软件架构+关键流程是主、骨架 ，代码是次、肉。 此外，软件的主和次是依附的关系，所以，软件应该很容易 思想：人对万事万物都要讲究主次（否则我们没法认识事物的），上帝也一样（泰勒展开） 抓不住主次的后果： 做事，越做越错。比如买房 学习，越学越糊涂。比如看代码，陷入细节，不能自拔 主次应用： 断舍离 抖音 参哥，创业相关： 1、不要被 有价值的 垃圾束缚住 ---------》 次要东西要舍弃 2、在一个屎一样的赛道竞争（仅限于创业？），只能获得一坨屎 ----》 因为主是塞到 3、越聪明的人越简单（即：考虑的越复杂，这个人越蠢） -------> 创业如此、生活如此、学习也如此 4、确认一个项目是不是好的项目：只要看这个领域是否有人赚钱了 ​ ----------> 不要去分析，因为客观因素太多了，无穷无尽 5、如何成功？--------> 抄。简简单单，且容易成功 ​ ----------> 这个就是模板的作用 + 复制思想 6、君子不利于危墙之下 7、一个人最大的难点在于，知道自己的边界在哪里？？？ 3.1.3. 结构之-------锚 很多时候，主次可以提现锚 3.1.4. 认识结构的工具 如何认识结构？如何区别结构的主次？如何避免分析过程中的遗忘甚至颠倒主次？ 思维导图 3.1.5. 结构之-------化简 人不可能理解、记忆复杂的东西： 唯有 折叠/化简 展开（链接） 一个普通结构，人 只有具体才能理解，只有抽象才能记忆 -规定：任何抽象（抽象结论），下面要有例子； 任何一个典型例子，要总结其抽象 ---> 使用于理解、记忆、记笔记 太阳底下无新鲜事情----》 所以，发明是抽象在具体中迁移 ​ 比喻也是 化简的极致/抽象的极致，应该是忘记 过河弃伐 3.2. 结构应用----之思想结构 应用层思想：技巧集（说话技巧），方法集、工具集、思想工具集（比如比喻、先假设） 中层思想：本质、思想集（解耦思想、正反馈机制思想） 底层思想：自然法则集、必然性 上下关系（如类继承一样）： 1、越是底层： 通用性越好，越抽象（越能涵盖更多）、个数越少 ​ 越是顶层：通用性差，针对性好 ​ 2、下是上的支撑逻辑（抽象），上是下的具体（应用） ​ 3、形成过程：上层抽象形成下层，下层指导上层具体实践 比如： 能让你眼前一亮，或者是好用的工具/方法，背后一定存在着好的抽象、好的自然法则 ----> 注意总结 3.3. 抽象与具体 3.3.1. 抽象是个骗子 1、要十分警惕抽象，因为抽象是极具欺骗性的。 ---> 比如，安卓调的。让我们以为自己懂了，骗了自己：安卓的什么调的？时机是什么？为什么会调？从整个流程来看，调用的不得不在哪里？ 所以，一定要 防止被骗 2、抽象具有模糊性。 比如：兴趣是最好的老师，每个人都知道，但是99%的人仍然学不好。-------》 问题出在哪里？ 兴趣如何理解？具体包括？获取兴趣的具体步骤是啥？ 一个“兴趣”词语，毁掉一个智慧真理，障碍了人心 比如：文字本身就是抽象，就非常具有模糊性。。。。一个人可以洋洋洒洒说一万字，可是空无一物 比如：大家都一直说，看问题要抓本质。但是很多时候，仅仅停留在本质这个词上，不得进一步 正因为 抽象具有模糊性，所以，不同人对抽象的不同理解与实践，早就了不同的认知水平、人生： 比如： ​ 科学家眼里的 “为人民服务” -------> 具体理解：一生奉献在事业上，死在事业上的勇气 ​ 正课眼里的“ .....................” -------> 具体理解：口号，话术 ​ 普通人，，，，，， 推论： 想打马虎眼，可以说一些抽象、大的话 3.3.2. 抽象 是圭臬，是化简的有利工具 3、要奉 抽象 为圭臬，因为 抽象才能升华、才能无招胜有招（举一反十）、才能举重若轻、才能轻松。 TODO: 例子： 才能化简 -你的抽象能力（化简能力），决定你能cover多少事情（知识、能力）！！！！！ ----------》 学过之后，达到自然状态，然后忘记 3.3.3. 抽象与具体，两条腿走路才能走远 只有具体才能理解，只有抽象才能记忆 见下 只有抽象才能演绎（指导）， 只有具体才能执行： 比如知道 兴趣是最好的老师，都说烂了。但问题在于，如何找到具体路径让学生感兴趣、甚至沉迷呢？而不仅仅是念叨要 有兴趣、要专注.......... ---> 具体：正反馈，及时反馈。 ---> 再具体：见下 -如何让好的抽象发挥作用呢？TODO 规定： （1）所有的知识、结论、尤其真知灼见、至理名言，必须 抽象-具体的步骤（具象） 两方面来看 （2）抽象 -----具体 之间，给出走向具体的角度-------工具：5w2h分析工具 （3）很多时候，问题出在：意识中，以为是具体，实际上是抽象 ​ -------》 办法： 任何时候，用5w2h去检验？ ​ 比如： 结论之后（抽象），必举例子（具体） 李氏替换原则（抽象），设计模式（具体） 设计模式（抽象），具体安卓代码应用（具体） 兴趣是最好的老师（抽象），兴趣点是啥？培养步骤是啥？执行步骤是啥？（具体） 上山是抽象，选哪一条路、骑车上 是具体 （5why2How） 与别人沟通时，说了一个概念（抽象），具体这个概念的具体事情（具体）：只有说到具体，别人才能理解 与自己沟通时，比如要提高 沟通能力（抽象）: 从哪些方面？框架有哪些？有哪些技巧？什么时候说什么话？ （具体） 写技术文章时，自己经常性的提示词 “本质”，但是你写出来的东西，真的就能体现本质嘛？ 5w2h： what：本质从整体上规定事物的性质及其基本发展方向，本质由事物内部矛盾构成，是比较单一、稳定不变、深刻的东西，靠思维才能把握 how: 如何找到那么几十万行代码的本质？ ​ 规定了事物的性质 的角度： 一行关键代码 通知bindService以及拿到 对方Binder ，可以利用service了 -------》关键函数就一行 ​ 稳定不变的角度：要利用别人的服务， 任何语言，任何代码，任何系统，甚至是生活（拿到别人号码），都必然如此 ​ 深刻：体现了模型。拿到你的东西，才能利用你 where：Binder处于哪个线程？（一次binder，切换了很多线程，还有内核） ​ Binder 在安卓系统整体框架的位置（java-native-内核都有） ​ Binder在...................................地位 why： 不得不的： 各种通信方式，只有binder安全，又效率高 how: Binder 的机制 3.3.4. 应用：学习之抽象 与 具象 TODO: 总结 3.3.5. 工具：拆解抽象-----具体到数字 为了避免抽象欺骗我们（被自己骗）、必须学会拆解抽象，做一个高能量的人： 1、拆解高能量： （1）睡眠上 ：多少小时、什么时间睡 （2）身体锻炼上：多久跑一次步 （3）说话语气上：要有激情----五米以外要能听见 （4）心态上：挑战高难度任务 2、拿纸，记录上面每一条 -----> 每天看，并执行 3.4. 思考模式、驱动模式 对于重要的事情，持续问问题 ------->作为课题 然后写出答案（只有纸面上，才能在脑中成体系，才能清晰） 3.5. 思想工具： checkList：为什么难的事情，坚持不了，简单的事情，也坚持不下来？ ----> 1、大量简单的事情，如同满地珠子，总有很多会被遗忘 。利器：简短的checkList，周期性看 checkList是一根线，看似没价值，但是保证所有珠子都在思想的线上 3.5.1. 如何深刻？ 深刻是抽象的东西 规定：对重要的东西 1、了解怎么用 2、了解背后的东西（背后的原理） 3、理解背后的自然法则…（出去自然，别无他物）：为什么记不住？ 因为你感悟的深度不够，以至于理解上不自然—————》适用于一切 https://baijiahao.baidu.com/s?id=1743010636038377873&wfr=spider&for=pc 规定：对重要的东西，必须给出背后的自然法则，并写出来 3.5.2. 第一性原理 3.5.3. 背后的背后、原理的原理 应用一：成瘾机制分析 比如： 这么多年， 成瘾的点 喜欢养鸟、造鸟笼 幻想：幻想人鸟和谐、给鸟一个可爱的家，幻想以后老鸟可以下蛋、养小鸟 视觉激励：看到鸟很开心听觉激励：鸟的叫声很悦耳 迷恋于刷墙、迷恋于修家里的坏了的东西 幻想： 家，更趋于完美 ；妻子看了很高兴。 视觉激励：把破损的墙刷白，修复，看上去很有成就感 痴迷于刷抖音，可以连续刷一天 视觉激励：美女无穷性：新鲜感 可以吃东西，吃到发胀还想吃 味觉激励触发了动物性 痴迷于黄色网站 幻想：视觉激励：美女无穷性：新鲜感触发了动物性 -----》 共同点：不难：难会产生痛苦、会有意志力消耗 完成前的幻想 完成后的奖励 无穷性：给予无穷的新鲜感。这是 永动 的动力 很显然：养鸟做不到、刷墙做不到 ----> 一定会造成后期的厌倦 触发的越底层，越自然，越容易成瘾：动物性（生理性）》 人性 》 社会性 为什么绝大部分人能忍受干苦力活、在烈日下暴晒，却忍受不了学习的苦呢？ -------》 这其实是很自然的： 原因： （1）干苦力：有及时激励（每天的工钱、又有新的墙被刷完，可见性）---> 不会枯燥 （2）学习知识，没有及时的奖励 ----》 这就极度极度的枯燥，像是在沙漠里行走，满眼枯燥 难的东西，一直不理解 -----》 痛苦 角度： 背后---------使用（更好的） 背后的背后—-------使用（这种才是可迁移的、跨项目的，甚至跨语言的使用） 因为：背后的背后，一定是底层的、通用的思想和架构，比如，消息屏障是背后。背后的背后，就是消息屏障原理的设计初衷、设计思想，即消息屏障背后的模型，以及。这种就可以移到 新的项目上（新项目肯定是没有handler了的） 背后的背后，相关问题： 原理为什么要这样设计？有没有不得不 你能想出其他设计嘛？你怎么样才能想出其他原理？可不可以那样设计？ 哪一种设计是最好的？ 了解了背后（原理），可以更好使用工具；了解了背后的背后（原理为什么是这样设计的出来的），可以更好的创造工具 如一级指针可以改变 值 二级指针可以改变一级指针的值一样 TODO： 你问得问题和思想，都是有层次的 学习知识 如何成瘾？ 可迁移的机制： ----> 多研究 嗑瓜子理论（https://wiki.mbalib.com/wiki/%E7%93%9C%E5%AD%90%E7%90%86%E8%AE%BA） 游戏理论 成瘾的根本原因是：有一套反馈机制在里面 ------> 正反馈机制、及时反馈 ​ 反馈机制做了哪些事情：1、修正 2、奖励 -及时的奖励机制 学习很难像游戏一样搭建奖励机制的原因在于： 1、学习带来的反馈是延时的，很难及时，比如背诵一个单词，猴年马月才能用上，才能体现在分数或生活中 2、学习带来的奖励也很难量化 ----> 比如背诵一个单词，只是结果上多背了一个单词。在激励上，多了多少？对英语提升影响多大？？ 3、游戏的激励更为直观：成功闯关，此成就只有20%的玩家获得。鲜花、排行榜、音效 TODO:我搭建的及时激励有: 1、数“技巧”个数（越多，我越离厉害更进一步 ） 2、0层图的个数，简洁程度 3、不得不的 “锚点”个数 4、方法集元素个数 5、本质的个数 6、美感、譬喻、比喻个数 7、兴奋点、关注点：得到了新的思想工具，思想世界又丰富了 ----> 思想世界 与 物质世界：获得思想世界新的东西，让我亢奋，比物质世界里买新东西还亢奋 刷抖音，让我痛苦，我搜集不到好的 思想、思想工具。反而让 思想世界凌乱 8、有多少个 “无招胜有招” -----> 决定你的lever 9、有多少个 “不得不” 10、多少个自然 成为熟悉安卓架构的少有的前百分之20% 幻想： 成为专家之后，年薪百万，然后住豪宅，给家里人都买保险。后半生便无忧了 幻想自己成为专家后的自信。理解深刻后的喜悦 注意： 1、及时激励应该是知识本身，或者知识相关。不应该是： 激励是一个礼物、一块糖 2、专注（过于抽象）只是奖励的副产品 弄懂复杂的物理知识，就像生理上的射精------蔡志忠 --------》 成瘾机制的消除 你喜欢刷墙，有很强烈的意愿去 看到墙刷完后的效果 3.5.4. 描述事物的工具--------SCQA模型 S（Situation）情景 ——由大家都熟悉的情景、事实引入。 C（Complication）冲突 ——实际情况往往和我们的要求有冲突。 Q（Question）疑问 ——怎么办？ A（Answer）回答 SCQA模型是一个“结构化表达”工具。所以，写技术文档，也可以从这些角度进行阐述 3.5.5. 描述事物的工具--------5W2H 5W2H是描述事情的全面性，时间、地点、人物、原因、过程、结果。 案例2：设计一款app的调查问卷，你会如何设计调查问卷上的问题？ what(做什么)：你用这款app做什么事情？ when（何时）：你通常在什么时间使用这款app？ where（何地）：你会在什么场景使用它？ why（为什么）：你为什么选择这款app？ who（是谁）：如果你觉得你喜欢这个产品，你会推荐给谁？ how （怎么做）：你觉得我们需要什么功能才是比较新颖的？ how much（多少钱）：如果你认为这是个对你有帮助的APP，你会花什么价格去购买app里的服务？ 3.5.6. 追问问题的根本原因------5Why 3.5.7. 思想工具之 复利/复制/继承性 快速复制是一个极大的利器（不需要完全从0到1，再困难的来一遍） 例子： 1、人类与动物最大的区别不是 发明和使用工具，而是语言。--------------《时间简史》 原因在于： 语言，让知识和经验，可以在 人与人、人与人类幼崽之间快速 复制、继承 ------> 人类升级可以利用软件升级 动物的升级只能靠既然选择，然后刻在基因里 ------> 动物的升级是硬件升级，周期千万年 2、站在巨人肩膀上 ----- 牛顿 IT为啥可以垄断，形成巨大财富？ 原因： 快速的复制性，一份代码，可以马上在几亿台设备运行 -----> 突破了时间、地点、材料的限制 抖音上主播卖货： 1、原来面向一个客户，复制成面向亿万客户 2、如何写文案？别人十万点赞的文案，拿过来，改一改，便轻轻松松1万 ----> 复制的威力(抄) ​ 看到谁就抄谁！！ 3、 抖音参哥： ​ 做生意，千万不要做一个匠人（深耕一个领域）！！反匠人精神！！----------> 90%的生意都有周期性，比如钢材生意，就几年 ​ 而是要利用复制的威力！！！！ 举例子： 觉得工厂比较有技术、自己做的二十年产品有价值 --------》实际上这些都是脏活、累活、不出成绩的活。。。关键每有垄断性，可以找到任意的工厂买 ​ 有这个精力，可以多开几家淘宝店 复制要做到： 1、低成本 2、快速 规定： 重要的事情，难的事情，一定要做到可复制/可继承 list： docker环境、aosp代码注释 3.5.8. 思想之化简 为什么要化简 人不可能理解复杂东西 人不可能记忆复杂东西 人不可能执行复杂的东西（多次）： 多次执行一个复杂东西，耗时耗力------》 人的意志力多宝贵 人不可能关注复杂的东西： 重要的事情只有一个，所以不可能分心 ------------>化简是我们终生的课题，甚至是时刻的课题 从目的论的角度： 化简，让目的更加清晰 如何化简？ 化简的具体目标是什么？化简的具体工具是什么？ 化简具体工具： 1、提取重复 比如重构函数，提取重复； 比如 把常见的要做的脚本(电脑启动时，启动多个软件)，多个封装到一个脚本中 my_start 比如：把一个成功的商业模式疯狂复制 2、上面的复制思想 比如：你会了一件事情之后，就可以不做了。教会别人，让别人做 3、 代码化简-----见how...... --------》 是不是可以应用到生活？ 一些好的化简的例子 例子1： 代码化简-----见how...... 例子2：软件结构、行文结构，如下 key1 -------> key2 -------> key3 -------> key4......... | | 具体。。 关注点在key上。。。。。。然后对每个key展开 key常常是目的 生活、记忆化简之 合并同类项 比如： 记忆adb命令： 刚开始记忆很多很多adb命令 ----> 记忆有哪些key(录屏、滑动) -----> 类似的操作放一起后，只需要记忆 屏幕相关、手势相关、app相关（最终只需要记忆三个名词） 3.5.9. 化简推论：重要的只有一个 重要的事情只有一件、重要的代码只有一行、重要的笔记只有有一句话 -----> 理解程度的衡量标准 3.5.10. 这世间最不可靠的就是意志力 比如：励志、发誓、承诺、高三打鸡血熬夜学习、纵欲、身处 为什么？因为都基于意志力，人的意志力是非常稀缺的，一消耗就没了 所以： 1、一切靠意志力的东西，都是非常不可靠的：绝不相信 相对可靠的有： 固定的流程、规章制度、法律----------》 好的约束 好的周围环境 自身：提高精神力（身体、脑力） 3.5.11. 分析人的三模型 信息模型、认知模型、执行模型 （输入） （function） （输出） 任何一个复杂系统也这样分析 TODO: 人生模型之 执行模型 -----> 一定要 目标感很强 。技巧： ​ TODOList： 月度-周-日 执行模型 关于动力、关于阻力 3.6. 技巧 取其神，忘其形 ----》 真传一句话，假传万卷书 如何识别形，又如何提取神？ 技巧，比热情重要，热情会消散。而技巧不会 3.7. 生活化模型----理解、记忆的利器 生活化模型的本质：将新知识类比桥接到旧的已经获得的知识体系上。。。以已知链接未知。。。。 生活化模型，是学习新知识、记忆新知识点极大的利器 任何一个知识点（尤其代码调用流程），给出生活中的类比、或者形象化 比如：费曼的恐龙多高多大，三层楼高但是头进不来 不用担心 比如 ：输入法imm、imms、ims 媒婆相亲 比如：looper线程，驴拉磨 比如：APP启动，皇子继承皇位模型 为什么能这样做？ 太阳底下没有新鲜事 为什么要这样做？ 1、得到不得不，得到自然2、也是可复制思想的要求。讲旧知识复制到新知识上，这样减少消耗 3、也是合理性思想的要求。如果找不到生活化模型，必然不合理 记忆，在于形象化、生活化、具体化 尤其代码调用流程，其实是模块调用流程更合适，（我记不住步数太多的流程。。。子系统内部不适用？），流程生活化，极大提高记忆力 大的流程，编生活模型故事，理解本质。。。。。。之后小流程、内部流程、细节由 大的流程 撑起来 （不得不） 注意： -基于模型，去记忆代码。 而不是根据代码记模型 · 3.8. 人生架构 身体 > 脑子 > 关系：身体会影响脑子 坐久了，会影响思维 思考久了，容易睡不着 ----> 利用身体运动反作用 3.9. 学习如何学习 https://www.campzhe.com/archives/1372 3.9.1. 学习动力与阻力 好奇心是根本动力 ----> 多问。培养好奇心 做学问：好奇心重要，品味也很重要 动力的好坏： 美感 > 好奇心 > 兴奋点 > 竞争、攀比 激发了我探索这个世界的兴趣 ---> 来理解大自然的工作机理 激发了我探索系统的兴趣 ---> 来理解系统的工作机理 ------> 为机理而活 我对科学有兴趣只是因为我想了解这个世界， 我发现越多， 探索世界这件事情就越美妙 我迷恋于 应用的级别，为啥呢？我觉得会使用某一项技术后，会方便很多 ----> 便利很多，超越很多人 --------> 我关注的点（兴奋的点）的层级， 决定我的层次 --------> 如何改变兴奋点呢？ 兴奋点： 在主要任务、主要分支做出主要贡献 不急、不重要、不是必须+费时间，就靠后 动力： 成瘾-----奖励机制 见上： 学习知识 如何成瘾？ 阻力：缓解痛苦 难题、知识过于复杂、游戏闯不过去、环境搭建总是失败、苦思冥想 ，都是佛家 求不得的痛苦 ------> 这些必然会产生痛苦，可是我们又没办法规避，必须做出来。 那么，如何缓解这种痛苦呢？方法： 1、想办法，降低问题的难度 --- > 做一个低难度的、阶段性问题，适应了再逐渐升高难度： -比如：学习安卓的显示系统，自己看代码难度为90，看技术文章为60，挺别人讲视频20 ​ 正确做法： 先看视频---》视频了解后，看技术文章加深---》最后跟着代码走一遍 2、梳头 3、对于非常困难的，需要常年累月的问题，可以做一些，不通的话，先休息几天，再尝试 比如之前搭建Docker搭建代理环境，我前前后后，弄了一年多，终于弄好。还有linux可视化界面 4、多看看大家的视频，尤其张益唐的淡泊 3.9.2. 学习之无招胜有招 真正意义上的复杂系统，必须来自于简单的规则，以及在时间这个变量的参与下，衍生出的无穷可能性。 ---------> 风清扬给令狐冲 风清扬对令狐冲的武功教诲和岳不群对令狐冲的武功教诲是截然不同的，风清扬对令狐冲人生的教诲更为精妙，更合令狐冲的脾气。这一回的传剑是实实在在，风清扬的一剑中竟有三百六十种变化，这种武功是不是真是至高无上的呢？但风清扬传剑术与令狐冲，虽说是剑术却有另一种高人境界，放飞自我，做学问方法。“剑术之道，讲究如行云流水，任意所至”，学问之道，生活之理，其实亦是如此 无招胜有招，说的并不是没有任何招式，白纸一张。而是： 1、掌握最核心的精髓（极度简化，近似无招） 2、基于精髓，任意演变 （行云流水，任意所至），从而可以忽略演变，无需记忆： -通过链接一切，做到极致化简。例子：三百六十种变化，风清扬知道如何由 三百六十种变化 链接到 一剑 ，所以在风的眼里，只有一剑，忘却了三百六十种变化 无招胜有招，说的就是极致化简（超级减法） 具体如何化简，见《化简》 检验是否学会的标准（也是学习的方法）： 见下 当你觉得一个东西复杂的时候，一定是 1、你理解没深刻 2、你看问题的角度有问题 复杂的东西，其内核一定是简单的、明了的 复杂的东西，不仅内核简单明了，本身也一定是简单、明了的（这世上不可能存在复杂的东西） 人是不可能，理解与记忆复杂的东西。 真传一句话。 这也是 检验自己是否 真得的标准。 柯浩然-------------------一法通，万法通 3.9.3. 无招胜有招之目的论 目的论就会让我们忘记，不需要记忆 有了目的，就不会无聊。听课也会有主动性，看书看代码也是 关于目标： 不应该是1个小时内，进度多少 --------》 而是，一个小时内，获得多少智慧？见过路途中多少风景？ 3.9.4. 无招胜有招之链接实操 理想的学习知识路径： 1、左图：我们不可能认识一棵树: 一棵树有太多的细节（叶子），仅仅外表都让我们眩晕（还有叶子光合、树枝养分吸收等等）：比如 安卓的操作系统，各种操作、各种功能 2、中图：将 一棵树 的主干、主要枝丫、果实 提取出来，忽略细节 （抓住主干的能力）：比如 : 安卓系统，显示与触摸就是两个大的主干 3、右图：对主干、主要枝丫 留一两个关键点（极度化简的能力：不得不的点、唯一决定的点）。比如：安卓系统的显示的根本是surface上的数据 4、基于右图链接： 树根------树节点1----树节点2----果实 一定要形成关键节点的强链接 5、如何认识系统？基于最简的关键节点 （右图），反推 左图 ： 如果不基于右图，我们永远无法理解左图，反而越理解越糊涂！ 6、一定牢牢地把握树根，把整个世界链进去！ ----------------> 知识的应用便是从 树根 链到 节点1，节点1链到节点2，最后链到果实的 过程 常见的一些例子： 写文章也应该如此--------文章目录就是 关键节点----key 看文章也是如此--------只需要看目录结构就行 规定：看文章时，必须旁边有目录章节，随时看所处的位置： 定位bug，也应该如此---------看关键status 我们记不住这个世界，只能记住这个世界的所有key，链接所有key 打开最外层的.md, 则可以链接其他所有的.md文件： 3.9.5. 如何化简？ 原则：【1】 核心尽量是绝对的锚、【2】 逻辑链彻底的短、【3】 逻辑链要强固 关键在于【2】，因为人不可能记忆长的东西 应用一：代码的化简 比如： 起点----目标反推法 见 TODO: 延拓应用领域 ​ 写文章 ​ 思考代码 3.9.6. 学习之底层逻辑 3.9.7. 学习之 以问题、面试问题驱动 目的论 3.9.8. 学习知识之各个维度------拆解|切割 学生时期课堂里，老师讲课的方式是从下往上，一步一步搭建完整个楼（知识）给你看 -----------》社会上的海量知识，差异： 1、海量知识，难以一步一步； ---------》 对应方法：拆解、看大的纵向 2、由于知识是已经完成的事物。自己去看，必然是 从上往下；我们很难理解（甚至看不到）从下往上（房子最开始有没有搭地基、房子内部结构是怎么设计的） -------------> 如何更好地逆向？如何从上到下的角度更好地理解？ ​ 对应方法：目的论（基于目的，一步步论述 每一个“下”的合理性） 目的----出发点 寻找问题------回答问题 （这其实也是目的论） 字面上--------结构上----------本质上 纵向（大的）-------横向 如何深刻？ ：上面的技巧，无论如何，没法做到深刻。。。。。要深刻，必须有深刻的问题嘛？ 3.9.9. 学习效果拆解 &checkList 参考： https://www.zhihu.com/question/324702775/answer/1007956506?utm_campaign=shareopn&utm_medium=social&utm_oi=903075405244817408&utm_psn=1586476031338307584&utm_source=wechat_session 学习效果=有效学习时间*学习状态*学习方法 -------> 逐渐从这三方面拆解 手机远离5m以上 方法： A4纸检查法 3.9.10. 学习材料 有言者： 老师（学校老师、年长者、培训视频） 书本（技术博客、互联网） 无言者： 学习一切差异化的思想 ： （1）别人与你不一样的地方 （2）识别好的 ----> (3)拿过来学习 -----> （4）拓展应用 比如：aosp编译前，source envoromrnt.sh ------> 就是一个很好的思想（把root下所有环境都初始化好，比如make 在任意目录下执行都一样！） TODO:应用 3.10. 分析、理解、记忆的工具----目的论 **目的论：目标---出发----不得不：** 锚：出发点（触发点）------------目标 由此 过程就是不得不的了：~因为目标是，所以，第一步；因为目标是，所以，第二步 基于锚，我们体会到了 每一步的 不得不，对事物的理解就到家了， 自然， 分析比较透彻了（因为证明了不得不） 理解的深刻了 过程不得不，只需记忆锚就好（自然是记忆的好工具） 推论： 1、合理性分析：也是这个方法的应用，即 针对于目标，该步骤的合理性在哪里？ 2、生活也要如此，当我们处在 漫长的过程中，一定想一想，当下的操作，对于出发点 和 目标是必要的嘛？？ ------> 我们经常会忘记目标，而且目标不停摆动 3、不得不 与 费曼技巧（创造知识）说的是一个东西。 区别在于： 不得不 似乎对已有的事物没有完全瓦解，只是对已有事物证明其合理性---------》 应用在对已有知识 不太熟悉的情况下？ ​ 创造知识 要求完全瓦解 -----------》 对熟知的事物，从0开始，似乎更彻底 从更高层次上看， 证明 不得不 是化简的极大利器，是理解的极大利器，更是记忆的极大利器 ​ 目的论分析 是 合理性(自然) 的有利工具（有了自然，就不需要记忆了） TODO: 从不得不角度， 代码 跟数学好像---------- 把一道题（不一定是证明题）的解答步骤，做到不得不，就完全理解了 生活也是如此------------炒菜有很多步骤，但最合理的只有一个（比如，买菜的时机是你想出去溜达的时候，吵豇豆前要先煮一下才软，这些都是合理性上的不得不），把步骤想到不得不的时候，你就完全理解炒菜了，也不需要记忆了 所以，不得不 是 理解 多个步骤、流程性 东西的 利器？？？？？？ ​ TODO: 背后的背后： -思考角度|关注的点，如此的重要 --------》 可以将三件完全不相关的领域 一剑串起（某一角度） --------》 一个角度，决定着 某一领域的 修为。。。。这也是真传一句话的原因 TODO: 把 不得不 用在 任何事、任何时 上？？？？？？似乎只能是流程性的 3.10.1. 写技术文章（流程性）的结构一 也按照上述思路 规定： 行文格式 大的锚（目标-------触发点） 阶段性1的锚（目标1------触发点1） ​ 非常小的目的-----小的触发点-----小的不得不 ​ 阶段性2的锚（目标2-------触发点2） 例子：比如目的是打开SSH开关 ------》这是你的关注点，也是写文章的锚点 具体怎么打开，不要关心 规定： 在过程中，一直问自己： 目标是啥？ （触发点是啥？） 3.11. 写技术文章的结构二 0层，必须有锚点 其他目录是流程目录：大目录之间是流程，小目录间也是 -----> 目录相当于函数调用（关键的） 必须有总结 引用只能引用总结 0层图有0层图大总结 各个小流程里，有小节的总结 3.12. 如何在一个领域做到顶尖？ 梦想 成魔成疯 3.13. 心理 任何行为都是心理、激素作用？？ 每天暗示自己：（1）你是个天才 （2）这个原理让我高潮 （3）人际关系的拿捏、权利让我高潮 3.13.1. 立志 此生，为道而生，为自然法则而生 我要用 道 来驾驭万物！ 智慧、思维于我是一种天赐的礼物 3.13.2. 心流 你如何在修理电器、养花种草上获得心流，你便可以培养同样的心流在其他事情上 3.13.3. 空杯心态 3.13.4. 焦虑 zhangyitang 3.13.5. 假装 你想成为什么样的人，先从假装开始（先从暗示开始） 3.13.6. 比较 从根本上来看，人是不可能与他人比较的 -------> 原因在于：与他人的比较都是浅层次的比较：年薪、职级、成绩、房子、、、、、、 -------> 浅层次的比较 危害极大，1、让人只盯着表象，于发展无意义 2、让人陷入焦虑 只有与自己比较，才能触及根本。从而，才能进步。与自己比较的内容：自己的内核有没有提升 3.13.7. 表达是门技术 ---> 需要去研究 3.13.8. 关于选择 规定：任何大的选择，基于未来3~5年去做。 站在未来看现在，才能做好选择。 -技巧： 当前犹豫的事情，时间尺度拉到未来十年，就好选择了 EX : 转岗去做通信的东西，就是一个彻底傻逼的行为，原因：违背了历史进程，违背了行业发展 3.14. 其他小点 如何鉴定一个view是特定某个？1、在断点调试中，会标明子类名 2、log中大小 3、眼睛观察时，可以改变大小（最好颜色） --------> 区别化 面向对象，什么时候new，比什么时候调用方法要重要！！！前者是基础 充分涌流，英文对编程很重要，可以在网上链接全世界的开发者和网站！！！！！ 好的断点调试环境下，可以调试z侧的Zeus 我是个笨人。。。笨人理解事物的方式就是， 1、慢化: 不停地细化、分解问题，然后一条条回答，确定 一定要梳理，q&a，否则跟没做过一样，比如输入法 画完图没有用，太泛 2、记录，与回顾 3，任何事情都要有 更抽象。。。。。这才是你的。你忘不掉的 任何时候，非主线程需要标识！！！！！ 按照功能去分层，分类！分代码 如何界定真懂和假懂 做项目工程或者阅读代码时，一定要有文档输出。1，理思路 2 记忆 3 回顾 我跟周围领域边界是什么。。。。跟周边啥关系 绑定，addwin，bind 记忆之锚 万物皆对象与关系（对象的高级就是架构） 测试用例方法:一步一步走。。。。不要跳跃！！！ 刷完版本，点hipay 更新代码，导入so，点hipay 不要走捷径，走捷径会让你死的很惨 测试用例不过， 1，绑定关系原则:测试套里其他的过没过？ 2，相互影响关系原则:为了排除测试用例之间的影响， 不要被自己骗了。。。。问一句，不这么样，又会怎样？如果没有，你会怎么做？ 理清，透彻！！！！如何达到呢？ 如何不囿于代码？？ 贫穷不是因为懒惰‘ 农民工：勤劳、能吃苦、善良 3.14.1. 每前进一步，把之前所有方法再轮一遍 ------->方法便成指数级增长 例子： 1、进步:云帆引入方法，可以将其他盘代码引入As工程源码作为source 基于进步的拓展:那么可以做的事情就非常多了，比如将Z侧代码引入source断点调试，依赖源码 再拓展: 打通ndk调试（A侧和Z侧），以同样方法引入cpp 再再拓展: 2、云构建ok了，其实可以做很多事情。。。。 比如，串所有代码？ 再比如， 3.14.2. 每天给你自己暗示， 你是计算机天才，高手 3.14.3. 永远不要用毅力、努力， ------>因为它有对应的副作用同样强！！！！ 太用力跑不远！！！！ 股市上也是，太要快，反而跌的惨 3.14.4. 对比，一定要强烈、一定要客观 例子： 1、如果练好说话：把自己说的话录音（客观）下来，与别人同样的话录音下来，同时放映对比（强烈） 2、看自己胖不胖：用手机后置摄像头（客观）拍照片，对比以前照片 再例子：看书，划重点，用颜色笔划重点 3.14.5. 坚持输出，以输出倒逼理解！ --->(关键是，倒逼思考) 任何学习都是如此 读书也是如此: 输入（看书）+头脑内整合（思考）——>输出（写作）=收获 理解事物也是如此 3.14.6. 跟对人、读好的书、好的csdn ----> 学会挑选，避免糟粕！！ 如何挑选？看评价，长期的！ 大量的信息涌进来，鱼龙混杂----> 大部分观点是错的！！ ----------------> 所以，要跟对人！！！！跟对时间上检验过的人！！！ ----------------> 即使你自己没有独立思考能力，跟对了人，也就。。。 3.14.7. 如何深刻？学习、知识、理解 1、要反向才能深刻----> 时刻提问题，时刻怀疑！！！！！！ 所以，我们可以推导出任意事物的学习方法： 任何学习一定是伴着很多问题的：1、自己给自己提问题 2、网上搜面试问题（别人给你提的问题） 2、实践 + 实践后的总结 才能深刻 要学一个东西，一定要尽量实践，比如做题、比如动手实验、比如动手写代码、写项目 --------->纸上得来终觉浅（听人说也是如此） 3、抛开不谈技巧： 做.........时，抛开.........不谈，必然要解决的问题是？ 做安卓显示时，抛开安卓不谈，显示这一功能必须要解决的问题是啥？ 1、不能让开发者自己一笔笔画吧，自然是 有一个基础元素的概念，让开发者自己去组装 -----> 即控件概念 2、必然有人把 基础元素的数据 转化成 显示数据 ------>即render系统（这里可以看出，渲染是必然的，但是不一定要并发） 3、如果有多个窗口呢，怎么办？ -----> wms 总之，如何深刻？规定： 1、抛开不谈 2、不允许用 wms、window manager sevice 来作为标题 -----> 用功能文字 作为标题（并证明不得不） 而应该是显示系统、如何转换数据？ 如何协调各个窗口之间？ 见 Graphic.md 3.14.8. 积木思想： 积木思想（先拆再串），应对繁多的方法： 拆成独立的木块（这个种类不多）。弄透了独立木块（工具），然后再整合（串） 学习也是，要用积木思想，先拆再整合 3.14.9. 问题 问题是技术存在的唯一理由 一个人有多牛在于他能解多难的问题 问题是检验技术的唯一标准 只有好的问题才能让人深刻！！！！ 3.14.10. 执行力 对于有拖延症和慢性格的你来说，执行要比理解全，要重要。。。大于一切！！！！！ 3.14.11. 绩效问题： 绩效b，你的问题在于不会展示自我！！！不够自信！！！主管不相信你 https://zhuanlan.zhihu.com/p/30489002?utm_source=wechat_session&utm_medium=social&utm_oi=903075405244817408&utm_campaign=shareopn 云帆: 当时给浩哥留下了好印象（弄好了编译，让代码跑起来）-----> 后面好活都让他做了！！！！为什么我没有做到？？我当时只想着查接口资料。。。我似乎也不知道系统代码可以替换的！！！！！！ 冬郎: 会表现，尤其领导面前-------->知识管理！！！！而我认为这些没有用！！！！ 朱明亮：你能够独当一面嘛？？？技术上呢嘛，气势上呢嘛？ 海涛：如何绩效好？两种：1、你在重要的角色上，这个项目没了你，其他人很难完成这个角色（至少做起来比较困难） 2、简单的事情上，做出亮点。做的漂亮。 你的绩效总是垫底，不感到委屈吗？ 年中绩效评价时，其中一个团队成员问我，为什么自己的工作量并不比别人差，但是绩效排名却不理想。 好吧，这个问题对于很多管理者来说着实是一件头疼的事情。但作为团队leader，总有一天要面对这类问题。我也只能根据我的理解去给他一些建议： 为什么一起入职的小伙伴，短短的一段时间后就在绩效考核上拉开了差距呢？ 我们建立一个较为理想的模型：我们将团队的工作任务看作一块三明治，分为困难、普通以及简单任务，在对团队成员并不存在主观偏见的情况下，leader会倾向于按照“平均”的原则去分配工作。 一般情况下，所得到的最终结果会是：有人完成的很理想，有些人完成的很差。但是，从团队绩效的整体完成情况来看，并不理想。 可以预见的是，如果继续按照上述方式分配工作，团队绩效依然无法有较大的改观，此时，作为leader不得不作出一些调整——按照能力去匹配工作。 带来的效果一般也是显而易见的，团队整体的绩效得到了保证。 现在回到最初的问题，我们心里是否有答案了呢： 丙的工作量并不比其它人少，为什么绩效排名靠后？ 我想答案可以简单概括为，丙的可替代性较高。 进一步去思考，可以将以上过程称为绩效阶层分化。通俗的说，我们以往的工作效果导致了我们被划分为了甲类、乙类以及丙类员工（为了便于理解，暂且这样称呼）中的一种，而leader出于对团队绩效负责的原则，采取了最低风险的工作分配方式，更加剧了绩效阶层的固化。 丙类员工的悲哀在于，他就像站在拥挤的地铁车厢门口的人，稍不注意便会被挤下车。然而，我们被划分至丙类员工并不是最糟糕的事情，最糟糕的是我们从未去思考自己是如何一步步走向丙类的。 经了过对绩效阶层分化的理解，看上去作为丙类员工的我们似乎已经无路可走了。事实真的是这样吗？回顾上面的思考过程，我们会发现导致我们一步步走向丙类的直接原因，便是对于复杂、重要工作任务完成的效果差。而根本原因，在于能力缺失，或态度消极。在职场上的一条永远成立的定律：先有做事情的能力，才会有做事情的机会。 因此，扭转局面的唯一机会便是：踏踏实实地提升自身的能力，去主动承担并且完成复杂、重要的工作。绩效与薪资挂钩往往使大家捡了芝麻丢了西瓜，仅仅纠结于眼前的利益，而忘记了改进自身能力去追求自身更高价值的机会。不善于反思自己，将绩效评价结果简单地归结于偏见，甚至更加消极怠工，是对自身最大的不负责。 最后，我所理解的绩效考核的最终目的是帮助员工去发现、理解及改进自身问题，因此完整的绩效评价应该包括结果评价、绩效面谈辅导两个主要部分。也就是说，这是一个工作效果集中复盘，帮助团队成员发现成长机会，并且与他一起制定提升措施的过程，按PDCA模式去挖掘自身潜力。 许多管理者甚至将绩效考核权利当成自己树立威信的杀手锏，如果你偏要拿出一副“老子说谁行谁就行”的嘴脸，那我也只能祝你以及你的团队好运了。。。。。 3.14.12. TODO： 了解impl与接口关系，为什么要这样设计 泡脚 静态方法如果修改一个量，基本上都要加锁 ——》因为不同线程会同时修改这个值 你在华为，做的最大的错事就是，你太怂了！！！！！！导致了后面一系列问题，绩效，分的蛋糕 任何一个新名词，任何一个新逻辑，任何一件事情，都问一句:本质是啥（what)？最底层逻辑是啥（how)？（害怕被名词欺骗，害怕被自己骗） 不停地what，when，how，why————》不停进行交替，这样你可以追到本质 比如，序列化，本质是啥 工作逻辑 原理逻辑 做的笔记，必须是自己的深刻理解（1，自己的 2，深刻浓缩） 一个模块的开发，一定由上至下来设计接口。由上至下来写接口。。。。。为什么是这样的？因为一个接口的功能是由它的调用者决定的！！！使用者 父类调想要调到子类方法: 可以直接在子类里增加，instance判断 2 父类增加这个方法，子类复写（不用父类里用instanceof 判断） 只是子类的方法，不要在父类里 》各有什么优劣？ 第二种更好，原因在于:第一种在父类里了解了当前类是子类，即父类了解了子类逻辑，并调用子类逻辑。。。。=》子类逻辑下沉到父类里了。。。这不好，产生了耦合，以后。。。。。这样做，父类里会有大量instanceof 尤其是父类里面引用了子类=》这本身就是耦合，本身引用方向就很不对！！！ 原则，父类不需要对子类是哪一种进行感知。。。做自己的逻辑，这样不会耦合？ 即使只有一个子类去override，还是第二种好 例子: 如何hook安卓流程 1，实现安卓所要的接口抽象，塞给安卓。。安卓回调时，回调到z 比如，无障碍流程 2，继承安卓的类，恶意复写 比如元能力恶意复写activity的内容 静态如何调用非静态？ 静态不能在方法中调用，但是，可以把非静态变量赋值给静态变量 而且方法可以当做callback（变量)，所以，非静态可以转化静态 -----> 例如安卓Toast, Notication 其实有些架构是必然的，比如，通知，要考虑不同应用，则必然manager在另一个进程里 为什么？为什么？为什么？ 回调，回调到子类还是父类？（其实都是一个实例，层次不一样）其实都可以，哪种更合理？ 读书最重要的是读目录，尤其是技术书！！！！比如安卓艺术探索艺术 断点调试适合向下 每天要有计划。。。规定，所有的计划要细化。。。。所有的学习或新东西，要输出东西 集中精力 一定要学会化简！！！！！比如，看代码要学会化简。。。把握住核心的几行代码。然后去理解与记忆。。。其他代码能删则删。。。这想要那也想要，最后一定是不深刻！！！！！！ 你是一只狼 大计划，接下来追求: 1，每天锻炼身体——》细化 2，锻炼脑袋——》对知识和金钱保持 强烈欲望！！！好奇好奇，可以走得更远 3，审视每个想法。念起即断 4，反思。复盘一切 5，每天身体和思想都清零， 以输出倒逼理解。。。又一例子，做笔记，做的笔记是你的理解。而不是你抄黑板 又一例子，写toast代码给开发者，先设计好开发者怎么用，以此输出为出发点 对外接口是一个类（模块)存在的意义以及其本质！！！！！！！ 要想把握一个模块，一定牢牢把握其对外接口。比如，了解一个接口怎么使用，入口在demo里。再比如，了解一个类是干啥的，看其有哪些对外接口。。。 如何让她意识到自己的错误。走她的路，让她明白。。。生日时，她没给祝福，生气。没给礼物时，生气！ 如何克服焦虑和拖延: 努力干砸每一件事情！干就完了！ 从本质上讲，调用函数就是信息传递！！！就是蝌蚪，电流 =》传递了两个信息: 1 、某个事 2、干这个事的一些东西》其中1，可以转化为2 3.14.13. 对个人成长无益 价值，价值 3.14.14. to整理 人世间有太多的羁绊，阻碍你的前进：性欲、面子、强迫症、手机、感情、亲情、执念、 要思考怎么进步，这才是根本 万物皆是对象 既然是对象，必然有层！！！！ 》所有事情，分层！！！！0层设计！！！ 问题集: 问题比对的东西重要！！！！ 问题《》根因 熬夜➕久坐，伤神 熬夜会变笨 餐巾纸 放慢大招： luyin、log 》录音别人的问题，问题是理解本质的神器 可叠加式进步 朝闻道夕死可矣 遇到难的问题，一时解决不了，不要强攻。。。。隔一段时间再解决（第一，不耗精力，第二，换脑子） 用输出检验输入，检验理解 注意每天给自己清零 机器要一直跑，人要常休息、常思考。 沉下去 要活的有智慧 长度 书籍:稀缺，穷爸爸富爸爸 抓crash log是虚拟机在死亡之前发出来的。所以跟安卓或者z没有关系。 方向性问题，一定不要听你同级别同年龄的人，的话，（比如yangyunfan说andriod比算法有前途） 近期emui会有需求。 如何理解，分析，思考，解决问题，问题拆解，原子性 Android studio 6.3.2，比如EA保存高质量图片 对比网上很难搜到的东西一定要有记录，比如docker的安装。studio的配置！！！ -2深度参与了嘛 -1 提高自己的沟通能力！！！！ 0，每日问一下，你的技术达到最好了嘛？今天是否追到根？能力提升了嘛？ =》你总结了很多，入脑内化了嘛？ 每天看一遍 图的话，闭眼想关键点 时间，力量 所有的复杂配置要记录关键流程，以免后续返工时，又浪费时间 给一个不得不的理由 1、技术思维，向上下扎到根，向上捅破天，，， 竞品思维 产业思维：安卓如何做的，苹果如何做的，你可以怎么做 和一个有心机的人竞争，两种方式，可以赢他，一种是比他更有心机，这种能赢，但只是险胜。第二种是更纯粹，但在思维，思想上，高纬度碾压 陈浩，怎么样才能挣到他一样的年薪？找那个段位的人聊天。。。。他说的是对自己人生知识智慧的提炼(不会出现在书本，不会出现在互联网上) 看虎嗅，看36氪 越底层越重要，身体，家人，赚钱能力 不能短视！！！！ 多找跃华聊天，他就是你的陈浩！！！ 每件事情都是有一定意义的，要识别其意义，并总结下来 理解一样东西，不快，但是弄懂了就彻底懂了 方案，一遍不懂就十遍，任何难的东西，解决方法=》每天看一遍 厉害的人，是其抽象能力厉害！！！手机跟无线射频没什么两样，就是多了个显示屏 可以无时无刻把玩业务，这样你的时间就多了。比如，做输入法，在自己的手机里很多安装输入法，有空时对比把玩 比起商用完善的项目，github上的demo更有价值 ---------》原因在于：1、GitHub给了源码 2、初期代码都是核心代码 开源项目代码中Java太多，如何看呢？跑起来，通过log找主类？和流水线 串线、串流程、走读代码最好的方法是，打调用栈------》非常快，且准确！！！ 难点在于跑起来， 哪些串线：流程串线以及关键量的流转串线 代码走读就是串线，包括Z，包括任何代码！！无论是应用代码，框架代码，A代码还是z代码！！！！关键在于如何跑起来？ 如何跑起来：1，代码要能编译=》开源软件apk；框架代码匹配手机 2 构造触发点：流程向上游找触发点！！！！（1）点击apk触发，以用户角度触发 （2）主动去调。。。上游的任意一个函数=》这里的可操作性非常大！！！！！！上游函数很多，有些易调到，比如Imm可以直接被apk获得，从而可以调control框架代码里的接口！！！！！=》实现了button调用框架代码！！！！ 规定，跳转画完的流程图，之后也一定加调用栈验证一下，很快！ 规定，画完图，用一两句总结一下，这个图的流程，创建了谁，又怎么流转的 一个量的流转图，要回答从哪里来，怎么流转的，最终去了哪里，做了什么 时序图，中重要的量，也要回答上述问题 一个方法，尤其重要的方法，你必须回答，是不是触发点，这个方法做了什么（很可能是做了一些事情，作为另一个流程的触发点） 那到底他是做了他这一级的事情，还是向下递归的事都是他做的呢 一个方法做了什么，还是一个类做了什么！！！！！！ 三方应用app出问题》先看我们测试demo有没有覆盖这个场景 ----------》这也是demo APP存在的意义！！！！！ 看代码，要回答：从哪里来？属于哪个进程？？？（即属于哪一侧？） 》总之一句话，一定要有好的问题？？？？=》好的问题哪里来 你总结了很多方法，有没有在任何一件事情上，考虑能否应用？将方法应用范围延拓！！！ 无论是知识，还是专利创新，一定要吸收别人的！ 杨云帆有个习惯，走在路上，游泳的时候在想事情。很有效果，换脑子，换心情 输入法架构的必要性在哪里: 时序图体现了具体怎么做，但是不能回答为什么这样做 从类图里可以回答为什么这样做 从组建图里可以更可以回答为什么这么做，这么做的必要性！！！！ 有迹可循的创新: 迁移与联想能力 任何细节的补充只能依附于主干，加强主干，不能扰乱主干。。。记忆，知识点，都要联系主干 不断加强主干！！！！附属的自然强 一级一级地抽象出主干！！！！！ 主干与分支关系：站在主干理解分支，站在主干记忆分支 =》具体应用： 理解时序图，要站在类图上（高维度） 理解时序图，要站在组件图上 理解动态，一定要站在静态的基础上 理解与记忆，一定是主干与分支，抽象与具体，相结合的产物 把琐碎、细节挂到主干，核心上 》推论：画图也是如此，不要一张图画很多东西。一张时序图，画一个东西，然后挂载到主干图 高手在于，拆分、链接、主干ji 》站在全貌上看，做局部 =》对于Z，安卓永远是主干！！！！ 1.学着用肉体操纵精神： =》治愈拖延，自律就很容易 我们无法自律、无法坚持的本质原因：消耗意志力资源，但其极其有限。用精神控制肉体，终究会失败的。 例子，如何坚持读书？不要管你想不想读，先把书拿出来，看一会儿，逐渐会发现你看进去了 你把你的身体,放到一个场景中,你的精神怎么办呢?嘿嘿,它会自然而然地接受这个场景,并且顺势地\"继续下去\",甚至还会将做这件事的“痛苦\"化为“快乐”。 所以啊,为什么要学会\"用肉体控制推动精神\",而不是相反?还因为你的精神会在你还没行动前,就给你设置了一大堆障碍、想象出一百万种失败场景把你吓尿。 2训练感官的能力; 3.让自己突然变开心的能力; 这三种能力同时满足:很重要,但是大e 没有的要求,并且还是很多听起来不错的\"能 力\",比如自律、抗拖延、调节情绪.. 力的基础。借个时髦的词儿,叫\"元能力\"比。 每天百分之十五的时间学习总结 每天百分之十五的时间思考提升的方法，建立长久 很多事情，如何从长的尺度去看？？？？？ 有些人不哄女生，而是和女生讲道理 原因在于，考虑长期的相处方式，而不是像渣男一样，一时的哄骗 太用力的人跑不远。 努力不应该是某种需要被时常觉知的东西,意 志力是短期内会用完的精神能量。 真正坚持到最后的人靠的不是激情,而是恰到 好处的喜欢和投入。 当坚持不再成为需要被言说的事实或是需要被 排练的步骤时,它就成为了我生活的一部 分,而不是什么挂在生活之上的负担。 最长久的陪伴不费心力。如果你真的喜欢 人,真的想在他身边一辈子,就不会说有多么 爱他,而是觉得\"每天能和他在一起,就很 好。 太用力的爱不仅让自己累,也让身边的人累。 https://www.zhihu.com/question/304174916/answer/825079036 把所有问题都放在纸上思考 系统性、流程化 人和动物的差别在于工具 人与人的差别也在于工具》要善于用工具、善于用人！！！！ 绝不看抖音与朋友圈 每天留半个小时抄写经书。半个小时深度思考 高手是深度思考的高手；是自我管理的高手 思考本质的东西 每天早起 每天喝温水 每天晚上列计划，第二天执行 总论：任何事物总是守衡，均衡的。你要想达到一定目标，就要主动构建差异化 例子1: 睡眠只是其中之一 例子2: 绝大部份时间，要时刻利用大脑深度思考一些东西；也要学会利用十分钟，让大脑完全放空 例子3、坐大部分时间，也要学会站 例子4、大部分时间睁眼看东西，有时候闭上眼睛，看的更清楚 例子5、 做一个极简主义者、本质主义者！！！！！！！！！！！！ 把精力放在本质上 我一直强调主干（本质），却没能做到！！！！！！！！！ 比如工作中，只做主干的核心活，放弃噪音 比如，问题没能一眼看穿本质 如何剔除噪音、寻找主干？？？ 1、识别入口和出口（即起与终） 2、 你把你的身体,放到一个场景中,你的精神怎 么办呢?嘿嘿,它会自然而然地接受这个场 景,并且顺势地\"继续下去\",甚至还会将做这 件事的“痛苦\"化为“快乐”。 所以啊,为什么要学会\"用肉体控制推动精 神\",而不是相反?还因为你的精神会在你还没 行动前,就给你设置了一大堆障碍、想象出一 百万种失败场景把你吓尿。 元能力二:训练感官的能力 问你几奇fti题。 你有没有刻意训练过自己耳朵,让它能ぜ ashi: adibility级 组件级 dialog 里view不属于 contentView的体系。。。delegate是塞给了contentview极其子类 =》所以他说，目前无障碍功能是contentview粒度的，contentView级别的 contentview粒度=》是其对无障碍边界的高度概括。。。而我为什么不能？ 点灰的地方，dialog里的安卓view会收到响应，这是AgpwIndow做的。=》具体代码？ gongashi从架构上推导出，能不能做，有必然性。。。。 不要先用代码去验证，先从架构，有哪些类，从而推导能做哪些事情。。。 哪些类，支撑流程到哪一步 了因: 思考那些不得不的东西，市场，代码，fupiao，题目解法 log不稳定，怎么办 =》log要稳定，要有层次，要干净 log能解决一切，包括类在哪里创建。。。项目中，有没有一个类，以及其子类！！！！！！ viewtree与client关系 clinet单例，新Windows，清掉之前的 》所以，单例也是可以的 只给出解决方法，而不给出缘由，这不是解答！ 了因: 可叠加式进步 可叠加式，如Git，如备份，如docker的commit。毁坏了，瞬间恢复。。。叠加式在于，之前所做，没有浪费，为后期垫脚！！！！！！ 进步 了因: 管理，也讲究减法 学习毕晟，流程化，把账号给别人 利用加分警告早点填表 马占福把计划交给必胜执行，自己早早下班 催人，一定要针对一个人，打击一个人。邮件或群里批评最差的 催人，催主管，让主管施压 任何事情，只和pm对接！！！！！ 有很多问题时，只要针对最多的那个子系统打，不要铺开 如何逼人做事，每半个小时反馈一下 学习知识，更要学习别人的智慧，管理，集合其他人的优点 如何催一群人？一个个打电话，效率低，，，，把所有人拉到一个群里，完成的退群 了因: 理解一定要基于例子，但是也一定要抽象、提炼、甚至升华，，，，看透本质的能力，，，，反思能力，，，轻装上阵，，，，精力，，心流，，，，时间的任何利用，，，你必须非常非常努力，同时着眼于当下，，为什么如是因，如是因！不要管结果。。。。。兴趣也不是最好的老师，而是兴趣导致的坚持。任何事情都怕坚持！！！。。。遇到问题，一定冷静再冷静。。。。。利用一切零碎时间思考，优于集中时间。。。。任何事情，一定要找到深层次的原因，深层次，这样才。。你要成为领导者，不要畏畏缩缩！！。。。人与人之间的差距在于工具，实体工具，思想工具。。。。。。。不着于象。。。。。重心永远在工作上，永远！！！。。。。。。对面若有人，那么你一定比他强，你是能啃硬骨头的人。。。。思路哪里来，参考（参考别人，z参考A)。。。。。刻骨，让公司离开你难受。。。。。做任何事情都要分清主次，尤其是做决定的拼命去学。。。时候。。。。我要成为领导者。。。。思考。。。拉筋，，，聚焦，，，，google ！！！ 27了，真可怕。。。。如何客观评价自己？。。。。对于理解，文字（包括代码是非常操蛋的东西。理解时，脑子想着的东西越具象越好。。。数据永远不会骗人，眼睛会。。（瘦与胖，通过手机视频。。。。。。聚焦事业！！！！。。。。。这短短的一生，我们都将失去，播放大胆一些，勇敢一些，爱一个人，追一个梦，爬一座山。。。。。主动当责。。。。。不可替换。。。。。身体和事业，其他都是副产品。。。。自信！！！！自信。。。。。沉下去。只争朝夕！身体！！！！梳头！！！！格局!!!!!!!!!自我管理与他人管理（必须安排计划表），，，刑法：晚上床上不准手机！！！白天不准床 。。。。？男生说话，不要说带情绪的话，尤其负面情绪的。。。放下。。。军人好睡，犯人好睡（无3c电子产品，千万不要手机）。。无韭菜、洋葱、豆腐、青椒。。。。助眠：牛奶。。。。看书，尤其纸质。。。暗的环境。。。脸皮要厚！。。。声音大！。。。。不要急，慢慢来。。。。。人生就是问题组成的。。。。太有意思了。。。。人脉资源！！！。。。多建立忘年交！。。。。让你的领导毫无顾忌的骂你。。。。能发动各种资源，超过个体价值。。。静能生智（带降噪耳机，闭目）。。。。太有意思了！！！。。。 人生在于做减法，因为做减法留下的东西是本质，而且能留在脑子里；任何问题都记着做减法（人生方向，题目解法，阅读代码，代码架构，做笔记，）。。。。代码运行就是水流，分叉聚合。。。代码如何做减法：分主次—————主，代码流水始终出不来的类为主类，用一次的便是次要的（砍掉）。。。。极致的努力与爱。。 找老婆如找工作，多试。。。。。人活着就是为了解决问题而活，钱名是副产品。。。。情商高，会夸人，苏神，锦科。。。。任何事情都有其底层逻辑。。。。。难问题的解决方法------每天看一下。。。。学会拒绝。。。。念头纷飞，最好的方法是替代，读书。。。学很难很难问题的方法，每天看一遍，尤其睡前。。。。看人与看事一样，先看了轮廓，轮廓最重要。。。。。。。。。单线程去做某些事情，做到专注。。。。。最好的状态是自然。。。任何事情都不要做足，帮人，吃饭，性。。。。缺憾才是恰到好处。。。。学一样东西，先要忘了它（它去理解其存在设计的必要性），学会了更要忘记（学会抽象出其精髓）。。。。。。。。方向大致正确，绝不能很正确。。。。。。多看高手思考的文章与话（一句话胜过十年书，十年磨难你才能总结出的:方向大致正确）。。。。难的问题，深的问题，每天看一遍 。。。。。对人，也要抓住干。。。。。方向大致正确 组织充满活力。。。。极度努力，你可以踢掉公司，而非。。。。。。。30岁了，要学会*聚焦。。。。。行痴。。。。。。任何事物的发展都要由具象到抽象，不断抽象的过程(数学的发展、人的真知、学习，题目---------方法的总结、工作：具体代码，文档设计，领导项目，领导公司，愿景)。。。理解问题一定要具体（结合具体例子），理解后一定要抽象(抽象总结)。。。。性格！！！！！！！！！！！！终其因，是你的性格导致你在组内无法出头。。。。。。关于坚持 、自律、克制欲望终极目标------------------美学 。。。。。。大胆一些。。。。。疯狂去学。。。。抓主干，对技术、着迷，其他永远是顺带的能力。。。。。声音大，气势上压倒别人。。。。记忆与理解，必须依赖具体例子、场景，同时必须总结抽象化。。。。。成为时间的朋友，做一个长跑着。。。。。你必须快速升职加薪，你没钱花了。。。。。学习一定要使用倒逼方法，题目倒逼，代码倒逼（现对名词，知识体系框架名词大概了解一下即可）。。。。充分利用反馈机制。。。。知识，最后一定要有框架，目录！。。。。说话，老余，声音稳定，有底气。。。。。分析思路要清晰。。。。任何事情，强行都不好（感情，学习，记忆，理解，交际），要自然。。。。深刻，向下。。。。。爱。。。屎尿渠，，，，，，被需要的时候才是有价值的，，，， 升级，年薪百万。，，，，一日即一世，，，，，囫囵吐枣，，，抓住主干，熟悉主干后，完善细节，，，，，，，，，，，，如果你的工作招聘一个高中生通过一至三个月就能上手那么你的价值在哪里？，，，，没有年薪百万，没有高职级我会死掉，，，，求求你，让我再多看一道题，多学一个知识点，，，，，，，，，认真，空间，是你的就是你的，，，，，，本质，基础：事物一定要触及本质(不耗时)..打好基础，好时，，，，， 自然是本质本质是自然，，，，，，，，，，加完班的无聊感导致，，一天就是一生，一次就是一生，，，，，求求你，让我再学一会儿，再进步一次，，，求求你，让我追下去，再追下去，，，如魔如疯，，，，一定要识别什么是好的，是深刻的！！学会主动找好的，深刻的，，，，，充分利用切换，加班不可怕，，， 注重效率，即领悟本质的时间！！ 噪音信息太多，害处非常大，=》挑选被别人检验过的，尤其评价好的！！！ 纸上记录： 疑问回答 模式推进问题 计划完成 声音记录： 录音！！！！！ 锚⚓️ 记忆之锚 逻辑之锚 源码，逻辑之锚 很多事情，如何从长的尺度去看？？？？？ 有些人不哄女生，而是和女生讲道理 原因在于，考虑长期的相处方式，而不是像渣男一样，一时的哄骗 太用力的人跑不远。 努力不应该是某种需要被时常觉知的东西,意 志力是短期内会用完的精神能量。 真正坚持到最后的人靠的不是激情,而是恰到 好处的喜欢和投入。 当坚持不再成为需要被言说的事实或是需要被 排练的步骤时,它就成为了我生活的一部 分,而不是什么挂在生活之上的负担。 最长久的陪伴不费心力。如果你真的喜又区 人,真的想在他身边一辈子,就不会说有多么 爱他,而是觉得\"每天能和他在一起,就很 好。 太用力的爱不仅让自己累,也让身边的人累。 https://www.zhihu.com/question/304174916/answer/825079036 把所有问题都放在纸上思考 系统性、流程化 人和动物的差别在于工具 人与人的差别也在于工具》要善于用工具、善于用人！！！！ 绝不看抖音与朋友圈 每天留半个小时抄写经书。半个小时深度思考 高手是深度思考的高手；是自我管理的高手 思考本质的东西 每天早起 每天喝温水 每天晚上列计划，第二天执行 关于睡眠： 裸睡，低温 随时带着腿黑 十二点必须关灯关手机 准点睡，最重要的是准点起，7点半 白天多晒太阳，抑制褪黑素。回家就关灯，留小灯。 休息不一定要睡觉，而在于放空大脑 总论：任何事物总是守衡，均衡的。你要想达到一定目标，就要主动构建差异化 例子1: 睡眠只是其中之一 例子2: 绝大部份时间，要时刻利用大脑深度思考一些东西；也要学会利用十分钟，让大脑完全放空 例子3、坐大部分时间，也要学会站 例子4、大部分时间睁眼看东西，有时候闭上眼睛，看的更清楚 例子5、 做一个极简主义者、本质主义者！！！！！！！！！！！！ 把精力放在本质上 word适合展示具体细节东西。但是很缺乏结构性、框架性东西。如刘刚所说，很散 程序员不是写代码的，代码只是表象 要像SE一样，不写代码，但其实代码都是他写的。 1、把已经写好的代码，转化成对象，事物之间的架构、逻辑。 2、要解决的问题，从对象的架构和逻辑上分析可行性解决方案。。。。》这本质上与代码无关了！ 好的程序猿，一定心中没有代码！！！！！！ gongashi他告诉我，1、不要关注于代码，要有对象提炼。 2、弄懂z之前，一定把安卓的流程弄的非常熟练 调用栈不知道底，如何知道底， 网上搜 找地图 4. 道，天道 道是最大的结构 得道得一切 5. 精力管理 职业生涯，往往精力确定最后跑的多远 意志力是最不可靠的、最不可持续的东西 从底层思想上看，精力管理的精髓在于 抓大放小： 把精力放在大上 5.1. 降低消耗 5.1.1. 他耗： 他人即地狱 具体技巧：对于level比较低、能力弱的人，不要争辩 -----> 只能徒消耗自己 5.1.2. 内耗 具体技巧： 管我屁事 5.1.3. 抓大放小 比如： clion过一段时间，激活码就失效，还得再去找------> 淘宝上6个月激活码才4块。十年也才80 ​ -------> 从经济上，完全是小，不值得投入精力去找免费的 再比如： docker的各种问题，因为docker可以通过jar，每次commit ------> 可以复用，一次解决，终生解决 ​ ------> 可复用的东西，是值得投入精力的 大与小的checkList： 大 小 5.2. 睡眠 关于睡眠： 裸睡，低温 随时带着腿黑 十一点必须关灯关手机 十二点睡 准点睡，最重要的是准点起，7点半 白天多晒太阳，抑制褪黑素。回家就关灯，留小灯。 休息不一定要睡觉，而在于放空大脑 下午以及晚上，一定不要喝茶、奶茶、咖啡 如果晚上实在睡不着，就起来吃饱-----> 吃饱的情况下，容易睡着 脑力劳动者有几大问题： 1、身体没有充分的疲劳导致睡眠往往更差,要么睡不着,要么睡着以后半睡半醒。 -----》 要有足够的身体疲劳 2、大量使用脑力后,一样会产生严重的饥饿感,吃下很多食物和糖分,但是又无法消耗。这就导 致了。脑力劳动者在不配合体力劳动或者严格的自我节制的情况下,会得不到良好的休息, 身体状 态很容易肥胖化和营养过剩。 ----》 如何减少饥饿感？ 3、脑力劳动的疲惫感非常之不明显,一般人疲惫的节奏,和身体天然形成的节奏差别巨大,很难保 持在24小时左右这个周期里, 这就导致了很多人会间歇性的熬夜或者失眠。 4、脑力的消耗会导致人的自控力下降,在需要关灯睡眠的时候,却克制不住自己玩手机,由于光线 的刺激,越来越兴奋。 ----》 自控力下降 5、大脑的疲劳会让人非常不愿意运动,同时自控力下降会使人无法主动运动,缺乏运动。加重失眠 和热量过剩。 这样,就会形成恶性循环,脑力耗尽不能做体力活动。缺乏体力活动,导致难以入睡。睡眠不足, 导致脑力下降。螺旋下滑,而这个循环是非常容易进入,且难以打破的,需要很大的毅力打破 他,但是一两次的放纵或者紧急任务就会把人重新拉入这个循环。 解决方法： 1、尽可能早起,早上醒来马上起床,不要赖床,快速的进入到明亮的环境中去。如果工作生活允 许,可以保持一到两周的强制早起 (6-7点之间)来恢复节律; 2、早上起来进食大量的蛋白质来减少全天的饥饿感。避免因为蛋白质缺乏,而无法自控进食大量 零食导致的营养缺乏型热量过剩所带来的肥胖和精力上限降低的问题; 3、保持饮食的时间,摸索自己的承受度, 把晚饭放在一个睡前不太撑也不太饿的时间点进行; 4、尽可能多晒太阳或者在明亮的光线下(室外)活动一两个小时; 5、摸索自己的睡眠节奏,在睡前的一个合适的时间运动半小时左右。运动后会有一个兴奋期反而睡 不着,但是每个人的兴奋期不一样,所以要自己摸索自己的周期; 6、尽可能安抚自己的情绪,说服自己不为生活中的小事烦心,避免情绪的干扰,消耗仅有的自控力 Q,打乱正常的节奏。 5.3. 内与外 的关系 干活，应该是事件驱动--------> 因为内心是极度不稳定的东西 事情驱动，太痛苦 内心驱动，会很容易放纵。内心的不稳定造成的（对于天才，反而是） 内心的纠结，会导致一个人唯唯诺诺 -------> 内心的外化 是导致人被看不起的根本原因 所以，将外的纠结、物质的贫困 与 心里的平静、富足 分隔开。。。。比如： 佩雷尔曼家徒四壁，内心却异常富足，给人的感觉也是 5.4. 极简主义 与 扣 我们的终极目标：内心世界的极简 -----------> 衍生的表象： 1、对物质的极简。虽然都是物质简单，与扣是完全两种相反的东西： 极简主义：由内向外，内心追求极简，导致外物极简 -----------> 保护了内心与精力 扣： 由外而内，外物的纠结，导致内心的紊乱 -----------> 内耗严重 5.5. 到底要不要 一个光鲜的外壳？ 外壳： 一个邋遢的外表，让人第一印象很差、让人看不起。。。。。。。 一个好的车谈生意能让老板看得起 吹自己的经验、能力，吹高有利于获取更多的资源 同时，如果你对上面的东西，很反感。。。。。那么外势必引起内心的紊乱、内耗 差的外壳 你在公司经常说你是土木毕业的，这样就会让同事觉得你不专业 满心欢喜 --------》如何智慧地解决这一问题呢？ 5.6. 关于心态、心境--------动力问题 进一寸有一寸的欢喜 希望成为查理芒格这种有智慧的人 -----> 如何倒推？ TODO: 其实，心态永远是最重要的。 6. 时间管理 这时间最贵的就是时间 -----》 每天问一下自己，今天的收获是啥？值得嘛？ 7. 阅读 7.1. 为什么要读书？读完书就忘 读完书就应该忘 读书的目的在于： 1、得其神（书中的思想、人格、模型、方法论），忘其形（事情、时间、地点、人物） ---------》 反馈：用 书中模型，应用于生活 2、截取书中的树结构中重要的点 -----> 链接到你的树结构中。同时要做好化简 ​ 注意：如果保持 原书的结构，永远都不是你的 例子： -----------> 链接到你的结构中: (1) 学习的方法树中 或（2） checklist中 7.2. 书单 柳冠中推荐的书籍： 伟大的探索者 ----> 人生的信仰问题 一般系统论：脱离知识结构的元素，是毫无意义的 关于人为事物的科学 自然资本论 7.3. 如何训练思维的深度？ ------> 5why法（向前追因） 和 5so法（向后追果） https://www.zhihu.com/question/19553569/answer/208715100?utm_source=wechat_session&utm_medium=social&utm_oi=903075405244817408&utm_content=group1_Answer&utm_campaign=shareopn 思维的深度，可以说就是逻辑链条的长度。 5why法，简单来说就是连续追问为什么，寻找问题的根因。 一个合理的层次是：追问到问题变得没有意义为止。 为什么东边的墙上有很多鸟粪？ 调查发现，原来是因为墙上有很多蜘蛛，而这些鸟以蜘蛛为食，所以经常在墙附近活动。 为什么墙上有很多蜘蛛？ 因为墙上有很多小虫子，而蜘蛛以这些小虫子为食。 为什么墙上有很多小虫子？ 因为东面墙上有几扇窗子，半晚时候博物馆里的光会从这里透出去，而这些趋光性很强的虫子就被光吸引过来了。 所以，正确的解决问题方法应该是，在窗户那里安装遮光性很强的厚窗帘，这样就能彻底解决问题了。 5 so法 比如金融投资。比如几年前国家发布多个政策，多个场合明确表示要进行产业转型。 So？ 新能源汽车是产业转型的重要方向之一。 So？ 新能源汽车将会迎来很高的产量爆发（新能源汽车股票值得投资）。 So？ 锂电池作为新能源汽车核心部件，其需求量会暴增（锂电池股票值得投资） So？ 锂矿作为锂电池原料，起需求量会暴增（锂矿股票值得投资） 7.4. 思考快与慢： 7.5. 穷查理宝典 7.6. 如何成为技术领域的高手？ 1、学会拆解 2、对拆解后的专项做强加联系！ 7.7. 大家&大书 目的：研究大家的思想。哪怕吃透一个，也足以让你拉开同龄人一个身位。 求真书院的院训是“寻天人乐处，拓万古心胸” 君子生非异也，善假于物也 --》劝学 ---》根本, 洞察力 https://blog.sciencenet.cn/blog-3377-1269721.html 杨振宁和爱因斯坦不断提到的宗教体验是什么? 7.8. 不要骗自己-------费曼方法 “最小作用量”这个话题巴德只与费曼讨论过一次，却深深地印在了费曼的脑海中。[2]费曼说：“他只是解说，他并没有证明任何东西。没有任何复杂的事情，他只是说明有这样一个原理存在。我随即为之倾倒，能以这样不寻常的方式来表达一个法则，简直是个不可思议的奇迹。” 1、衡量自己有没有理解知识的标准：（绝大多数时候，我们会被自己所骗，以为自己理解） 技巧： What I cannot create, I do not understand (只要是)我不能创造的, 我就(还)没有理解。-------> 即：检验自己有没有理解的方法：从0开始，把它创造出来。绝好的方法 2、Know how to solve every problem that has been solved （需要知道“每一个”已被解决问题的解决方法） 7.9. 费曼学习法更一般的理论 参考：https://www.campzhe.com/archives/1280 ----> 好文 布卢姆分类法把学习分为6个层次： 记忆（Remember） 理解（Understand） 应用（Apply） 分析（Analyze） 评价（Evaluate） 创造（Create） 注意：创造，不是一下子创造所有细节 而是：先创造出骨架，再在骨架上填充上血和肉 ---------》所以，创造 和 化简 似乎说的是一件事情 检验是否学会的标准（也是学习的方法）： 如果你没有极度化简，你就没有真正掌握 如果你没有创造出来，你就没有真正掌握 7.10. 教育 https://www.campzhe.com/archives/1428 你们的孩子，并不是你们的孩子 7.11. 性 萨古鲁：https://kknews.cc/news/5jxyxrk.html ​ https://www.bilibili.com/read/cv4760798 8. 管理 管理也是技术， 8.1. 管理他人 管理； 1、管理的表格 2、进度表格：（1）进度有时间 （2）进度有计划、有责任人、有 smart原则 3、每天过进展，每天注上时间，保留历史记录 捅人： 高风险、请审视 针对进度表里的责任人，找到具体的责任人，再具体对进展 提问题： 1、serdes是最复杂的接口—————》所以，提问，关注了这一点 2、必须提问，以怀疑的眼光进行对抗。。。。对抗才能有好的效果。。。不要一团和气 8.2. 自我管理 8.2.1. 每周checklist 跑步 ---》 为了头脑清晰，为了大脑快乐 冥想 思考 阅读 时刻保持好心情，是一切做事的前提 看孩子视频 想象是你的亲人 金刚经 跨过门，十个俯卧撑 乐观 乐趣 ---》 为了大脑快乐 对一切新事物感兴趣（新事物必然战胜旧事物） 永远永远要有热情，不要做一个老人 记忆，与理解，图像+链接： 1、不要浮于文字----看到文字，闭上眼，想象图像 2、建立好 文字----图像的链接： 比如 迪米特法则，从文字很难知道是什么，但： 迪米特吃汉堡包 每天给自己洗脑： 我一定会成为顶尖的人才。一定会在技术上到达顶尖专家的水平。一定会成为管理水平高超之人 我厌恶性、食物、抖音这些低级欲望 我爱道，以及道后面的道。。。模型，模型 我珍惜一切时间 大我：我要推动整个行业的发展，我要成为时代的弄潮儿 我已经30岁了，没有多少时日了，我这辈子一定要为自己的人生做一件大事。 我要把生命献给我的事业。 你若真的喜欢编程，是拦不住的 8.2.2. 时间管理 马斯克： 不按照 时间线 去 列计划 ------> 会造成一件事情，完成不了，其他事情都完成不了 而是给每个任务安排 时间限 ，即：每一件事情最小的时间 ----> Deadline是第一生產力 9. 文章&演讲 list 9.1. 丘成桐 http://wen.org.cn/modules/article/view.article.php/3956 丘成桐：数学与生活 虽然我得到政府奖学金的资助，我在闲暇时还须靠辅导学童挣钱。生活虽然很艰难，但我却学会如何去应付这些困境，并从中取乐。 困难的环境可以令人变得更加成熟。但是反过来说，长久的为生计奔波，对学者的成功却可能是有害的。毕竟，学者需要在一个稳定的环境下成长和发展，才能完成有深度的成果。我观察到历史上的伟大数学家之中，顶多百分之五的人在其整个职业生涯中都身处穷困。在历史上，我们看到一个社会，一个国家，在百战之余，都需要休养生息，才能成长。 9.2. 陆奇 《新范式 新时代 新机会》 ---------- 陆奇 https://www.youtube.com/watch?v=-LECKZqygzk ppt： https://drive.google.com/file/d/1GVwHZAgUYMkjJ-kEGRAc1P_GPGbTAQ2j/view 本质是讲任何复杂体系，包括一个人、一家公司、一个社会，甚至数字化本身的数字化体系，都是复杂体系。“三位一体”包括： “信息”系统（subsystem of information），从环境当中获得信息； “模型”系统（subsystem of model），对信息做一种表达，进行推理和规划； “行动”系统（subsystem of action），我们最终和环境做交互，达到人类想达到的目的。 --------------》 用三位一体来分析任何一个复杂系统 人是模型的组合，人有三种模型： 认知模型，我们能看、能听、能思考、能规划； 任务模型，我们能爬楼梯、搬椅子剥鸡蛋； 领域模型，我们有些人是医生，有些人是律师，有些人是码农。 拐点：模型的成本从边际走向固定 10. 表达 表达是抽象----》 具体应该是思维能力 ----》 再具体：说话思维能力 10.1. 普通聊天如何缓解尴尬？ ------------话题来源： 11. 翟东升2021年预测 1、中美关系局部回暖，但科技封锁会继续----> 中国 2、中欧双边协定会有反复 3、中国在解决卡脖子技术方法：基础软件、工业软件、芯片、光刻机有好消息传来！！！！ 4、新冠疫苗成本竞争 5、人民币对美元将会继续保持一定的强势。 graph TD A(工业用地效率)-->B1(土地利用强度) A-->B2(土地经济效益) B1-->C1(容积率) B1-->C2(建筑系数) B1-->C3(亩均固定资本投入) B2-->D1(亩均工业产值) B2-->D2(亩均税收) graph LR KaTex--> A(标记 Accents) A-->撇,估计,均值,向量等写于符号上下的标记 KaTex--> 分隔符_Delimiters 分隔符_Delimiters-->小中大括号,竖杠,绝对值等分隔符的反斜杠写法 KaTex--> 公式组_Enviroments 公式组_Enviroments-->B(.....) KaTex-->C(...) console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Naturalaw/修.html":{"url":"Naturalaw/修.html","title":"修","keywords":"","body":"1. 减小内耗2. 白骨观TreeviewCopyright © aleen42 all right reserved, powered by aleen42 减小内耗 白骨观 [TOC] 1. 减小内耗 1、自己与自己-------后悔、焦虑 2、与最亲近的人---------如果无法沟通，直接不说 亲近的人，尽量有效沟通 3、 2. 白骨观 白骨观是佛家修持法之一， 为佛教五门禅法之一种，通常由不净观、白骨观、白骨生肌和白骨流光四步组成。主要的目的是息灭对色身的贪恋。佛法的的修持讲色空不二，非空非有、亦空亦有。实际上修气脉，是从有进手，证得空相，最后达亦空亦有的境界。有和空是无差别的。 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Scriptures/":{"url":"Scriptures/","title":"Scriptures","keywords":"","body":"1. IntroductionTreeviewCopyright © aleen42 all right reserved, powered by aleen42 Introduction 1. Introduction console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"Scriptures/金刚经.html":{"url":"Scriptures/金刚经.html","title":"金刚经","keywords":"","body":"1. 正文 & 解释1.1. 第一品 法会因由分2. 参考3. 一些感悟TreeviewCopyright © aleen42 all right reserved, powered by aleen42 第一品 法会因由分 参考 一些感悟 1. 正文 & 解释 1.1. 第一品 法会因由分 如是我闻。一时佛在舍卫国祇树给孤独园。与大比丘众千二百五十人俱。尔时世尊食时。着衣持钵。入舍 卫大城乞食。于其城中次第乞已。还至本处。饭食讫。收衣钵。洗足已。敷座而坐。 注释： 2. 参考 https://www.youtube.com/@supu929 金刚经 3. 一些感悟 知识： 重视智慧，而不是识 经文：重义，而不是文字本身，不是形式本身 修持的根本：善护念（无论佛、道） 渡河之后，弃筏（学佛如此，学习知识也是如此） console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"},"CheckList.html":{"url":"CheckList.html","title":"Check List","keywords":"","body":"1. Daily checkList1. Daily checkList 冥想--15min 身体： 十个俯卧撑 十一点闹钟，关灯光 一直努力在弄环境，追求最好的工具。----> 反而把“主”弄丢了，技术本身 console.log(\"plugin-popup....\");document.onclick = function(e){ e.target.tagName === \"IMG\" && window.open(e.target.src,e.target.src)}img{cursor:pointer}"}}